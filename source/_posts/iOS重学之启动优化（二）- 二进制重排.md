---
title: iOS重学之启动优化（二）- 二进制重排
author: Sunny
tags:
  - iOS
  - 启动优化
categories:
  - iOS
cover: >-
  https://sunny-blog.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2%E5%9B%BE%E6%96%87%E4%BB%B6/cover14.jpg
abbrlink: 23c5d0e7
date: 2022-06-15 18:52:59
---

## 写在前面

在第一部分[iOS重学之启动优化（一）](https://codersunny.com/posts/a5b508b2/)中，我们主要从`Pre-main`和`main`之后两个时间来衡量一个iOS应用启动的时长，以及详细分析了`Pre-main`的四个阶段，其中也提到了一些概念：比如**物理内存**、**虚拟内存**、**缺页中断**等，感兴趣的可以移步上一篇文章了解一下，本文主要跟大家详细讨论一下什么是**二进制重排**、**二进制重排为什么能够优化iOS应用启动时间**等问题。

## 物理内存 & 虚拟内存

**物理内存**：指的是通过物理内存条获得的内存空间。

**虚拟内存**：跟物理内存相反，虚拟内存指的一种计算机系统内存管理技术，它使得应用程序认为它拥有连续可用的内存，实际上它通常被分隔成多个物理内存碎片。

只谈概念太空洞，下面我们用图来解释什么是物理内存、什么是虚拟内存。

物理内存的概述图如下：

![2022061501](https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061501.png)

{% note pink no-icon %}
**分析**：

在没有虚拟内存的概念之前，每个应用一启动，操作系统就会把整个应用放进物理内存里面。
{% endnote %}

{% note green no-icon %}
**物理内存存在的问题**：

+ 内存紧张的问题 - 由于每次都是直接把整个应用放进物理内存里面，很可能出现内存不够用的情况。
+ 进程的安全问题 - 没个进程之间的物理地址是连续的，可以拿到别的进程的地址，容易出现进程不安全的问题。

{% endnote %}

虚拟内存的概述图如下：

![2022061502](https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061502.png)



{% note pink no-icon %}
**分析**：

虚拟内存的技术出现之后，每个进程并不是直接全部扔进物理内存，而是给每个应用分配一个虚拟的内存，虚拟内存通过**虚拟页表**来把相应数据放进物理内存里面。

**虚拟内存**的技术出现之后，也有了**内存分页**的概念，**虚拟页表**把一个进程分成若干页，比如：`Page1`、`Page2`、`Page3`......，当启动进程1的时候，只需要把`Page1`装载进物理内存，以此类推，如上图。

**PS**：大家注意上图的颜色区分能够很好的理解虚拟内存相关概念。

{% endnote %}

{% note green no-icon %}

**虚拟内存**解决了**物理内存**存在的两个问题，由于每个进程的数据被分成了很多页装载进内存，不会再出现内存紧张的问题，而且一个应用在物理内存里面的地址是不连续的，所以无法访问到别的进程的地址，也保证了线程安全。

{% endnote %}

**注意**：虽然一个应用在物理内存中的内存是不连续的，但是访问数据的时候是连续的，原因就在于我们访问数据访问的是对应的虚拟映射表，这个虚拟映射表记录的某个方法、函数对应在物理内存的真实地址。

## 缺页中断（PageFault）

在上面我们说过在有了**虚拟内存**技术之后，内存以分页的形式装载进物理内存里面，比如我们现在启动一个应用只需要先把启动相关的内存`Page1`到`Page10`装载进物理内存，当用到A功能的时候发现数据没有在物理内存里面，此时操作系统会阻塞APP进程触发一次**PageFault**，操作系统会从磁盘中读取相应的数据到物理内存上，再将其映射到虚拟内存页表上面。**PageFault**耗时非常短，平均在0.5ms左右，所以用户一般感知不到，但是有一种情况可能会造成大量的**PageFault**，那就是启动时刻，所以我们就可以思考如何减少启动时的**PageFault**次数，从而优化启动时长。

## 二进制重排

在分析二进制重排之前，我们先了解一下Link Map File是个什么东西。

### 链接映射文件

**链接映射文件**：Link Map File，里面记录的是每个类所生成的可执行文件的路径、CPU架构、符号等信息，可以简单的理解为这个文件告诉了我们一个应用的可执行文件的排列顺序。

{% note pink no-icon %}
BuildSetting - Write Link Map File设置为YES。
{% endnote %}

如图所示：

![2022061504](https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061504.png)

编译项目之后根据上图的地址找到我们需要的Link Map 文件，如图所示：

![2022061505](https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061505.png)

文件资源的编译顺序如下图所示：

![2022061506](https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061506.png)

{% note green no-icon %}
从上图可以看出一个项目可执行文件的排列顺序为：

+ 先按照项目 - Build Phases - Compile Sources中的顺序排列
+ 再按每个文件里面从上至下的方法顺序排列

{% endnote %}

### 什么是二进制重排

重新排列函数符号的位置，降低Mach-o文件载入物理内存时触发的**PageFault**次数，这个就叫**二进制重排**。

### 为什么二进制重排能优化启动时长

我们先来举个例子，一个应用启动需要调用`方法1`、`方法3`、`方法4`、`方法6`、`方法7`，其中`方法1`在Page1页上，`方法6`在Page2页上，`方法3`、`方法7`在Page3页上，`方法4`在Page4页上，如下图所示：

![2022061503](https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061503-20220616141820096.png)

二进制排列后，如下图所示：

![2022061507](https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061507.png)

{% note green no-icon %}

经过二进制重排之后，我们把启动需要调用的方法全部集中在了Page1里面，这样在启动时只需要装载Page1即可，相比之前减少了Page2、Page3、Page4的装载，这就减少了**PageFault**的次数，节省的时间大约为：0.5ms * 3 = 1.5ms。

这也就解释了为什么二进制重排能够优化启动时长。

{% endnote %}

### 二进制重排

iOS 应用之所以能够进行二进制重排其实是因为苹果爸爸早就有了这一套机制，其实`libobjc.order`就是利用二进制重排进行了优化。

![2022061508](https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061508.png)



现在我们来举个简单的例子做二进制重排：

以一个新的项目`LaunchDemo`为例，我在`ViewController.m`文件里面新加了几个方法如下：

![2022061510](https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061510.png)

**一**、在项目根目录下创建一个`.order`文件，我们这里叫：`LaunchDemo.order`文件：

![2022061509](https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061509.png)

我们先看一下默认的一个排列顺序：

![2022061511](https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061511.png)

**二**、在`LaunchDemo.order`文件里面指定每个符号的排列顺序：

![2022061512](https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061512.png)

**三**、在`Build Setting`里面指定`Order File`地址，如图所示：

![2022061513](https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061513.png)

**四**、编译项目，打开Link Map File，如下图所示：

![2022061514](https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061514.png)

{% note orange no-icon %}

**分析**：

经过二进制重排之后我们发现`Link MAp File`文件里面的符号排列顺序已经按照我们指定的顺序排列，其中我们在`LaunchDemo.order`文件里面指定的`-[LaunchDemo test]`符号，项目里面没有这个方法，所以只会被忽略不会报错。

{% endnote %}

到这里为止，二进制重排的整个核心我们就分析得差不多了，但是这个二进制重排有个最大的问题，那就是：我们如何才能准确获取项目启动时刻调用的方法顺序，换句话说我怎么知道我这个项目启动需要调用到哪些方法。

## 写在最后

二进制重排最大的问题我们已经抛出来了，有兴趣的也可以想想应该怎么办，下一篇文章我们将重点分析如何精确获取项目启动时刻调用的方法顺序。












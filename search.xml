<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Hexo】Butterfly 如何替换jsdelivr提升网站访问速度</title>
    <url>/posts/e94df8dd/</url>
    <content><![CDATA[<h2 id="写在前面">写在前面</h2>
<p>大家都知道<code>jsdelivr</code>，而且经常用这个CDN服务，这是一个很快而且免费的CDN服务，但是从去年还是啥时候开始就逐渐出现挂掉，不太好用的情况，前段时间更是大规模的挂掉，对我最直接的影响就是：我这个博客网站打开就是巨慢无比，控制台一堆报错，各种图片无法显示，这对于一个强迫症来说真的不能忍，于是打算换掉Butterfly主题下的<code>jsdelivr</code>CDN服务。</p>
<h2 id="解决办法">解决办法</h2>
<h3 id="办法一">办法一</h3>
<p>这种方法超级简单，只需要简单的一步：</p>
<p><code>butterfly主题下</code> - <code>scripts</code> - <code>events</code> - <code>config.js</code>文件 修改<code>jsdelivr</code>cdn。</p>
<p>将<code>https://cdn.jsdelivr.net</code> 换成 <code>https://fastly.jsdelivr.net</code>或<code>https://gcore.jsdelivr.net</code></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220529/20220529_01.png" alt="20220529_01"></p>
<p>其中<code>fastly</code>是美国的服务器，<code>gcore</code>是俄罗斯的服务器，两个都亲测好用，嫌弃麻烦的同学可以直接替换成这个，访问速度目前来看还是很快的。</p>
<h3 id="办法二">办法二</h3>
<p>修改<code>butterfly主题</code>中的<code>_config.yml</code>文件：</p>
<p>将<code>third_party_provider</code>由<code>jsdelivr</code>换成<code>local</code>：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220529/20220529_02.png" alt="20220529_02"></p>
<p>替换CDN（部分）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">main_css:</span> <span class="string">/css/index.css</span></span><br><span class="line"><span class="attr">main:</span> <span class="string">/js/main.js</span></span><br><span class="line"><span class="attr">utils:</span> <span class="string">/js/utils.js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js</span></span><br><span class="line"><span class="attr">translate:</span> <span class="string">https://npm.elemecdn.com/js-heo@1.0.6/translate/tw_cn.js</span></span><br><span class="line"><span class="attr">pjax:</span> <span class="string">https://npm.elemecdn.com/pjax/pjax.min.js</span></span><br><span class="line"><span class="attr">twikoo:</span> <span class="string">https://npm.elemecdn.com/js-heo@1.0.3/twikoo/twikoo.all.min.js</span></span><br><span class="line"><span class="attr">lazyload:</span> <span class="string">https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js</span></span><br><span class="line"><span class="attr">instantpage:</span> <span class="string">https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js</span></span><br><span class="line"><span class="attr">fancybox_css_v4:</span> <span class="string">https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css</span></span><br><span class="line"><span class="attr">fancybox_v4:</span> <span class="string">https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js</span></span><br><span class="line"><span class="attr">snackbar_css:</span> <span class="string">https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.css</span></span><br><span class="line"><span class="attr">snackbar:</span> <span class="string">https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js</span></span><br><span class="line"><span class="attr">fontawesomeV6:</span> <span class="string">https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css</span></span><br><span class="line"><span class="attr">aplayer_css:</span> <span class="string">https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css</span></span><br><span class="line"><span class="attr">aplayer_js:</span> <span class="string">https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js</span></span><br><span class="line"><span class="attr">meting_js:</span> <span class="string">https://npm.elemecdn.com/js-heo@1.0.12/metingjs/Meting.min.js</span></span><br></pre></td></tr></table></figure>
<p>以上是我使用的一些cdn，其他的cdn如有补充的可以在评论里留言。</p>
<p>这里推荐字节跳动的静态资源公共库：<a href="https://cdn.bytedance.com">https://cdn.bytedance.com</a></p>
<h3 id="办法三">办法三</h3>
<p>为<code>jsdelivr</code>搭建反向代理服务，比如使用<a href="https://www.cloudflare.com/zh-cn/">Cloudflare</a>自行去搭建。</p>
<h2 id="最后">最后</h2>
<p>本文就写到这里了，如有问题，欢迎随时联系博主，博主马上修改。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hexo】Butterfly主题配置（持续更新）</title>
    <url>/posts/391caf66/</url>
    <content><![CDATA[<h2 id="升级建议">升级建议</h2>
<p>为了减少升级以后带来的不便，建议请按照下面的方式进行操作：</p>
<p>在博客根目录下创建一个文件：<code>_config.butterfly.yml</code>，并把<code>butterfly</code>主题目录下的<code>_config.yml</code>内容复制到该文件中（注意：复制的是<a href="">butterfly主题目录</a>下的<code>_config.yml</code>不是博客根目录中的<code>_config.yml</code>）。</p>
<p>以后只需要在<code>_config.butterfly.yml</code>文件里进行修改即可。</p>
<blockquote>
<p><strong>注意</strong>：butterly主题目录下的<code>_config.yml</code><strong>不要删除，不要删除，不要删除，重要的事情说三遍。</strong></p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：如果你项目中使用了<code>_config.butterfly.yml</code>文件，在主题目录下的<code>_config.yml</code>修改不会有效果。</p>
</blockquote>
<p>如图，以后我们只需要关注这两个配置文件即可：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202205/20220514_01_01.png" alt="20220514_01_01"></p>
<h2 id="scaffolds文件夹">scaffolds文件夹</h2>
<p>博客目录下有一个文件夹<code>scaffolds</code>，这个是模版文件夹，当我们新建页面或者文章时，<code>hexo</code> 会根据<code>scaffolds</code>来建立文件。</p>
<p>顾名思义，模版就是指新建的文章或页面默认的内容，比如我修改了<code>scaffolds</code>下的<code>post.md</code>：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202205/20220514_01_02.png" alt="20220514_01_02"></p>
<p>这样每次我新建的文章顶部都有这些默认内容，能添加的字段很多，具体参考<a href="https://butterfly.js.org/posts/dc584b87/#Post-Front-matter">butterfly主题官方文档</a>。</p>
<h2 id="config-yml文件">_config.yml文件</h2>
<h3 id="修改网站标题、副标题等信息">修改网站标题、副标题等信息</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网站设置</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Sunny</span> <span class="comment"># 网站名称</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span> <span class="comment"># 副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">千里之行，始于足下</span> <span class="comment">#  描述行文字：你可以理解为个性签名</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="comment"># 关键词</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Sunny</span> <span class="comment"># 作者 </span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment"># 语言 default(en)/ zh-CN（简体）/ zh-TW（繁体）</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span> <span class="comment"># 时区</span></span><br></pre></td></tr></table></figure>
<h3 id="url相关配置">url相关配置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网站url 默认是https://example.com 如果使用的是github pages 请设置成 https://xxx.github.io</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://codersunny.com</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title/</span> <span class="comment"># 永久链接</span></span><br><span class="line"><span class="attr">permalink_defaults:</span> <span class="comment"># 默认永久链接</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：如果<code>url</code>不修改使用默认<code>https://example.com</code>，文章末尾的链接是打不开的。</p>
</blockquote>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202205/20220514_01_03.png" alt="20220514_01_03"></p>
<h2 id="config-butterfly-yml文件">_config.butterfly.yml文件</h2>
<h3 id="写在前面-2">写在前面</h3>
<p>本文基本上是按照<code>_config.butterfly.yml</code>文件从上到下的顺序来总结的，大家看的时候对照着设置即可。</p>
<h3 id="导航栏菜单">导航栏菜单</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">   <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">   <span class="string">音乐库:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">  <span class="comment"># Archives: /archives/ || fas fa-archive</span></span><br><span class="line">  <span class="comment"># Tags: /tags/ || fas fa-tags</span></span><br><span class="line">  <span class="comment"># Categories: /categories/ || fas fa-folder-open</span></span><br><span class="line">  <span class="comment"># List||fas fa-list:</span></span><br><span class="line">  <span class="comment"># Movie: /movies/ || fas fa-video</span></span><br><span class="line">  <span class="comment"># Link: /link/ || fas fa-link</span></span><br><span class="line">  <span class="comment"># About: /about/ || fas fa-heart</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：必须是<code>/xxx/</code> + <code>||</code> + <code>图标名</code>，如果不想展示图标可以不写图标名。</p>
</blockquote>
<p>我这里暂时只配置了两个，效果如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202205/20220514_01_06.png" alt="20220514_01_06"></p>
<h3 id="代码高亮相关设置">代码高亮相关设置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span> <span class="string">mac</span> <span class="comment"># 高亮主题： darker / pale night / light / ocean / mac / mac light / false</span></span><br><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span> <span class="comment"># 是否展示复制按钮 copy button</span></span><br><span class="line"><span class="attr">highlight_lang:</span> <span class="literal">true</span> <span class="comment"># 是否展示代码块语言 show the code language</span></span><br><span class="line"><span class="attr">highlight_shrink:</span> <span class="literal">false</span> <span class="comment"># 是否展开代码框 true: shrink the code blocks / false: expand the code blocks | none: expand code blocks and hide the button</span></span><br><span class="line"><span class="attr">highlight_height_limit:</span> <span class="literal">false</span> <span class="comment"># unit: px</span></span><br><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">true</span> <span class="comment"># 是否关闭代码滚动条</span></span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202205/20220514_01_07.png" alt="20220514_01_07"></p>
<h3 id="复制相关配置">复制相关配置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># copy settings</span></span><br><span class="line"><span class="comment"># copyright: Add the copyright information after copied content (复制的内容加上版权信息)</span></span><br><span class="line"><span class="attr">copy:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启网站复制权限</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启复制版权信息添加</span></span><br><span class="line">    <span class="attr">limit_count:</span> <span class="number">50</span> <span class="comment"># 超过这个字数会在复制内容后面加上版权信息</span></span><br></pre></td></tr></table></figure>
<h3 id="社交图标">社交图标</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># social settings (社交图标设置)</span></span><br><span class="line"><span class="comment"># formal:</span></span><br><span class="line"><span class="comment">#   icon: link || the description</span></span><br><span class="line"><span class="comment"># 书写格式：图标名:url || 描述性文字</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">   <span class="attr">fab fa-github:</span> <span class="string">https://github.com/xxx</span> <span class="string">||</span> <span class="string">Github</span></span><br><span class="line">   <span class="attr">fas fa-envelope:</span>  <span class="string">mailto:xxx@gmail.com</span> <span class="string">||</span> <span class="string">Email</span></span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202205/20220514_01_08.png" alt="20220514_01_08"></p>
<h3 id="头像和顶部图配置">头像和顶部图配置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Favicon（网站图标）</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/images/avatar.png</span></span><br><span class="line"><span class="comment"># Avatar (头像)</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">/images/avatar.png</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span> <span class="comment"># 是否开启头像的动效</span></span><br><span class="line"><span class="attr">disable_top_img:</span> <span class="literal">false</span> <span class="comment"># 如果不需要展示顶部图 设置为true</span></span><br><span class="line"><span class="attr">index_img:</span> <span class="string">/images/background.png</span> <span class="comment"># 主页的top_img</span></span><br><span class="line"><span class="attr">default_top_img:</span> <span class="string">/images/default_post_cover.png</span> <span class="comment"># 默认的顶部图 如果top_img没有配置时，会显示default_top_img</span></span><br><span class="line"><span class="attr">archive_img:</span> <span class="string">/images/default_post_cover.png</span> <span class="comment"># 归档页面的top_img</span></span><br><span class="line"><span class="attr">tag_img:</span> <span class="string">/images/default_post_cover.png</span> <span class="comment"># tag子页面的top_img</span></span><br><span class="line"><span class="attr">tag_per_img:</span> <span class="comment"># tag子页面的 top_img，可配置每个tag 的 top_img</span></span><br><span class="line"><span class="attr">category_img:</span> <span class="string">/images/default_post_cover.png</span>  <span class="comment"># category子页面的top_img</span></span><br><span class="line"><span class="attr">category_per_img:</span>  <span class="comment"># category子页面的 category_img，可配置每个category 的 top_img</span></span><br></pre></td></tr></table></figure>
<p>部分效果图如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202205/20220514_01_09.png" alt="20220514_01_09"></p>
<h3 id="文章封面配置">文章封面配置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span> <span class="comment"># 是否显示文章封面</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span> <span class="comment"># 文章侧边栏是否开启</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span> <span class="comment"># 归档是否开启</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">both</span> <span class="comment"># 封面显示的位置 left/right/both both表示左右两边交替显示</span></span><br><span class="line">  <span class="attr">default_cover:</span> <span class="comment"># 当没有设置文章封面时 默认的封面展示</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">https://sunny-blog.oss-cn-beijing.aliyuncs.com/default_post_cover.png</span></span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202205/20220514_01_10.png" alt="20220514_01_10"></p>
<h3 id="404页面和无法显示的图片配置">404页面和无法显示的图片配置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换无法显示的图片的图片</span></span><br><span class="line"><span class="attr">error_img:</span></span><br><span class="line">  <span class="attr">flink:</span> <span class="string">/images/friend_404.gif</span></span><br><span class="line">  <span class="attr">post_page:</span> <span class="string">/images/404.jpg</span></span><br><span class="line"><span class="comment"># 404页面</span></span><br><span class="line"><span class="attr">error_404:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">subtitle:</span> <span class="string">&#x27;抱歉，页面没有找到～&#x27;</span></span><br><span class="line">  <span class="attr">background:</span> <span class="string">https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png</span></span><br></pre></td></tr></table></figure>
<h3 id="文章显示信息配置">文章显示信息配置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">page:</span> <span class="comment"># Home Page</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># created or updated or both 主页文章日期是创建日或者更新日或都显示</span></span><br><span class="line">    <span class="attr">date_format:</span> <span class="string">date</span> <span class="comment"># date/relative 显示日期还是相对日期</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 主页是否显示分类</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 主页是否显示标签</span></span><br><span class="line">    <span class="attr">label:</span> <span class="literal">true</span> <span class="comment"># true or false 显示描述性文字</span></span><br><span class="line">  <span class="attr">post:</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># created or updated or both 文章日期是创建日或者更新日或都显示</span></span><br><span class="line">    <span class="attr">date_format:</span> <span class="string">date</span> <span class="comment"># date/relative 显示日期还是相对日期</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 文章是否显示分类</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 文章頁是否显示标签</span></span><br><span class="line">    <span class="attr">label:</span> <span class="literal">true</span> <span class="comment"># true or false 显示描述性文字</span></span><br></pre></td></tr></table></figure>
<h3 id="字数统计">字数统计</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wordcount (字数统计)</span></span><br><span class="line"><span class="comment"># see https://butterfly.js.org/posts/ceeb73f/#字数统计</span></span><br><span class="line"><span class="attr">wordcount:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_wordcount:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：如果打开字数统计插件，请务必要先安装插件。</p>
<p>进入根目录下，使用命令<code>npm install hexo-wordcount --save</code>或<code>yarn add hexo-wordcount</code>安装字数统计的插件。</p>
</blockquote>
<h3 id="文章末尾版权信息设置">文章末尾版权信息设置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启文章后面的复制信息</span></span><br><span class="line">  <span class="attr">decode:</span> <span class="literal">true</span> <span class="comment"># 是否解码</span></span><br><span class="line">  <span class="attr">author_href:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202205/20220514_01_11.png" alt="20220514_01_11"></p>
<h3 id="打赏功能配置">打赏功能配置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打赏功能</span></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启</span></span><br><span class="line">  <span class="attr">QR_code:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">/images/wechat_pay.png</span></span><br><span class="line">       <span class="attr">link:</span></span><br><span class="line">       <span class="attr">text:</span> <span class="string">微信</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">/images/ali_pay.png</span></span><br><span class="line">       <span class="attr">link:</span></span><br><span class="line">       <span class="attr">text:</span> <span class="string">支付宝</span></span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202205/20220514_01_12.png" alt="20220514_01_12"></p>
<h3 id="分享功能配置">分享功能配置</h3>
<p>有三个分享服务商：<code>AddThis</code>、<code>Sharejs</code>、<code>Addtoany</code>，只能选择其中一个，我这里使用默认的<code>Sharejs</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Share.js</span></span><br><span class="line"><span class="comment"># https://github.com/overtrue/share.js</span></span><br><span class="line"><span class="attr">sharejs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sites:</span> <span class="string">facebook,twitter,wechat,weibo,qq</span></span><br></pre></td></tr></table></figure>
<h3 id="网站页脚配置">网站页脚配置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">since:</span> <span class="number">2020</span></span><br><span class="line">  <span class="attr">custom_text:</span> <span class="string">Hi,</span> <span class="string">welcome</span> <span class="string">to</span> <span class="string">my</span> <span class="string">&lt;a</span> <span class="string">href=&quot;https://codersunny.com&quot;&gt;blog&lt;/a&gt;!</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="literal">true</span> <span class="comment"># Copyright of theme and framework</span></span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202205/20220514_01_13.png" alt="20220514_01_13"></p>
<h3 id="网站背景图片配置">网站背景图片配置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Website Background (设置网站背景)</span></span><br><span class="line"><span class="comment"># can set it to color or image (可設置图片 或者 颜色)</span></span><br><span class="line"><span class="comment"># The formal of image: url(http://xxxxxx.com/xxx.jpg)</span></span><br><span class="line"><span class="attr">background:</span> <span class="string">/images/background.png</span></span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202205/20220514_01_14.png" alt="20220514_01_14"></p>
<h3 id="网站副标题设置">网站副标题设置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># the subtitle on homepage (主页subtitle)</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># loop (循环打字)</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># source 调用第三方服务</span></span><br><span class="line">  <span class="comment"># source: false 开闭调用</span></span><br><span class="line">  <span class="comment"># source: 1  调用一言网的一句話（简体） https://hitokoto.cn/</span></span><br><span class="line">  <span class="comment"># source: 2  调用一句网（简体） http://yijuzhan.com/</span></span><br><span class="line">  <span class="comment"># source: 3  调用今日诗词（简体） https://www.jinrishici.com/</span></span><br><span class="line">  <span class="comment"># subtitle 會先显示 source , 再显示 sub 的內容</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果关闭打字效果，subtitle 只会显示 sub 的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">自信且温和，温和且坚定</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Loading Animation (加载动画)</span></span><br><span class="line"><span class="attr">preloader:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="侧边栏配置">侧边栏配置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 侧边栏是否开启</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># 是否在手机上显示</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span> <span class="comment"># 侧边栏位置 left or right</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">card_author:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span></span><br><span class="line">    <span class="attr">button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">Github</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://github.com/xxx</span></span><br><span class="line">  <span class="attr">card_announcement:</span> <span class="comment"># 公告栏内容</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">欢迎来到Sunny的技术杂货铺，如果喜欢记得收藏奥～</span></span><br><span class="line">  <span class="attr">card_recent_post:</span> <span class="comment"># 最新文章</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span> <span class="comment"># 如果设置为0 将会展示所有文章</span></span><br><span class="line">    <span class="attr">sort:</span> <span class="string">date</span> <span class="comment"># date or updated</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202205/20220514_01_15.png" alt="20220514_01_15"></p>
<h3 id="简繁转换、夜间模式等配置">简繁转换、夜间模式等配置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Conversion between Traditional and Simplified Chinese (简繁转换)</span></span><br><span class="line"><span class="attr">translate:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">default:</span> <span class="string">简</span> <span class="comment"># 默认的按钮文字</span></span><br><span class="line">  <span class="comment"># the language of website (1 - Traditional Chinese/ 2 - Simplified Chinese）</span></span><br><span class="line">  <span class="attr">defaultEncoding:</span> <span class="number">2</span></span><br><span class="line">  <span class="comment"># Time delay</span></span><br><span class="line">  <span class="attr">translateDelay:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">msgToTraditionalChinese:</span> <span class="string">&#x27;繁&#x27;</span> <span class="comment"># 当前是简体时 按钮文字</span></span><br><span class="line">  <span class="attr">msgToSimplifiedChinese:</span> <span class="string">&#x27;简&#x27;</span> <span class="comment"># 当前是繁体时 按钮文字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read Mode (阅读模式)</span></span><br><span class="line"><span class="attr">readmode:</span> <span class="literal">true</span> <span class="comment"># 是否打开阅读模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 深色模式</span></span><br><span class="line"><span class="attr">darkmode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Toggle Button to switch dark/light mode</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">autoChangeMode:</span> <span class="literal">false</span> <span class="comment"># 是否自动切换</span></span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202205/20220514_01_16.png" alt="20220514_01_16"></p>
<h3 id="查看大图配置">查看大图配置</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Lightbox (图片大图查看模式)</span></span><br><span class="line"><span class="comment"># You can only choose one, or neither (只能选择一个 或者 两个都不选)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># medium-zoom</span></span><br><span class="line"><span class="comment"># https://github.com/francoischalifour/medium-zoom</span></span><br><span class="line"><span class="attr">medium_zoom:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fancybox</span></span><br><span class="line"><span class="comment"># http://fancyapps.com/fancybox/3/</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202205/20220514_01_17.png" alt="20220514_01_17"></p>
<h2 id="最后-2">最后</h2>
<p>基本上到这里，关于<code>butterfly</code>主题的一些基础配置就可以了，关于更多的模块配置可以参考<a href="https://butterfly.js.org/">butterfly主题官方文档</a>。</p>
<p>官方文档永远是最好的学习资料。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hexo】Mac OS上使用Hexo + Github搭建博客教程</title>
    <url>/posts/47556fe7/</url>
    <content><![CDATA[<h2 id="Hexo介绍">Hexo介绍</h2>
<p>Hexo是一个快速、简洁且高效的博客框架，具体可以见<a href="https://hexo.io/zh-cn">Hexo官网</a>，它在github上的star数现在已经到34.7k，Hexo主要有以下特点：</p>
<ol>
<li>超快速度：Node.js所带来的超快生成速度，可以让上百个页面在几秒内完成渲染。</li>
<li>支持Markdown：Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</li>
<li>一键部署：只需一条指令即可部署到 GitHub Pages, Heroku 或其他平台。</li>
<li>插件或可扩展性：强大的 API 带来无限的可能，与数种模板引擎（EJS，Pug，Nunjucks）和工具（Babel，PostCSS，Less/Sass）轻易集成。</li>
</ol>
<h2 id="安装环境">安装环境</h2>
<h3 id="安装Node-js">安装<code>Node.js</code></h3>
<p>下载地址：<a href="https://nodejs.org/en/">Node.js</a></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_01.png" alt="20220509_01"></p>
<h3 id="安装淘宝镜像">安装淘宝镜像</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 使用命令安装淘宝镜像：</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org </span><br></pre></td></tr></table></figure>
<h2 id="安装Hexo">安装Hexo</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 使用命令去安装Hexo</span><br><span class="line">cnpm install -g hexo-cli </span><br></pre></td></tr></table></figure>
<h3 id="安装成功">安装成功</h3>
<p>安装成功后，使用<code>hexo -v</code>命令去查看Hexo的版本：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_02.png" alt="20220509_02"></p>
<h2 id="初始化Hexo-Blog">初始化Hexo Blog</h2>
<h3 id="新建一个文件夹">新建一个文件夹</h3>
<p>我这里创建一个名为Blogs的文件夹，并进入该文件夹内</p>
<h3 id="初始化Hexo">初始化Hexo</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 初始化hexo</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>初始化成功如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_03.png" alt="20220509_03"></p>
<p>这时候Blogs下的目录结构如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_04.png" alt="20220509_04"></p>
<h3 id="本地启动Hexo">本地启动Hexo</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 启动Hexo</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_05.png" alt="20220509_05"></p>
<p>浏览器打开博客网站</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_06.png" alt="20220509_06"></p>
<h2 id="创建博客文章">创建博客文章</h2>
<h3 id="创建博客">创建博客</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 创建一篇博客</span><br><span class="line">hexo n <span class="string">&quot;我的第一篇博客文章&quot;</span></span><br></pre></td></tr></table></figure>
<p>文章在Blogs目录下的结构如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_07.png" alt="20220509_07"></p>
<h3 id="清理项目缓存">清理项目缓存</h3>
<p>新增博客文章或者修改博客文章内容，需要执行此命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 清理之前生成的网站</span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<h3 id="重新生成博客">重新生成博客</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 重新生成博客</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<h3 id="再次启动项目">再次启动项目</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 再次启动博客网站</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>浏览器页面展示如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_08.png" alt="20220509_08"></p>
<h2 id="修改网站主题">修改网站主题</h2>
<p>Hexo框架默认的是landscape主题，Hexo上有三百多种主题，大家可以上<a href="https://hexo.io/themes/">Hexo官网</a>选择自己喜欢的主题，我这里以butterfly为例：</p>
<h3 id="下载butterfly主题">下载butterfly主题</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 下载butterfly</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_09.png" alt="20220509_09"></p>
<p>我们下载的主题都存放在Blogs/themes文件夹下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_10.png" alt="20220509_10"></p>
<h3 id="修改项目配置文件">修改项目配置文件</h3>
<p>主题下载下来之后，我们需要在项目配置文件_config.yml里面修改我们的主题：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_11.png" alt="20220509_11"></p>
<p>把默认的<code>landscape</code>修改为我们下载好的主题 <code>butterfly</code></p>
<h3 id="重新生成项目">重新生成项目</h3>
<p>这时候再执行我们Hexo三连：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 清理项目缓存</span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">// 重新生成项目</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">// 本地启动项目</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>Tips：重新生成项目和本地启动项目可以合并：<code>hexo g &amp; hexo s</code></p>
<p>再次打开项目，效果图如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_12.png" alt="20220509_12"></p>
<p>哈哈哈哈，惊不惊喜，意不意外，这是个什么鬼东西？？？</p>
<p>别慌，发现问题 - 找到问题 - 分析问题 - 解决问题：</p>
<p>原因其实也很简单，我们没有安装pug和stylus的渲染器，执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 在Blogs目录下 安装pug 和 stylus渲染器</span><br><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br></pre></td></tr></table></figure>
<p>安装完成后，重新生成项目：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_13.png" alt="20220509_13"></p>
<p>到这里，我们的主题修改就完成了，后期我们可以根据自己的需要去修改butterfly的配置文件，让我们的博客网站更加个性化。</p>
<p>下一篇文章我将说说如何修改主题让我们的博客网站更具个性化。</p>
<p>关于Hexo搭建博客到这里就讲得差不多了，下面我们就想怎么把博客部署到Github上。</p>
<h2 id="部署博客到Github">部署博客到Github</h2>
<p>首先，你得要有一个自己的Github账号吧，我相信99.99%的开发者都是有Github账号的，如果你是那0.01%，请前往<a href="https://github.com/">Github</a>自行注册。</p>
<h3 id="创建仓库">创建仓库</h3>
<p>在Github里创建一个存放博客项目的仓库，操作如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_14.png" alt="20220509_14"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_15.png" alt="20220509_15"></p>
<p>这里有两个注意点：</p>
<ol>
<li>仓库的名称必须与你Github账号名相同</li>
<li>仓库必须以<code>gitHub.io</code>结尾</li>
</ol>
<p>比如你Github账号名叫：<code>zhangsan</code>，那你新建的这个仓库名就叫：<code>zhangsan.github.io</code></p>
<p>创建之后，我们就有了一个存放博客项目仓库：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_16.png" alt="20220509_16"></p>
<h3 id="安装Hexo部署插件">安装Hexo部署插件</h3>
<p>进入到Blogs目录下，安装部署插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_17.png" alt="20220509_17"></p>
<h3 id="修改项目配置文件-2">修改项目配置文件</h3>
<p>好了，万事俱备，只欠修改_config.yml文件了，打开_config.yml文件，拖拽到最后，修改文件：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_18.png" alt="20220509_18"></p>
<p>修改为：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_19.png" alt="20220509_19"></p>
<p>注意：repo为你刚创建的Github项目的地址，如果你是使用的vim打开的_config.yml，记得修改了要:wq保存退出</p>
<h3 id="重新生成项目-2">重新生成项目</h3>
<p>清理项目缓存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>重新生成博客：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>部署到云端（Github）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>注意：这里每次使用<code>hexo d</code>部署到Github为了安全都要求输入账号密码，如果你不希望每次都输入账号密码，可以跟博主一样设置Github的SSH Keys，以后每次发布到Github就不需要输入账号密码了。</p>
<h3 id="访问云端博客主页">访问云端博客主页</h3>
<p>访问地址：<a href="https://happycodersunny.github.io/">https://happycodersunny.github.io</a></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220509/20220509_20.png" alt="20220509_20"></p>
<h2 id="最后-3">最后</h2>
<p>基本上到这里，属于我们自己的博客就搭建完成啦，撒花🎉🎉🎉～，整个搭建流程如果不出错半个小时之内其实是可以搞定的，但是这路哪里那么好走呢，每个人去搭建的过程中或多或少都会遇到一些问题，我自己在搭建的过程中也碰到了一些问题，我会抽空把遇到的问题详细整理出来，希望能够帮助大家如果要搭建博客的时候少踩点坑。</p>
<p>嘻嘻嘻，都看到这里了，不要吝啬你的小星星嘛，为博主点个赞呐～</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hexo】Hexo博客备份到Github</title>
    <url>/posts/da31eaeb/</url>
    <content><![CDATA[<h2 id="为什么要备份">为什么要备份</h2>
<p>在<a href="https://happycodersunny.github.io/2022/05/09/%E3%80%90Hexo%E3%80%91Mac%20OS%E4%B8%8A%E4%BD%BF%E7%94%A8Hexo%20+%20Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/">这篇文章</a>中我们把<code>Hexo</code> 和 <code>Github</code>结合起来搭建了自己的个人博客，<code>hexo d</code>部署到<code>Github</code>的其实<code>Hexo</code>编译后的文件，这些文件是用来生成网页的，并不包含我们的源文件：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220511/20220511_01.png" alt="20220511_01"></p>
<p>它其实上传到<code>Github</code> 的是在我们本地目录里的<code>.deploy_git</code>里面的内容：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220511/20220511_02.png" alt="20220511_02"></p>
<p>我们的源文件比如相关<code>source </code>文件、配置文件等都是没有上传到<code>Github</code>上的，所以我们要利用<code>git</code>来做分支管理，对我们的源文件进行备份，这样我们就可以在另一台电脑上把源文件<code>clone</code>到本地安装相应的环境就可以继续写我们的博客了。</p>
<p>好了，废话少说，我们直接来说如何进行博客源文件的备份。</p>
<h2 id="Hexo-博客备份">Hexo 博客备份</h2>
<h3 id="创建新分支">创建新分支</h3>
<p>在<code>Github</code>上博客仓库下创建一个新的分支<code>hexo</code>，并且将这个分支设置为默认分支，具体操作如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220511/20220511_03.png" alt="20220511_03"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220511/20220511_04.png" alt="20220511_04"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220511/20220511_05.png" alt="20220511_05"></p>
<h3 id="克隆Hexo分支">克隆Hexo分支</h3>
<p>在本地把我们刚建的分支<code>hexo</code>克隆到本地：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220511/20220511_06.png" alt="20220511_06"></p>
<p>把克隆下来的项目里面的<code>.git</code>文件复制到我们的Hexo博客目录下:</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220511/20220511_07.png" alt="20220511_07"></p>
<blockquote>
<p><strong>注意</strong>：如果之前搭建博客的时候自己更换过主题文件的，请把主题文件里面的<code>.git</code>文件删除。</p>
</blockquote>
<h3 id="开始备份">开始备份</h3>
<p>进入到Blogs根目录下，执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Blog源文件备份&quot;</span></span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure>
<p>这时候我们会看到<code>Github</code>上的<code>hexo</code> 分支就有我们的源文件了。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220511/20220511_08.png" alt="20220511_08"></p>
<p>如果你想要每次更改东西都希望备份到<code>hexo</code> 分支上，可以执行如下步骤：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;备份&quot;</span></span><br><span class="line">git push</span><br><span class="line">hexo g &amp; hexo d</span><br></pre></td></tr></table></figure>
<h2 id="如何恢复博客">如何恢复博客</h2>
<p>假如我们现在更换了电脑，希望在新的电脑上继续写博客，把<code>Github</code>上<code>hexo</code>分支上的项目克隆到本地（注意：是我们备份的那个分支）</p>
<p>进入到克隆下来的文件夹，执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p>然后再去安装主题相关的插件即可，当然如果你电脑上还没有 <code>Node.js</code>等环境的话可能还需要去安装相关的环境。</p>
<p>现在我们就基本上可以在另一台电脑上继续我们的博客之旅啦～</p>
<h2 id="最后-4">最后</h2>
<p>到这里，如何备份Hexo博客以及如何恢复Hexo博客就基本结束啦。</p>
<p>嘻嘻嘻，都看到这里了，不要吝啬你的小星星嘛，为博主点个赞呐～</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hexo】Twikoo评论系统配置教程</title>
    <url>/posts/feb84685/</url>
    <content><![CDATA[<h2 id="写在前面-3">写在前面</h2>
<p>Hexo博客里面支持的评论系统有：<code>Disqus</code>、<code>Disqusjs</code>、<code>Livere</code>、<code>Gitalk</code>、<code>Valine</code>、<code>Waline</code>、<code>Utterances</code>、<code>Facebook Comments</code>、<code>Twikoo</code>、<code>Giscus</code>，这里面有的评论有的是国外的服务器、有的有广告，本文要讲的<code>Twikoo</code>是在butterfly3.3之后支持的，它支持邮件提醒、微信提醒等功能，还是非常好用的。</p>
<blockquote>
<p><strong>注意</strong>：本文仅针对腾讯云的部署方式中的「手动部署」，其他详细部署方式请参考<a href="https://cloud.tencent.com/act?cps_key=44b3b34da3e3b77bae971b11ed4b2639&amp;fromSource=gwzcw.3814800.3814800.3814800&amp;utm_id=gwzcw.3814800.3814800.3814800&amp;utm_medium=cps&amp;page=cloudbase01">官方文档</a>。</p>
</blockquote>
<h2 id="购买云开发套餐">购买云开发套餐</h2>
<p><strong>温馨提示</strong>：如果你已经拥有云开发环境，可以忽略这一步，直接到【登录授权】。</p>
<p><strong>1、<strong>进入<a href="https://cloud.tencent.com/act?cps_key=44b3b34da3e3b77bae971b11ed4b2639&amp;fromSource=gwzcw.3814800.3814800.3814800&amp;utm_id=gwzcw.3814800.3814800.3814800&amp;utm_medium=cps&amp;page=cloudbase01">云开发CloudBase</a>，进行</strong>登录</strong>、<strong>实名认证</strong>操作，点击<strong>控制台</strong>：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220605/2022060501.png" alt="2022060501"></p>
<p><strong>2、<strong>点击</strong>云产品</strong>，选择<strong>云开发CloudBase</strong>：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220605/2022060502.png" alt="2022060502"></p>
<p><strong>3、<strong>点击</strong>新建</strong>，选择<strong>空模板</strong>，点击下一步：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220605/2022060503.png" alt="2022060503"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220605/2022060504.png" alt="2022060504"></p>
<p><strong>4</strong>、选择合适的套餐进行购买：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220605/2022060505.png" alt="2022060505"></p>
<blockquote>
<p><strong>温馨提示</strong>：</p>
<p>地域选择【上海】</p>
<p>计费方式选择【包年包月】</p>
<p>环境名称自由填写</p>
<p>套餐版本选择【特惠基础版1】</p>
</blockquote>
<p><strong>5</strong>、按照上面的步骤操作之后，我们会拥有一个云开发环境：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220605/2022060506.png" alt="2022060506"></p>
<blockquote>
<p><strong>注意</strong>：记录一下这个环境ID，我们后面会用。</p>
</blockquote>
<h2 id="登录授权">登录授权</h2>
<p>环境 - 登录授权 - 开启【匿名登录】</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220605/2022060507.png" alt="2022060507"></p>
<h2 id="安全配置">安全配置</h2>
<p>环境 - 安全配置 - 添加域名：将自己的域名添加进去</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220605/2022060508.png" alt="2022060508"></p>
<blockquote>
<p><strong>温馨提示</strong>：</p>
<p>如果更改了域名发现评论加载不出来的情况，请记得回来更改为最新域名，尤其是那些刚开始使用 github.io来作为自己博客域名的童鞋，哪天购买了自己的域名，记得换，记得换，记得换（重要的事情说三遍）。</p>
</blockquote>
<h2 id="云函数">云函数</h2>
<p><strong>1</strong>、环境 - 云函数 - 新建云函数</p>
<blockquote>
<p><strong>温馨提示</strong>：</p>
<p>函数名称填写：<code>twikoo</code></p>
<p>创建方式选择：空白函数</p>
<p>运行环境选择：Nodejs10.15</p>
<p>函数内存选择：128M</p>
<p>必须按照上面的方式选择，不要瞎选瞎写好吧。</p>
</blockquote>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220605/2022060509.png" alt="2022060509"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220605/2022060510.png" alt="2022060510"></p>
<p><strong>2</strong>、清空上图中「函数代码」框里的内容，复制<code>exports.main = require('twikoo-func').main</code>到里面，点击确定，如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220605/2022060511.png" alt="2022060511"></p>
<p><strong>3</strong>、点击「<strong>twikoo</strong>」函数名进入云函数详情页 - <strong>函数代码</strong> - <strong>文件</strong> - <strong>新建文件</strong>，输入<code>package.json</code>确定，将<code>&#123; &quot;dependencies&quot;: &#123; &quot;twikoo-func&quot;: &quot;1.5.11&quot; &#125; &#125;</code>内容复制到新建的文件<code>package.json</code>里面。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220605/2022060512.png" alt="2022060512"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220605/2022060513.png" alt="2022060513"></p>
<h2 id="配置butterfly主题文件">配置butterfly主题文件</h2>
<p>打开<code>主题butterfly</code>下的配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">Twikoo</span> <span class="comment"># Valine,Disqus</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># Display the comment name next to the button</span></span><br><span class="line">  <span class="comment"># lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># 文章top_image上是否显示评论数量</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">true</span> <span class="comment"># 首页文章是否显示评论数量</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Twikoo</span></span><br><span class="line"><span class="comment"># https://github.com/imaegoo/twikoo</span></span><br><span class="line"><span class="attr">twikoo:</span></span><br><span class="line">  <span class="attr">envId:</span> <span class="string">xxxxxxxxxxxxx</span> <span class="comment"># 环境ID，即是上面创建的云环境的ID</span></span><br><span class="line">  <span class="attr">region:</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220605/2022060514.png" alt="2022060514"></p>
<h2 id="最后-5">最后</h2>
<p>关于其他的评论系统的配置请参考：<a href="https://butterfly.js.org/posts/ceeb73f/">butterfly主题官方文档</a></p>
<p>关于Twikoo评论系统详细文档请参考：<a href="https://twikoo.js.org/quick-start.html">Twikoo官方文档</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hexo】如何拥有一个自定义域名的Hexo博客</title>
    <url>/posts/9fce234e/</url>
    <content><![CDATA[<h2 id="如何拥有自己的域名">如何拥有自己的域名</h2>
<p>在<a href="https://happycodersunny.github.io/2022/05/09/%E3%80%90Hexo%E3%80%91Mac%20OS%E4%B8%8A%E4%BD%BF%E7%94%A8Hexo%20+%20Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/">这篇文章</a>中我们利用Hexo和Github搭建了自己的博客，搭建出来的博客地址格式都是：<code>https://+Github博客仓库名.github.io </code></p>
<p>比如我的博客地址就是：<code>https://happycodersunny.github.io</code></p>
<p>是不是觉得不好看，大家的网址都长一样，好像是流水线上生产出来的一样，那么怎么替换成自己的域名显得更个性化呢？</p>
<h2 id="购买域名">购买域名</h2>
<p>首先一个普通的域名也不贵，你可以上XX云买一个自己喜欢的域名，我这里以阿里云为例：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220512/20220512_01.png" alt="20220512_01"></p>
<p>在购买的时候需要你实名，就按照要求填写相关信息即可，填写之后需要一会的审核时间，一般还是很快的。</p>
<p>如果你实在是不想花钱买域名也可以<a href="%5Bhttp://freenom.com%5D(https://link.zhihu.com/?target=http%3A//freenom.com/)">在这里</a>免费注册一个域名，具体注册和解析步骤可以参考<a href="https://www.zhihu.com/question/31377141/answer/2266363145">知乎文章</a>。</p>
<h2 id="域名解析">域名解析</h2>
<p>购买域名之后我们还需要对域名进行解析之后才能使用。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220512/20220512_02.png" alt="20220512_02"></p>
<p>在这里面添加两条记录如上所示。</p>
<p>记录类型为A的四个记录值是Github page官网说的四个记录值，好多文章写的192开头的两个已经不是最新的了，大家最好还是对照<a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site">Github Pages</a>进行设置，也可以使用<code>ping xxx.github.io</code>来验证一下。</p>
<p>记录类型为CNAME的记录值必须是<code>xxx.github.io</code>。</p>
<h2 id="添加CNAME文件">添加CNAME文件</h2>
<p>一、在<code>Github</code>上博客项目里按照下面步骤配置自定义域名：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220512/20220512_03.png" alt="20220512_03"></p>
<p>这里需要注意的是：我们需要勾选<code>Enforce HTTPS</code>，这样以后访问我们的博客才安全不会提示网站链接不安全的问题，<code>Github Pages</code>官网上说勾选这个之后一般需要等待24h才可以正常使用，不过有时候也快，我这个等了两三分钟就可以了。</p>
<p>二、配置完成之后，博客项目下会多一个<code>CNAME</code>文件，里面的内容就是我们上面配置的自定义域名：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220512/20220512_04.png" alt="20220512_04"></p>
<p>三、检查博客根目录下的source文件夹下是否有一个CNAME文件，如果还是没有请自行在<code>/source</code>目录下新添加一个CNAME文件，内容跟上面一样还是填写自己购买的域名，保存。</p>
<h2 id="修改博客配置文件">修改博客配置文件</h2>
<p>打开我们本地博客目录下的<code>_config.yml</code>文件：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220512/20220512_05.png" alt="20220512_05"></p>
<p>将里面的url替换成我们自己的即可。</p>
<p>执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>再次运行博客：</p>
<p>如果不添加<code>HTTPS</code>，网站左上角会提示该网站不安全：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220512/20220512_06.png" alt="20220512_06"></p>
<p>正常添加<code>HTTPS</code>，网站左上角会有一个锁头标志，说明这个网站是安全的：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220512/20220512_07.png" alt="20220512_07"></p>
<p>这样我们就把自己购买的域名用上了，也使自己的网站更具个性化一点。</p>
<h2 id="最后-6">最后</h2>
<p>嘻嘻嘻，都看到这里了，不要吝啬你的小星星嘛，为博主点个赞呐～</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>【PS学习】初识PS界面</title>
    <url>/posts/70b04f6f/</url>
    <content><![CDATA[<h2 id="写在前面-4">写在前面</h2>
<p>我这里以【<strong>PS2020</strong>】和【<strong>Mac</strong>】为例来带大家初步认识PS，也顺便整理一下我之前学习PS的笔记。</p>
<h2 id="初识PS界面">初识PS界面</h2>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220705/2022070501-20220706104214108.png" alt="2022070501"></p>
<div class="note green no-icon flat"><p>1:【菜单栏】- 包含了文件、编辑、图像、图层、文字、选择、滤镜、3D、视图、窗口、帮助</p>
<p>2:【工具选项栏】 - 设置工具选项的，根据所选的工具不同【工具选项栏】中的内容也不同</p>
<p>3:【工具栏】- PS相关的工具</p>
<p>4:【工作区】- 所有的操作都会显示在工作区</p>
<p>5:【工作面板】- 用来设置颜色、工具参数等</p>
</div>
<h2 id="PS工具栏介绍">PS工具栏介绍</h2>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220705/2022070530.png" alt="2022070530"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220705/2022070531.png" alt="2022070531"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220705/2022070532.png" alt="2022070532"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220705/2022070533.png" alt="2022070533"></p>
<div class="note green no-icon flat"><p><strong>总结</strong>：上面按照【PS2020】的工具栏从上至下简单做了个介绍，但是大家会发现有的图标右下角有<strong>展开</strong>标记，说明着里面还包含了其他工具，大概包含了69种工具。</p>
<p>这里就不一一罗列出来，大家可以打开PS看一下。</p>
</div>
<h2 id="部分PS操作">部分PS操作</h2>
<h3 id="面板显示与隐藏">面板显示与隐藏</h3>
<p>隐藏所有面板：<label style="color:red">tab键</label></p>
<p>只显示【工具栏】和【工具选项栏】面板：<label style="color:red">tab键 + shift</label></p>
<div class="note green no-icon flat"><p><strong>注意</strong>：当鼠标靠近左边，左边面板会出现，当鼠标靠近右边，右边面板会出现。</p>
</div>
<h3 id="PS界面如何复位">PS界面如何复位</h3>
<p><label style="color:red">【PS界面】右上角 - 复位基本功能</label></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220705/2022070502.png" alt="2022070502"></p>
<h3 id="多个文档之间如何切换">多个文档之间如何切换</h3>
<p><label style="color:red">快捷键：control + tab键</label></p>
<h3 id="如何关闭当前打开的所有文档">如何关闭当前打开的所有文档</h3>
<p><strong>1</strong>、<label style="color:red">【菜单栏】文件 - 关闭全部 </label></p>
<p><strong>2</strong>、<label style="color:red">快捷键：option + command + W </label></p>
<h3 id="如何保存自定义的工作区">如何保存自定义的工作区</h3>
<p><label style="color:red">【PS界面】右上角 - 新建工作区</label></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220705/2022070502-20220705194235045.png" alt="2022070502"></p>
<h3 id="如何缩放图片">如何缩放图片</h3>
<p><strong>放大</strong>、<label style="color:red">快捷键：Z键</label> 、<label style="color:red">快捷键：command + +</label></p>
<p><strong>缩小</strong>、<label style="color:red">长按option</label>、<label style="color:red">快捷键：command + -</label></p>
<p><strong>适合屏幕</strong>、<label style="color:red">【工具选项栏】 -适合屏幕</label>、<label style="color:red">快捷键：command + 0</label></p>
<h3 id="如何自定义PS里的快捷键">如何自定义PS里的快捷键</h3>
<p><strong>1</strong>、<label style="color:red">【菜单栏】编辑 - 键盘快捷键</label></p>
<p><strong>2</strong>、<label style="color:red">快捷键：shift + option + command + K</label></p>
<h3 id="如何使用智能参考线">如何使用智能参考线</h3>
<p><label style="color:red">【菜单栏】视图 - 显示 - 智能参考线</label></p>
<div class="note green no-icon flat"><p><strong>注意</strong>：设置显示智能参考线后，在移动物体的时候就会出现智能参考线。</p>
</div>
<h3 id="如何使用网格">如何使用网格</h3>
<p><label style="color:red">【菜单栏】视图 - 显示 - 网格</label></p>
<h3 id="如何修改网格的大小">如何修改网格的大小</h3>
<p><label style="color:red">【菜单栏】PhotoShop - 首选项 - 参考线、网格和切片</label></p>
<h3 id="如何在PS界面添加更多面板">如何在PS界面添加更多面板</h3>
<p><label style="color:red">【菜单栏】 - 窗口 - 选择想要展示的面板</label></p>
]]></content>
      <categories>
        <category>PS</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title>【PS学习】图层相关基本操作</title>
    <url>/posts/c0e79a01/</url>
    <content><![CDATA[<h2 id="写在前面-5">写在前面</h2>
<p>相关文章：</p>
<p>1、<a href="!https://codersunny.com/posts/70b04f6f/">【PS学习】初识PS界面</a></p>
<p>2、<a href="!https://codersunny.com/posts/52ee9edd/">【PS学习】文件基本操作</a></p>
<p>3、<a href="!https://codersunny.com/posts/b55c64d0/">【PS学习】色彩基础</a></p>
<p>本文主要记录一下图层的一些基本操作，PS版本为【PS2020】。</p>
<h2 id="初识图层">初识图层</h2>
<h3 id="图层的显示与隐藏">图层的显示与隐藏</h3>
<p>【菜单栏】窗口 - 图层（快捷键<strong>F7</strong>）</p>
<p>如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/1.png" alt="1"></p>
<h3 id="改变图层缩略图大小">改变图层缩略图大小</h3>
<p>选择图层 - 右击 - 改变缩略图大小</p>
<p>如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/2.png" alt="2"></p>
<div class="note green no-icon flat"><p>新建的图层默认是透明的，如何想要给当前图层设置颜色，在选择颜色之后填充即可改变图层的颜色。</p>
<p><strong>如何填充？</strong></p>
<p>快捷键：Shift + F5</p>
<p>如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/3.png" alt="3"></p>
</div>
<h3 id="如何选择多个图层进行编辑">如何选择多个图层进行编辑</h3>
<p>Shift + 需要选择的图层（连续性）</p>
<p>command + 需要选择的图层（非连续性）</p>
<h3 id="如何复制一个图层">如何复制一个图层</h3>
<p>图层 - 右击 - 复制图层</p>
<p>option + 需要复制的图层 - 拖动</p>
<h3 id="修改图层的名称和颜色">修改图层的名称和颜色</h3>
<p>图层面板 - 选择图层 - 右键选择颜色（可以用来突出图层）</p>
<p>如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/7.png" alt="7"></p>
<h3 id="复制图层">复制图层</h3>
<ol>
<li>选择图层 - 右键 - 复制图层</li>
<li>command + J</li>
</ol>
<h3 id="锁定图层">锁定图层</h3>
<p>锁定透明像素：锁定之后 画笔工具无法在透明区域进行绘制。</p>
<p>锁定图像像素：锁定之后 无法在该图层上使用画笔工具。</p>
<p>锁定位置：锁定之后 图像的位置就不能移动。</p>
<p>锁定全部：包括锁定透明像素、图像像素、位置等。</p>
<p>如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/8.png" alt="8"></p>
<h3 id="查找图层">查找图层</h3>
<p>根据不同类型去过滤图层 方便快速找到我们需要的图层。</p>
<p>如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/9.png" alt="9"></p>
<h3 id="对齐图层">对齐图层</h3>
<ol>
<li>图层面板选择需要对齐的图层 - 【工具栏】移动工具（V） - 【工具选项栏】选择对齐方式</li>
<li>【菜单栏】图层 - 对齐 - 选择对齐方式</li>
</ol>
<p>如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/10.png" alt="10"></p>
<h3 id="分布图层">分布图层</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/11.png" alt="11"></p>
<h3 id="图层的复制-粘贴功能">图层的复制/粘贴功能</h3>
<ol>
<li>command + C 复制 / command + D 粘贴</li>
<li>拖拽需要复制的图层到另一个图层上</li>
<li>【图层面板】- 选择图层 - 右键复制图层</li>
</ol>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/18.png" alt="18"></p>
<h3 id="原位粘贴">原位粘贴</h3>
<p>command + V - 【菜单栏】编辑 - 选择性粘贴 - 原位粘贴</p>
<h2 id="背景图层">背景图层</h2>
<h3 id="背景图层和普通图层的区别">背景图层和普通图层的区别</h3>
<ol>
<li>背景图层是锁定的，图层右边有一个【锁头】的标志。</li>
<li>背景图层不能改变叠加顺序。</li>
<li>背景图层不能改变不透明度等。</li>
</ol>
<p>如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/4.png" alt="4"></p>
<h3 id="背景图层转化为普通图层">背景图层转化为普通图层</h3>
<p>点击背景图层右边的【锁头】标志。</p>
<h2 id="选择-取消选择图层">选择/取消选择图层</h2>
<p>工具栏 - 选择移动工具（V）- 选择图层进行移动。</p>
<div class="note green no-icon flat"><p>当两个图层重叠时需要移动下面的图层，需要将【工具选项栏】的【自动选择】取消，在图层面板选择需要移动的图层进行移动。</p>
<p>如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/5.png" alt="5"></p>
</div>
<h2 id="链接图层">链接图层</h2>
<p>链接图层：两个图层形成一个图层组，操作其中一个图层，另一个图层也会跟着移动。</p>
<p>链接：选中需要链接的图层 点击【链接图层】。</p>
<p>取消链接：选中链接的图层 再次点击【链接图层】。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/6.png" alt="6"></p>
<h2 id="图层组">图层组</h2>
<p>如何创建图层组？</p>
<ol>
<li>选中需要的图层 - 点击【图层面板】创建新组</li>
<li>选中需要的图层 - command + G</li>
</ol>
<div class="note green no-icon flat"><p>注意：图层组是可以叠加的。</p>
</div>
<h2 id="图层样式">图层样式</h2>
<ol>
<li>双击图层空白处 - 图层样式</li>
<li>选择图层 - 【图层面板】添加图层样式 - 混合选项</li>
</ol>
<p>如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/12.png" alt="12"></p>
<div class="note red no-icon flat"><p><strong>如何复制添加的一些图层样式的效果到其他图层？</strong></p>
<p>option + 图层样式效果 + 拖到到需要的图层下</p>
<p>如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/13.png" alt="13"></p>
</div>
<h3 id="缩放图层样式大小">缩放图层样式大小</h3>
<p>【菜单栏】图层 - 图层样式 - 缩放效果</p>
<p>如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/14.png" alt="14"></p>
<h3 id="将图层样式创建为图层">将图层样式创建为图层</h3>
<p>【菜单栏】图层 - 图层样式 - 创建图层（有几种样式就会转化为几种图层）</p>
<p>如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/15.png" alt="15"></p>
<p>将图层样式转化为图层之后 我们可以单独对某个图层进行调节 比如色相/饱和度（快捷键：command + U）</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/16.png" alt="16"></p>
<h3 id="图层样式的叠加">图层样式的叠加</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/17.png" alt="17"></p>
<div class="note green no-icon flat"><p>如果图层样式面板显示的不是所有的效果 可以选择左下角的fx - 显示所有效果</p>
<p>option + 复位：取消本次所有图层样式的所有设置。</p>
</div>
<h2 id="写在最后">写在最后</h2>
<p>关于图层的一些基本操作的笔记记录到这里就结束了，如有错误请多多指教。</p>
]]></content>
      <categories>
        <category>PS</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title>【PS学习】文件基本操作</title>
    <url>/posts/52ee9edd/</url>
    <content><![CDATA[<h2 id="写在前面-6">写在前面</h2>
<p>相关文章：1、<a href="https://codersunny.com/posts/70b04f6f/">初识PS界面</a></p>
<p>本篇主要讲一下PS中关于文件的一些操作，PS版本为【PS2020】。</p>
<h2 id="文件的相关操作">文件的相关操作</h2>
<h3 id="如何新建文档">如何新建文档</h3>
<p><strong>1</strong>、<label style="color:red">PS界面左边【新建】按钮</label></p>
<p><strong>2</strong>、<label style="color:red">【菜单栏】文件 - 新建</label></p>
<p><strong>3</strong>、<label style="color:red">快捷键：command + N</label></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220707/2022070701.png" alt="2022070701"></p>
<div class="note green no-icon flat"><p><strong>提示</strong>：里面有很多PS默认为我们提供的模版，如果有合适的可以直接创建。</p>
</div>
<h3 id="如何保存预设文档">如何保存预设文档</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220707/2022070702.png" alt="2022070702"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220707/2022070703.png" alt="2022070703"></p>
<h3 id="新建文档注意事项">新建文档注意事项</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220707/2022070704.png" alt="2022070704"></p>
<div class="note green no-icon flat"><p><strong>提示</strong>：</p>
<ol>
<li>当希望将多个页面的UI放到一个文件时，在创建文件时需要勾选【画板】。</li>
<li>如果文档是针对【打印输出】，颜色模式一般选择<label style="color:red">CMYK模式</label>，位数保持<label style="color:red">8bit</label>。</li>
<li>如果文档是针对【屏幕显示】，颜色模式一般选择<label style="color:red">RGB模式</label>，位数保持<label style="color:red">8bit</label>。</li>
<li>颜色模式的位数越高呈现的颜色就越多，不过一般我们肉眼也无法识别那么多颜色所以位数一般保持8bit即可。</li>
</ol>
</div>
<h3 id="如何打开文件">如何打开文件</h3>
<p><strong>1</strong>、<label style="color:red">PS界面左边【打开】按钮</label></p>
<p><strong>2</strong>、<label style="color:red">【菜单栏】文件 - 打开</label></p>
<p><strong>3</strong>、<label style="color:red">command + O</label></p>
<p><strong>4</strong>、<label style="color:red">选择需要打开的文件拖拽到PS</label></p>
<h3 id="如何打开序列文件">如何打开序列文件</h3>
<p><label style="color:red">选择某一序列文件 - 勾选【图像序列】</label></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220707/2022070705.png" alt="2022070705"></p>
<div class="note green no-icon flat"><p><strong>注意</strong>：PS工作区会出现时间轴，如果没有通过<label style="color:red">【菜单栏】窗口 - 时间轴</label>配置。</p>
</div>
<h3 id="置入链接的智能对象">置入链接的智能对象</h3>
<p><label style="color:red">【菜单栏】文件 - 置入链接的智能对象</label></p>
<p>🌰：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220707/2022070706.png" alt="2022070706"></p>
<p>点击左边图层面板置入的链接对象：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220707/2022070707.png" alt="2022070707"></p>
<p>修改这个置入的链接对象【保存】会发现原来已经的文件发生了变化：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220707/2022070708.png" alt="2022070708"></p>
<h3 id="置入嵌入对象">置入嵌入对象</h3>
<p><label style="color:red">【菜单栏】文件 - 置入嵌入对象</label></p>
<div class="note green no-icon flat"><p><strong>置入链接的智能对象 和 置入嵌入对象的区别</strong>：智能链接对象<strong>会</strong>随着源文件的修改而发生变化 嵌入对象<strong>不会</strong>随着源文件的修改而发生变化。</p>
</div>
<h3 id="如何存储文件">如何存储文件</h3>
<p><strong>1</strong>、<label style="color:red">【菜单栏】文件 - 存储为</label></p>
<p><strong>2</strong>、<label style="color:red">快捷键：option + command + S</label></p>
<h3 id="画板的创建与修改">画板的创建与修改</h3>
<p><strong>1</strong>、<label style="color:red">【图层面板】右边按钮 - 新建画板</label></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220707/2022070709.png" alt="2022070709"></p>
<p>属性面板可以调节画板的属性：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220707/2022070710.png" alt="2022070710"></p>
<p><strong>2</strong>、<label style="color:red">【工具栏】- 画板工具（V）- 【工具选项栏】添加新画板 - 在工作区合适的位置单击</label></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220707/2022070711.png" alt="2022070711"></p>
<div class="note green no-icon flat"><p><strong>提示</strong>：鼠标放置在【画板名称上】移动即可移动画板。</p>
</div>
<h3 id="如何导出画板">如何导出画板</h3>
<p><label style="color:red">【菜单栏】文件 - 导出 - 将画板导出到PDF</label></p>
<p>也可以导出为其他的格式：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220707/2022070712.png" alt="2022070712"></p>
<div class="note green no-icon flat"><p><strong>提示</strong>：</p>
<ol>
<li>【导出为】可以为每个画板以不同的格式导出。</li>
<li>【导出为】 - 双联是【PS2020】新增的功能</li>
<li><label style="color:red">command + 画板点击</label> 可以展示或收起多个面板</li>
<li>画板可以单独导出</li>
</ol>
</div>
<h3 id="如何为文件添加版权信息和简介">如何为文件添加版权信息和简介</h3>
<p><strong>1</strong>、<label style="color:red">【菜单栏】文件 - 文件简介 - 输入相关描述信息</label></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220707/2022070716.png" alt="2022070716"></p>
<p><strong>2</strong>、<label style="color:red">【菜单栏】PhotoShop - 首选项 - 导出</label></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220707/2022070718.png" alt="2022070718"></p>
]]></content>
      <categories>
        <category>PS</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title>【PS学习】色彩基础</title>
    <url>/posts/b55c64d0/</url>
    <content><![CDATA[<h2 id="写在前面-7">写在前面</h2>
<p>相关文章：</p>
<p>1、<a href="https://codersunny.com/posts/70b04f6f/">【PS学习】初识PS界面</a></p>
<p>2、<a href="https://codersunny.com/posts/52ee9edd/">【PS学习】文件基本操作</a></p>
<p>本篇主要是记录一下关于PS中色彩相关基础，PS版本为【PS2020】。</p>
<h2 id="色彩基础">色彩基础</h2>
<h3 id="色彩专业术语">色彩专业术语</h3>
<p><strong>1</strong>、<label style="color:red">色相</label></p>
<p>颜色在画板上的反映 可以理解为就是我们所说的颜色。</p>
<p><strong>2</strong>、<label style="color:red">纯度</label></p>
<p>彩度 - Chroma 是相对于灰色而言 从左到右 彩度越来越高</p>
<p>饱和度 - Saturation 从左到右 饱和度越来越低</p>
<p>强度 - Intensity 中间的颜色 强度是最高的</p>
<div class="note green no-icon flat"><p>彩度、饱和度、强度都可以用来形容纯度。</p>
</div>
<p><strong>3</strong>、<label style="color:red">明度</label></p>
<p>光亮度 - Luminance 越暗的颜色光亮度越低 越亮的颜色光亮度越高</p>
<p>暗色 - Shade 从左到右越来越暗</p>
<p>浅色 - Tint 从左到右越来越浅</p>
<p>​</p>
<p>关于色彩可以看看下图：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220707/2022072101.png" alt="2022072101"></p>
<h2 id="颜色的加法与减法">颜色的加法与减法</h2>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220721/2022072102.png" alt="2022072102"></p>
<p><strong>1</strong>、<label style="color:red">印刷三原色</label>：青色、品红、黄色</p>
<p><strong>2</strong>、<label style="color:red">光的三原色</label>：红色、蓝色、绿色</p>
<h2 id="色环构成原理">色环构成原理</h2>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220721/2022072103.png" alt="2022072103"></p>
<h2 id="如何使用双色模式打造单色调的照片效果">如何使用双色模式打造单色调的照片效果</h2>
<p><label style="color:red">【菜单栏】 - 图像 - 模式 - 灰度</label></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220721/2022072104.png" alt="2022072104"></p>
<p>效果图如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220721/2022072105.png" alt="2022072105"></p>
<h2 id="用吸管工具选取颜色">用吸管工具选取颜色</h2>
<p><label style="color:red">【工具栏】 - 吸管工具</label></p>
<p><label style="color:red">快捷键：I</label></p>
<div class="note green no-icon flat"><p>1、使用【吸管工具】吸取的颜色默认是作为【前景色】的</p>
<p>2、使用 <label style="color:red">option + 吸管工具</label>吸取的颜色是作为【背景色】的</p>
<p>3、【工具选项栏】- 取样大小是指取样区域：在这个范围内的像素都会参与吸取颜色的计算</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220721/2022072106.png" alt="2022072106"></p>
</div>
<h2 id="色轮取色模式">色轮取色模式</h2>
<p><label style="color:red">颜色 - 色轮</label></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220721/2022072108.png" alt="2022072108"></p>
<p>效果如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220721/2022072109.png" alt="2022072109"></p>
<div class="note green no-icon flat"><p>H：色相</p>
<p>S：饱和度（纯度）</p>
<p>B：明度</p>
</div>
<h2 id="用拾色器选取颜色：设置前景色-取色器">用拾色器选取颜色：设置前景色 - 取色器</h2>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220721/2022072110.png" alt="2022072110"></p>
<div class="note green no-icon flat"><p>前面的方块：代表的是前景色</p>
<p>后面的方块：代表的是背景色</p>
<p>点击左下角的小块即将前景色和背景色设置为默认（前景色为黑色 背景色为白色）</p>
<p><strong>提示</strong>：按键盘上的【D】也可以把颜色复原</p>
<p>​		   【X】切换前景色和背景色</p>
</div>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220721/2022072111.png" alt="2022072111"></p>
<div class="note green no-icon flat"><p><strong>警告提示</strong>：如果正在做的图片只是针对于手机屏幕等显示 可以忽略 如果是用于打印 就表示可能会打印不出来 可以点击警告标识下面的颜色 ps即会帮我们自动微调。</p>
</div>
<h2 id="利用色板画板调整颜色">利用色板画板调整颜色</h2>
<p>【PS界面】 - 色板：直接点击可以改变【背景色】颜色 【option + 点击】可以改变【前景色】</p>
<h2 id="增强的色板功能：智能填色">增强的色板功能：智能填色</h2>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220721/2022072112.png" alt="2022072112"></p>
<p>如何改变潜水艇的颜色：在【色板】上选中颜色直接拖拽到潜水艇的位置即可。</p>
<p>如何实现如下效果？</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220721/2022072113.png" alt="2022072113"></p>
<p><strong>1</strong>、<label style="color:red">option + command + 拖拽颜色</label></p>
<p><strong>2</strong>、<label style="color:red">图层面板 - 添加图层样式 - 颜色叠加</label></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220721/2022072114.png" alt="2022072114"></p>
]]></content>
      <categories>
        <category>PS</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS逆向】Cycript的基本使用</title>
    <url>/posts/7495500c/</url>
    <content><![CDATA[<h2 id="写在前面-8">写在前面</h2>
<p>本文主要是介绍一下逆向中Cycript的基本用法。</p>
<h2 id="简单介绍">简单介绍</h2>
<p>Cycript是OC、C++、JS、Java等多种语法的一个混合物，它是用来探索、修改、调试当前正在运行的APP，这个在我们以后逆向的过程中会经常使用到，关于Cycript的更多介绍大家可以参考<a href="!http://www.cycript.org/">Cycript官网</a>。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/1.png" alt="1"></p>
<h2 id="安装Cycript">安装Cycript</h2>
<p>在Cydia里面搜索Cycript进行下载，如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/2.png" alt="2"></p>
<h2 id="Cycript的基本使用">Cycript的基本使用</h2>
<h3 id="Cycript的开启和关闭">Cycript的开启和关闭</h3>
<p>1、开启</p>
<ul>
<li>保持Mac和iPhone的安全连接</li>
<li>使用命令<code>cycript -p 进程ID</code>或<code>cycript -p 进程名称</code></li>
</ul>
<div class="note green no-icon flat"><p>如果不太了解Mac和iPhone怎么保持连接的，可以参考博主的另一篇文章：<a href="!https://codersunny.com/posts/7df93f3b/">【iOS逆向】如何让Mac和iPhone建立安全连接</a>。</p>
</div>
<p>如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/3.png" alt="3"></p>
<p>这样我们就处于一个Cycript的语法环境。</p>
<p>2、关闭</p>
<p>快捷键：<code>control + D</code></p>
<p>3、清屏</p>
<p>快捷键：<code>command + R</code></p>
<h3 id="查看进程的ID和名称">查看进程的ID和名称</h3>
<p>在以后逆向中，我们需要使用<code>cycript -p 进程ID</code>或<code>cycript -p 进程名称</code>来探究某个APP，那么这个进程ID和进程名称我们应该从哪里获取呢。</p>
<p>1、在Cydia中搜索<code>adv_cmds</code>并安装</p>
<p>2、使用<code>ps</code>相关命令查看</p>
<div class="note pink no-icon flat"><p>列出所有进程：<code>ps -A</code></p>
<p>根据关键词显示某些进程：<code>ps -A|grep 关键词</code></p>
</div>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/4.png" alt="4"></p>
<p>我们这里以【喜马拉雅】APP为例：7091就是进程ID，ting就是进程名称，由于进程ID可能随时会发生变化，建议以后使用进程名称。</p>
<div class="note pink no-icon flat"><p><strong>注意</strong>：要想或者某个APP的进程名称、ID，必须要打开这个APP。</p>
</div>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/5.png" alt="5"></p>
<p>这样我们就可以监听这个进程了。</p>
<h3 id="Cycript中常用的语法">Cycript中常用的语法</h3>
<ul>
<li>获取当前进程的Application</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">UIApplication</span> sharedApplication] 或 <span class="built_in">UIApp</span></span><br></pre></td></tr></table></figure>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/6.png" alt="6"></p>
<ul>
<li>定义变量</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var 变量名 = 变量值</span><br></pre></td></tr></table></figure>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/7.png" alt="7"></p>
<p>这样在当前内存环境下，只要我们输入<code>app</code>就可以获取window。</p>
<ul>
<li>获取当前APP的RootViewController</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIApp</span>.keyWindow.rootViewController</span><br></pre></td></tr></table></figure>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/8.png" alt="8"></p>
<ul>
<li>根据内存地址获取对象</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">#内存地址</span><br></pre></td></tr></table></figure>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/9.png" alt="9"></p>
<ul>
<li>查看对象的所有成员变量</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">*对象</span><br><span class="line">或</span><br><span class="line">*#对象的内存地址</span><br></pre></td></tr></table></figure>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/10.png" alt="10"></p>
<ul>
<li>递归打印view的所有子控件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIApp</span>.keyWindow.recursiveDescription().toString()</span><br></pre></td></tr></table></figure>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/11.png" alt="11"></p>
<ul>
<li>筛选中某种类型的对象</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">choose(<span class="built_in">UIViewController</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/12.png" alt="12"></p>
<div class="note green no-icon flat"><p>这里打印的是当前在内存里面的VC，没有被创建的VC是不会被打印出来的。</p>
</div>
<h3 id="封装Cycript文件">封装Cycript文件</h3>
<p>一般我们会把一些常用的cycript语法封装在.cy文件中，使用起来会方便很多，具体步骤如下：</p>
<ul>
<li>封装好.cy文件</li>
<li>复制.cy文件到iFunBox的目录<code>usr/lib/cycript0.9</code>里面</li>
<li>关掉当前进程 重新进入：cycript -p 进程名称</li>
<li>导入该文件：@import cy文件</li>
</ul>
<h3 id="MJCycript文件">MJCycript文件</h3>
<p>大佬已经把一些常用的、实用的相关函数给封装好了，大家可以去下载<a href="https://github.com/CoderMJLee/mjcript">Github</a>。</p>
<p>按照我们上面讲的方式导入就可以使用：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/13.png" alt="13"></p>
<p>现在我们来看一下例子：如何创建一个View并把它添加到APP上。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/14.png" alt="14"></p>
<h2 id="写在最后-2">写在最后</h2>
<p>关于Cycript的简单介绍我们就分享到这里了，如有错误请多多指教。</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS逆向】一键越狱教程</title>
    <url>/posts/1bf7fb0b/</url>
    <content><![CDATA[<h2 id="写在前面-9">写在前面</h2>
<p>本文主要是记录一下如何越狱，博主这里指的是不完美越狱，博主这里越狱的手机是：iPhone5s  iOS12.5.6。</p>
<p>首先，你需要有：iPhone手机、Mac电脑，保证Mac和手机上都有<a href="https://www.i4.cn/">爱思助手</a>。</p>
<h2 id="越狱的简单介绍">越狱的简单介绍</h2>
<h3 id="什么是越狱？">什么是越狱？</h3>
<p>越狱：iOS jailbreak，利用iOS系统的漏洞获取iOS系统的最高权限，解开之前的各种限制。</p>
<div class="note red no-icon flat"><p><strong>越狱的优点</strong>：</p>
<p>1、可以打造个性化、与众不同的iPhone</p>
<p>2、可以修改APP的一些默认行为</p>
<p>3、可以自由安装非App Store来源的App</p>
<p>4、灵活管理文件系统，让iPhone可以像U盘那么灵活</p>
<p>5、给开发者提供了逆向功能的环境</p>
<p><strong>越狱的缺点</strong>：</p>
<p>1、越狱的手机不予保修</p>
<p>2、比较耗电，越狱之后的手机会常驻一些进程，耗电速度约提升10%</p>
<p>3、不再受iOS系统默认的安全保护，容易被恶意软件攻击，个人隐私有被窃取的风险</p>
<p>4、如果安装了不稳定的插件，容易让系统不稳定、变慢或者出现“白苹果”现象</p>
</div>
<h3 id="完美越狱和不完美越狱">完美越狱和不完美越狱</h3>
<p>完美越狱：手机在越狱之后可以正常关机和重启。</p>
<p>不完美越狱：手机不能关机或重启，关机之后可能会出现越狱软件<code>Cydia</code>等无法打开需要重新越狱，严重甚至出现“白苹果”现象。</p>
<h3 id="Cydia">Cydia</h3>
<p>Cydia：可以理解为是越狱之后的&quot;App store&quot;，可以在Cydia里面安装一些第三方软件、补丁、插件等。</p>
<div class="note red no-icon flat"><p><strong>Cydia安装软件的步骤</strong>：</p>
<p>1、添加软件源（不同的软件软件源可能不一样）（Cydia - 软件源 - 编辑 - 添加 - 输入软件源地址）</p>
<p>2、进入软件源 - 找到对应的软件开始下载</p>
</div>
<p>有的插件安装完成之后会要求重启SpringBoard，SpringBoard可以理解为iOS的桌面。</p>
<h2 id="如何越狱">如何越狱</h2>
<p>用数据线连接上手机和电脑，打开【爱思助手】- 工具箱 - 一键越狱：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/1.png" alt="1"></p>
<p>会显示当前手机系统、型号、是否越狱等信息：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/2.png" alt="2"></p>
<p>博主这里选择Checkra1n进行越狱，出现如下界面：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/3.png" alt="3"></p>
<p>点击Start，按照如下操作开始下载越狱软件CheckRa1n：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/4.png" alt="4"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/5.png" alt="5"></p>
<p>安装完Checkra1n之后，手机上会有一个checkra1n的软件，打开它开始安装Cydia软件：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/6.png" alt="6"></p>
<p>安装完Cydia之后，手机桌面会多一个软件如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/7.png" alt="7"></p>
<p>此时连接爱思助手，会发现顶部关于手机的信息会发生变化：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/8.png" alt="8"></p>
<p>会看到上面提示我们去安装AFC2和AppSync两个插件，这两个插件具体有何用处如下：</p>
<div class="note red no-icon flat"><p>AFC2：可以保证能够访问整个iOS的文件系统。</p>
<p>AppSync：保证绕过验证随意安装、运行破解的ipa包。</p>
</div>
<p>点击安装AFC2会提示我们如何安装，大家按照自己手机的系统来安装，Cydia - 搜索Apple File… - 安装：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/9.png" alt="9"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/10.png" alt="10"></p>
<p>安装完成之后，点击重启SpringBoard即可。</p>
<p>此时连接Mac和手机，爱思助手顶部信息如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/11.png" alt="11"></p>
<p>这时我们如果直接点击【安装AppSync】可能会报如下错误：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/12.png" alt="12"></p>
<p>不用理会，直接在Cydia - 添加软件源：<a href="http://cydia.angelxwind.net">cydia.angelxwind.net</a>，如下图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/13.png" alt="13"></p>
<p>选择我们刚添加的源 - 插件 - 搜索AppSync - 安装：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/14.png" alt="14"></p>
<p>安装完成之后同样需要重启SpringBoard，在Cydia - 已安装 里面可以看到我们刚安装的两个插件：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/15.png" alt="15"></p>
<p>两个都安装成功之后，我们会看到爱思助手顶部信息发生变化，告诉我们该设备已越狱：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/16.png" alt="16"></p>
<h2 id="写在最后-3">写在最后</h2>
<p>关于如何简单一键越狱的操作，博主就介绍到这里了，如有错误请多多指教。</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
        <tag>iPhone</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS逆向】如何让Mac和iPhone建立安全连接</title>
    <url>/posts/7df93f3b/</url>
    <content><![CDATA[<h2 id="写在前面-10">写在前面</h2>
<p>本文主要是记录一下在iOS逆向过程中，Mac是如何和iPhone建立安全连接来实现在Mac上可以通过命令行操作iPhone的。</p>
<h2 id="SSH-和-OpenSSH">SSH 和 OpenSSH</h2>
<p>SSH：Secure Shell的缩写，意思为“安全外壳协议”，是一种可以为【远程登录】提供安全保障的协议，使用SSH可以把所有的数据加密，防止中间人攻击等欺骗。</p>
<p>OpenSSH：是SSH的免费开源实现。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/1.png" alt="1"></p>
<div class="note pink no-icon flat"><p><strong>拓展</strong>：</p>
<p>SSL：Secure Socket Layer的缩写，是为网络通信提供安全及数据完整性的一种安全协议，在传输层对网络连接进行加密。</p>
<p>OpenSSL：SSL的开源实现。</p>
<p>绝大部分的https请求等价于http + OpenSSL。</p>
<p>OpenSSH是用来保证登录安全性的，而这个安全由OpenSSL来具体实现。</p>
</div>
<h2 id="Mac如何远程登录到iPhone">Mac如何远程登录到iPhone</h2>
<h3 id="方式一：通过网络连接">方式一：通过网络连接</h3>
<p>iOS下有两个常用的账户：root、mobile。</p>
<p>root账户拥有最高权限，mobile是普通权限账户。</p>
<p>现在我们来看如何在Mac上远程登录iPhone：</p>
<div class="note green no-icon flat"><p>1.首先在Cydia中下载插件<code>OpenSSH</code></p>
<p>2.保证Mac和iPhone在同一个局域网下（连接同一个Wifi）</p>
<p>3.使用命令<code>ssh 账户名@服务主机地址</code>登录到iPhone，这里账户名：root，服务主机地址：连接的Wifi设置里面查看</p>
<p><strong>注意</strong>：首次登录的初始化密码为：alpine</p>
</div>
<p>效果图如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/2.png" alt="2"></p>
<p>此时我们通过命令行在iPhone下创建一个<code>test.txt</code>的文本，此时通过<code>iFunBox</code>查看，会发现root账户下多了一个刚创建的文本：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/3.png" alt="3"></p>
<p>到这里，说明我们已经成功建立Mac和iPhone的连接。</p>
<div class="note red no-icon flat"><p><strong>提示</strong>：</p>
<p>如果在登录的过程中出现如下错误：<code>ssh: connect to host xxx port 22: Operation timed out</code>，可以<code>ping 主机地址</code>看看网络是否连接上。</p>
</div>
<h3 id="方式二：通过USB连接">方式二：通过USB连接</h3>
<p>默认情况下，SSH走的协议是TCP协议，Mac是通过网络连接的方式登录到iPhone，所以如果网络环境不好可能会造成传输速度比较慢的情况。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/4.png" alt="4"></p>
<p>为了加快传输的速度可以使用USB的方式进行登录，Mac上有个服务程序<code>usbmuxd</code>，<code>usbmuxd</code>是开机启动的，它可以将Mac的数据通过USB传输到iPhone上。</p>
<p>使用USB的方式连接的具体步骤如下：</p>
<div class="note pink no-icon flat"><ol>
<li>
<p>下载<code>usbmuxd</code>工具包</p>
</li>
<li>
<p>使用如下命令将iPhone的22端口（SSH端口）映射到本地的xxxxx端口（这个端口是任意的，只要不是保留端口就可以）</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">cd usbmuxd<span class="number">-1.0</span><span class="number">.8</span>/python-client <span class="comment">// 下载usbmuxd工具目录下</span></span><br><span class="line">python tcprelay.py -t <span class="number">22</span>:<span class="number">10010</span> <span class="comment">// 10010只要不是保留端口就行 -t是为了能够支持多个SSH连接</span></span><br></pre></td></tr></table></figure>
<p>端口映射完毕后，以后要想跟iPhone的22端口通信只需要跟Mac本地的10010端口通信即可，<code>usbmuxd</code>会将Mac本地10010端口的TCP协议数据通过USB的方式传到iPhone的22端口。</p>
</li>
<li>
<p>使用如下命令新开一个终端窗口，SSH登录到Mac本地的10010端口</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ssh root@localhost -p <span class="number">10010</span></span><br><span class="line">或</span><br><span class="line">ssh root@MacIP地址 -p <span class="number">10010</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</div>
<p>博主这里的操作如下图：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/5.png" alt="5"></p>
<p>此时，映射关系已经建立完毕。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/6.png" alt="6"></p>
<p>登录到Mac本地的10010端口，此时连接已经完成，创建<code>touch usbLoginTest.txt</code>的一个文本测试一下，会发现iPhone上多了我们刚刚创建的文本：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/7.png" alt="7"></p>
<p>USB登录的整个流程如下图：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/8.png" alt="8"></p>
<h2 id="写在最后-4">写在最后</h2>
<p>关于【如何让Mac和iPhone建立安全连接的两种方式】的文章就写到这里了，如有错误请多多指教。</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
        <tag>iPhone</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS逆向】最全的SSH通信过程</title>
    <url>/posts/beccfc53/</url>
    <content><![CDATA[<h2 id="写在前面-11">写在前面</h2>
<p>在<a href="https://codersunny.com/posts/7df93f3b/">【iOS逆向】如何让Mac和iPhone建立安全连接</a>文章中我们主要讲了Mac和iPhone如何建立安全连接，让我们在Mac上可以通过命令来控制iPhone，但是其实我们使用相关登录命令到登录到iPhone中间是有一个过程的，我们本篇文章就是来分析一下这个过程是什么样的，这个过程包括：</p>
<ul>
<li>建立安全连接</li>
<li>客户端认证</li>
</ul>
<h2 id="建立安全连接">建立安全连接</h2>
<p>在建立安全连接的过程中，服务器会提供自己的身份证明：公钥信息。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1209/1.png" alt="1"></p>
<p>如果客户端并没有保存过服务器的公钥信息，会出现如下提示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1209/2.png" alt="2"></p>
<p>这其实是在问我们是否需要保存这个公钥信息，我们选择【yes】之后保存，在客户端的ssh文件中查看相应的内容：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1209/3.png" alt="3"></p>
<p>如果是首次进行该操作，会提示我们输入密码进行登录。</p>
<h2 id="客户端认证">客户端认证</h2>
<p>SSH提供了两种认证的方式：</p>
<p>1、密码登录的认证方式</p>
<p>2、基于【密钥】的认证方式</p>
<div class="note pink no-icon flat"><p>SSH会优先使用密钥的认证方式，如果认证失败才会采用密码登录的方式进行认证。</p>
</div>
<p>我们这里重点来说一下基于密钥的认证方式是怎么样的。</p>
<h3 id="客户端生成公钥和私钥信息">客户端生成公钥和私钥信息</h3>
<p>1、通过下面的方式查看客户端是否生成过公钥和密钥：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1209/4.png" alt="4"></p>
<p>如果没有生成，通过命令<code>ssh-keygen</code>来生成公钥和私钥信息，如果已经生成，直接到第二步。</p>
<p>2、使用命令<code>ssh-copy-id root@服务器ip地址</code>将公钥信息追加到授权文件尾部，如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1209/5.png" alt="5"></p>
<p>我们来验证一下客户端和服务端存储的信息是否一致？</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1209/6.png" alt="6"></p>
<p>完成上述操作后，下次登录到iPhone就不再需要密码了。</p>
<div class="note orange no-icon flat"><p>如果按照上面方式配置了还是需要密码登录，需要使用下面操作修改一下权限（在iPhone的root账户下）：</p>
<p><code>chmod 755 ~</code></p>
<p><code>chmod 755 ~/.ssh</code></p>
<p><code>chmod 644 ~/.ssh/authorized_keys</code></p>
</div>
<h2 id="删除客户端保存的服务器的公钥信息">删除客户端保存的服务器的公钥信息</h2>
<p>有时候提供服务器的身份信息会发生变化，我们可能需要删掉客户端保存的公钥信息：</p>
<p>第一种方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~./ssh</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line">vim known_hosts(找到对应的信息进行删除)</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure>
<p>第二种方式：<code>ssh-keygen -R 服务器ip地址</code></p>
<h2 id="写在最后-5">写在最后</h2>
<p>关于SSH如何建立安全连接和客户端认证的文章就写到这里了，如有错误请多多指教。</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】Block底层原理（二）</title>
    <url>/posts/57c4c4a9/</url>
    <content><![CDATA[<h2 id="写在前面-12">写在前面</h2>
<p>在上一篇文章<a href="https://codersunny.com/posts/67d22871/">【iOS重学】Block底层原理（一）</a>中我们主要讲了Block的基本使用、底层原理、对变量的捕获机制以及Block的几种类型，本文是第二篇，主要内容包含：</p>
<ul>
<li><code>__block</code>修饰符的基本使用</li>
<li><code>__block</code>修饰的变量在Block内部的底层结构</li>
<li><code>__block</code>的内存管理</li>
<li>循环引用</li>
</ul>
<h2 id="Block的基本使用">__Block的基本使用</h2>
<p>如果想在Block内部修改auto变量的值，我们一般是无法直接修改的，会报如下错误：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/1.png" alt="1"></p>
<p><code>__block</code>修饰符就是用来解决Block内部无法修改auto变量值的问题。</p>
<div class="note green no-icon flat"><p><code>__block</code>不能用来修饰全局变量、static变量。</p>
</div>
<h2 id="block修饰的变量底层结构探究">__block修饰的变量底层结构探究</h2>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>(^Block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line">Block();</span><br></pre></td></tr></table></figure>
<p>如上，使用<code>__block</code>修饰的变量在Block内部之后的底层结构是什么样的呢？跟之前对比有什么不一样。</p>
<p>不使用<code>__block</code>修饰符，Block底层结构如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/2.png" alt="2"></p>
<p>使用<code>__block</code>修饰符，Block底层结构如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/3.png" alt="3"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/4.png" alt="4"></p>
<p>我们发现底层结构确实发生了变化：被<code>__block</code>修饰的变量会被包装成一个<code>__Block_byref_age_0</code>的对象，这个对象的结构里面有个<code>int age</code>，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_age_0</span> &#123;</span><br><span class="line">  <span class="type">void</span> *__isa;</span><br><span class="line">  __Block_byref_age_0 *__forwarding; <span class="comment">// 是指向自己的一个指针</span></span><br><span class="line">  <span class="type">int</span> __flags;</span><br><span class="line">  <span class="type">int</span> __size;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note orange no-icon flat"><p><strong>问题</strong>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *tempArr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="type">void</span>(^Block)(<span class="type">void</span>) =  ^()&#123;</span><br><span class="line">  [tempArr addObject:<span class="string">@&quot;1&quot;</span>];</span><br><span class="line">&#125;;</span><br><span class="line">Block();</span><br></pre></td></tr></table></figure>
<p>以上代码结果是否会报错？</p>
<p>不会，<code>[tempArr addObject:@&quot;1&quot;]</code>只是在使用<code>tempArr</code>指针并没有修改<code>tempArr</code>。</p>
</div>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;1---%p&quot;</span>,&amp;age);</span><br><span class="line"><span class="type">void</span>(^Block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,age);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2---%p&quot;</span>,&amp;age);</span><br><span class="line">&#125;;</span><br><span class="line">Block();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;3---%p&quot;</span>,&amp;age);</span><br></pre></td></tr></table></figure>
<p>我们打印<code>age</code>的地址看一下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">52.006645</span>+<span class="number">0800</span> BlockDemo[<span class="number">8781</span>:<span class="number">6613854</span>] <span class="number">1</span>--<span class="number">-0x7ff7bfeff2d8</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">52.007272</span>+<span class="number">0800</span> BlockDemo[<span class="number">8781</span>:<span class="number">6613854</span>] age is <span class="number">10</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">52.007357</span>+<span class="number">0800</span> BlockDemo[<span class="number">8781</span>:<span class="number">6613854</span>] <span class="number">2</span>--<span class="number">-0x100b478a8</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">52.007395</span>+<span class="number">0800</span> BlockDemo[<span class="number">8781</span>:<span class="number">6613854</span>] <span class="number">3</span>--<span class="number">-0x100b478a8</span></span><br></pre></td></tr></table></figure>
<p>从打印结果我们看到1和2、3的age的地址值不一样，我们可以根据上面的底层结构探索来解释一下为什么？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_age_0</span> &#123;</span><br><span class="line"> <span class="type">void</span> *__isa;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">__Block_byref_age_0</span> *__forwarding;</span><br><span class="line"> <span class="type">int</span> __flags;</span><br><span class="line"> <span class="type">int</span> __size;</span><br><span class="line"> <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__block_impl</span> &#123;</span><br><span class="line">  <span class="type">void</span> *isa;</span><br><span class="line">  <span class="type">int</span> Flags;</span><br><span class="line">  <span class="type">int</span> Reserved;</span><br><span class="line">  <span class="type">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__Block_byref_age_0</span> *age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__block <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;1---%p&quot;</span>,&amp;age);</span><br><span class="line"><span class="built_in">void</span>(^Block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;age is %d&quot;</span>,age);</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;2---%p&quot;</span>,&amp;age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> *implBlock = (__bridge <span class="keyword">struct</span> __main_block_impl_0  *)Block;</span><br></pre></td></tr></table></figure>
<p>我们把Block转为<code>__main_block_impl_0</code>的结构体来分析一下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/5.png" alt="5"></p>
<p>Block内部的<code>__Block_byref_age_0</code>结构体地址值是：<code>0x100e1c7e0</code>，而我们打印age的地址值是：<code>0x100e1c7f8</code>，两个不一样，说明打印的age的地址值不是<code>__Block_byref_age_0</code>结构体age的值，接着往下分析：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 地址值：0x100e1c7e0</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_age_0</span> &#123;</span><br><span class="line"> <span class="type">void</span> *__isa; <span class="comment">// 8byte __isa地址值：0x100e1c7e0</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">__Block_byref_age_0</span> *__forwarding; <span class="comment">// 8byte __forwarding地址值：0x100e1c7e8</span></span><br><span class="line"> <span class="type">int</span> __flags;<span class="comment">// 4byte __flags地址值：0x100e1c7d2</span></span><br><span class="line"> <span class="type">int</span> __size; <span class="comment">// 4byte __size地址值：0x100e1c7d6</span></span><br><span class="line"> <span class="type">int</span> age;<span class="comment">// 4byte age地址值：0x100e1c7d8</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过上面的分析我们看到：我们打印的age的地址值其实是<code>__Block_byref_age_0</code>结构体中age的地址值。</p>
<h2 id="block的内存管理">__block的内存管理</h2>
<p>在上面我们分析的是基本数据类型用<code>__block</code>来修饰，我们接下来看一下更复杂的情况：<code>__block</code>用来修饰对象类型。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="type">void</span>(^Block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;object is %@&quot;</span>,object);</span><br><span class="line">&#125;;</span><br><span class="line">Block();</span><br></pre></td></tr></table></figure>
<p>底层结构如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/6.png" alt="6"></p>
<p>这里有两点值得我们注意一下：</p>
<p>1的位置多了两个函数<code>copy</code>和<code>dispose</code>，这点我们在上一篇文章讲到过因为Block捕获的变量是对象类型，所以会有这两个函数，这里我们就不赘述了，除此之外我们发现<code>__Block_byref_object_0</code>这个结构体里面也多了两个函数：<code>__Block_byref_id_object_copy</code>和<code>__Block_byref_id_object_dispose</code>，里面具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __Block_byref_id_object_copy_131(<span class="type">void</span> *dst, <span class="type">void</span> *src) &#123;</span><br><span class="line"> _Block_object_assign((<span class="type">char</span>*)dst + <span class="number">40</span>, *(<span class="type">void</span> * *) ((<span class="type">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __Block_byref_id_object_dispose_131(<span class="type">void</span> *src) &#123;</span><br><span class="line"> _Block_object_dispose(*(<span class="type">void</span> * *) ((<span class="type">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部也是调用的<code>_Block_object_assign</code>和<code>_Block_object_dispose</code>，和我们之前讲的是一样的。</p>
<p>并且我们看到<code>__Block_byref_object_0</code>结构体里面会对<code>object</code>这个对象有一个强引用。</p>
<p>下面我们来总结一下：</p>
<p>1、当Block在栈上时，并不会对<code>__block</code>修饰的变量产生强引用。</p>
<p>2、当Block被copy到堆上时，会调用Block内部的<code>copy</code>函数，<code>copy</code>函数内部会调用<code>__Block_object_assign</code>函数，<code>__Block_object_assign</code>函数会对<code>__block</code>修饰的变量形成强引用。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/7.png" alt="7"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/8.png" alt="8"></p>
<p>3、当Block从堆中移除时，会调用Block内部的<code>dispose</code>函数，<code>dispose</code>函数内部会调用<code>__Block_object_dispose</code>函数，<code>__Block_object_dispose</code>会对<code>__block</code>修饰的变量进行一次release操作。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/9.png" alt="9"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/10.png" alt="10"></p>
<h2 id="Block的循环引用">Block的循环引用</h2>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="type">void</span>(^PersonBlock)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *person = [[Person alloc] init];</span><br><span class="line">        person.age = <span class="number">10</span>;</span><br><span class="line">        person.PersonBlock = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;person&#x27;s age is %d&quot;</span>,person.age);</span><br><span class="line">        &#125;;</span><br><span class="line">        person.PersonBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;--------&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-08</span> <span class="number">16</span>:<span class="number">07</span>:<span class="number">45.878556</span>+<span class="number">0800</span> BlockDemo[<span class="number">9541</span>:<span class="number">6681377</span>] person<span class="string">&#x27;s age is 10</span></span><br><span class="line"><span class="string">2022-12-08 16:07:45.879146+0800 BlockDemo[9541:6681377] --------</span></span><br></pre></td></tr></table></figure>
<p>发现<code>person</code>对象并没有被释放还存在内存里面，这就是我们常说的循环引用（内存泄漏）。</p>
<p>下图表示了上面对象之间的持有关系：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/11.png" alt="11"></p>
<p>如何解决循环引用？</p>
<p>其实就是把2和3其中一个变成弱引用即可，那么到底2和3谁变成弱引用更合适呢，3是<code>Person</code>对象有一个<code>PersonBlock</code>这个属性，我们希望当这个<code>Person</code>对象还在的时候随时能访问到<code>PersonBlock</code>，所以3应该是个强引用，我们把2换成弱引用即可。</p>
<ul>
<li>使用<code>__weak</code>，<code>__unsafe_unretain</code></li>
<li>使用<code>_block</code>，但是必须调用block</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(person) weakPerson = person;</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line">person.PersonBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;person&#x27;s age is %d&quot;</span>,weakPerson.age);</span><br><span class="line">&#125;;</span><br><span class="line">person.PersonBlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="keyword">typeof</span>(person) weakPerson = person;</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line">person.PersonBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;person&#x27;s age is %d&quot;</span>,weakPerson.age);</span><br><span class="line">&#125;;</span><br><span class="line">person.PersonBlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三</span></span><br><span class="line">__block Person *person = [[Person alloc] init];</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line">person.PersonBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;person&#x27;s age is %d&quot;</span>,person.age);</span><br><span class="line">    person = <span class="literal">nil</span>;</span><br><span class="line">&#125;;</span><br><span class="line">person.PersonBlock();</span><br></pre></td></tr></table></figure>
<p>我们来分析一下<code>__block</code>修饰的变量的内存问题：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block Person *person = [[Person alloc] init];</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line">person.PersonBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;person&#x27;s age is %d&quot;</span>,person.age);</span><br><span class="line">&#125;;</span><br><span class="line">person.PersonBlock();</span><br></pre></td></tr></table></figure>
<p>用一张图来表示他们之间的引用关系：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/12.png" alt="12"></p>
<p>如何解决循环引用？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">__block __<span class="keyword">weak</span> <span class="keyword">typeof</span>(person) weakPerson = person;</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line">person.PersonBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;person&#x27;s age is %d&quot;</span>,weakPerson.age);</span><br><span class="line">&#125;;</span><br><span class="line">person.PersonBlock();</span><br></pre></td></tr></table></figure>
<p>底层结构如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/13.png" alt="13"></p>
<p>这样我们就可以解决Block带来的一些循环引用的问题啦。</p>
<h2 id="写在最后-6">写在最后</h2>
<p>关于Block的底层原理在这里就全部结束了，如有错误请多多指教。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】Block底层原理（一）</title>
    <url>/posts/67d22871/</url>
    <content><![CDATA[<h2 id="写在前面-13">写在前面</h2>
<p>关于<code>Block</code>的底层原理相关东西，需要了解的东西比较多，所以博主这里打算用两篇文章来详细分析一下OC里面的<code>Block</code>，这是第一篇，内容主要包含：</p>
<ul>
<li>Block的基本使用</li>
<li>Block的底层数据结构</li>
<li>Block对变量的捕获</li>
<li>Block的类型</li>
</ul>
<p>好了，废话少说，现在跟着博主开始从头了解Block吧。</p>
<h2 id="Block的基本使用-2">Block的基本使用</h2>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Block</span></span><br><span class="line"><span class="type">void</span>(^WWBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;This is a block...&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 调用Block</span></span><br><span class="line">WWBlock();</span><br></pre></td></tr></table></figure>
<p>以上是最简单的一个Block，调用<code>Block()</code>会打印：<code>This is a block...</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)fetchDataWithSuccess:(<span class="type">void</span>(^)(<span class="built_in">NSString</span> *message))successBlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)fetchDataWithSuccess:(<span class="type">void</span>(^)(<span class="built_in">NSString</span> *message))successBlock &#123;</span><br><span class="line">    <span class="keyword">if</span> (successBlock) &#123;</span><br><span class="line">        successBlock(<span class="string">@&quot;这是一个成功的回调...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">[person fetchDataWithSuccess:^(<span class="built_in">NSString</span> *message) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;---- %@&quot;</span>, message);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-06</span> <span class="number">19</span>:<span class="number">30</span>:<span class="number">08.775142</span>+<span class="number">0800</span> BlockDemo[<span class="number">53402</span>:<span class="number">5642770</span>] ---- 这是一个成功的回调...</span><br></pre></td></tr></table></figure>
<p>相信这种类似的Block大家在日常项目中会看到很多很多，我们这里就不再一一列举了。</p>
<h2 id="Block的底层数据结构">Block的底层数据结构</h2>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Block</span></span><br><span class="line"><span class="type">void</span>(^WWBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;This is a block...&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 调用Block</span></span><br><span class="line">WWBlock();</span><br></pre></td></tr></table></figure>
<p>我们来看一下上面最简单的Block的底层C++结构是什么样的，使用命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code>转为C++代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="comment">// 定义Block</span></span><br><span class="line">        <span class="built_in">void</span>(*WWBlock)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">                            </span><br><span class="line">        <span class="comment">// 调用Block               </span></span><br><span class="line">        ((<span class="built_in">void</span> (*)(__block_impl *))((__block_impl *)WWBlock)-&gt;FuncPtr)((__block_impl *)WWBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把相应的强制转换给去掉能够帮助我们更清晰的理解Block的结构，去掉一些强制转换之后如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Block</span></span><br><span class="line"><span class="built_in">void</span>(*WWBlock)(<span class="type">void</span>) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"><span class="comment">// 调用Block      </span></span><br><span class="line">WWBlock-&gt;<span class="built_in">FuncPtr</span>(WWBlock);</span><br></pre></td></tr></table></figure>
<p>可以看到跟Block相关的有：<code>__main_block_impl_0</code>、<code>__main_block_func_0</code>、<code>__main_block_dec_0_DATA</code>这几个类，在生成的C++文件里面找到相关的结构如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/1.png" alt="1"></p>
<p>从上面的图里面我们可以看到，Block的结构里面也有一个<code>isa</code>指针，所以Block的本质其实也是一个【<strong>OC对象</strong>】，是一个封装了函数调用及其调用环境的OC对象。</p>
<p>对应关系如下图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/2.png" alt="2"></p>
<p>在调用的时候<code>WWBlock-&gt;FuncPtr(WWBlock)</code>，相当于是拿到<code>WWBlock</code>结构里面的函数指针<code>FuncPtr</code>去调用对应的方法，这个函数指针里面其实存放的就是Block代码块的地址。</p>
<h2 id="Block对变量的捕获">Block对变量的捕获</h2>
<p>为什么Block会对变量进行捕获？</p>
<p>因为在Block里面可能需要访问Block外部变量的值，所以需要捕获（capture）变量保证我们能正确访问到变量。</p>
<p>我们现在分别来分析【auto变量】、【static变量】、【全局变量】三种不同的变量，Block对其捕获是不是也不一样呢？</p>
<h3 id="auto变量">auto变量</h3>
<p>auto变量：离开当前作用域就会销毁的变量。</p>
<h4 id="1、非对象类型的auto变量">1、非对象类型的auto变量</h4>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Block</span></span><br><span class="line"><span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>(^WWBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;对auoto变量的捕获 - %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line">age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用Block</span></span><br><span class="line">WWBlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-06</span> <span class="number">20</span>:<span class="number">18</span>:<span class="number">28.957166</span>+<span class="number">0800</span> BlockDemo[<span class="number">54326</span>:<span class="number">5689813</span>] 对auoto变量的捕获 - <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>底层C++代码如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/3.png" alt="3"></p>
<p>跟前面我们没有捕获变量相比，会把<code>age</code>传递到Block里面：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/4.png" alt="4"></p>
<p>从底层结构我们也看到了：Block会对auto变量进行捕获，访问的方式是【值传递】。</p>
<h4 id="2、对象类型的auto变量">2、对象类型的auto变量</h4>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">void</span>(^WWBlock)(<span class="type">void</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            Person *person = [[Person alloc] init];</span><br><span class="line">            person.age = <span class="number">10</span>;</span><br><span class="line">            WWBlock = ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;person&#x27;s age is %d&quot;</span>,person.age);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;-----&quot;</span>);</span><br><span class="line">        WWBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">31.593895</span>+<span class="number">0800</span> BlockDemo[<span class="number">2248</span>:<span class="number">6132111</span>] -----</span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">31.594542</span>+<span class="number">0800</span> BlockDemo[<span class="number">2248</span>:<span class="number">6132111</span>] person<span class="string">&#x27;s age is 10</span></span><br><span class="line"><span class="string">2022-12-07 15:45:31.594693+0800 BlockDemo[2248:6132111] -[Person dealloc]</span></span><br></pre></td></tr></table></figure>
<p>底层结构代码如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/11.png" alt="11"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/12.png" alt="12"></p>
<p>对照上面的底层数据结构发现：多了两个函数<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code>。</p>
<p>当Block被拷贝到堆上时，会调用Block内部的copy函数<code>__main_block_copy_0</code>，函数里面调用<code>_Block_object_assign</code>，在<code>_Block_object_assign</code>里面根据auto变量的修饰符做出相应的操作：强引用或弱引用。</p>
<p>当Block从对上移除时，会调用Block内部的dispose函数<code>__main_block_dispose_0</code>，函数里面调用<code>_Block_object_dispose</code>，<code>_Block_object_dispose</code>去对引用的auto变量进行一次release操作。</p>
<div class="note pink no-icon flat"><p>在使用clang转换OC为C++代码时，如果有<code>__weak</code>可能会出现下面报错：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/13.png" alt="13"></p>
<p>让其支持ARC、指定运行时系统版本即可，比如：</p>
<p>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-14.0.0 main.m</p>
</div>
<h3 id="static变量">static变量</h3>
<p>static变量：离开当前作用域不会销毁的变量。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Block</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>(^WWBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;对static变量的捕获 - %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line">age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用Block</span></span><br><span class="line">WWBlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-06</span> <span class="number">20</span>:<span class="number">27</span>:<span class="number">55.716204</span>+<span class="number">0800</span> BlockDemo[<span class="number">54594</span>:<span class="number">5700817</span>] 对<span class="keyword">static</span>变量的捕获 - <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>底层C++代码如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/5.png" alt="5"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/6.png" alt="6"></p>
<p>从底层结构我们也看到了：Block会对static变量进行捕获，访问的方式是【指针传递】。</p>
<h3 id="全局变量">全局变量</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">      <span class="comment">// 定义一个Block</span></span><br><span class="line">      age = <span class="number">10</span>;</span><br><span class="line">      <span class="type">void</span>(^WWBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,age);</span><br><span class="line">      &#125;;</span><br><span class="line">      age = <span class="number">20</span>;</span><br><span class="line">      <span class="comment">// 调用Block</span></span><br><span class="line">      WWBlock();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-07</span> <span class="number">13</span>:<span class="number">39</span>:<span class="number">45.012065</span>+<span class="number">0800</span> BlockDemo[<span class="number">197</span>:<span class="number">6032120</span>] age is <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>底层C++代码如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/7.png" alt="7"></p>
<p>从底层结构我们发现：Block不会对全局变量进行捕获，直接访问全局变量即可。</p>
<div class="note green no-icon flat"><p><strong>思考</strong>：</p>
<p>1、为什么Block不会捕获全局变量，但是局部变量需要捕获？</p>
<p>全局变量在任何时候任何地方都是可以访问到的，因此不需要捕获可以直接访问。</p>
<p>局部变量因为作用域的问题需要被捕获，保证Block内部能够正确访问到该变量。</p>
<p>2、Block会对捕获self吗？</p>
<p>会，说明self是个局部变量。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test &#123;</span><br><span class="line">    <span class="keyword">self</span>.age = <span class="number">10</span>;</span><br><span class="line">    <span class="type">void</span>(^WWBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>, <span class="keyword">self</span>.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    WWBlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>底层C++代码如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/9.png" alt="9"></p>
<p><code>self</code>和<code>_cmd</code>其实是两个隐式参数，所以我们能在里面正常访问<code>self</code>、<code>_cmd</code>。</p>
</div>
<h3 id="Block捕获变量总结">Block捕获变量总结</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/8.png" alt="8"></p>
<h2 id="Block的类型">Block的类型</h2>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>(^block1)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;This is block...&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>(^block2)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %@ %@&quot;</span>,[block1 <span class="keyword">class</span>],[block2 <span class="keyword">class</span>],[^&#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>, age);&#125; <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %@ %@&quot;</span>,[[block1 <span class="keyword">class</span>] superclass], [[block2 <span class="keyword">class</span>] superclass], [[^&#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>, age);&#125; <span class="keyword">class</span>] superclass]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">29.626370</span>+<span class="number">0800</span> BlockDemo[<span class="number">2188</span>:<span class="number">6126897</span>] __NSGlobalBlock__ __NSMallocBlock__ __NSStackBlock__</span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">29.627050</span>+<span class="number">0800</span> BlockDemo[<span class="number">2188</span>:<span class="number">6126897</span>] <span class="built_in">NSBlock</span> <span class="built_in">NSBlock</span> <span class="built_in">NSBlock</span></span><br></pre></td></tr></table></figure>
<p>Block有三种类型：<code>__NSGlobalBlock__</code>、<code>__NSMallocBlock__</code>、<code>__NSStackBlock__</code>，都继承自<code>NSBlock</code>。</p>
<div class="note blue no-icon flat"><p><strong>注意</strong>：编译完的Block类型和运行时的Block类型会有一些区别。</p>
</div>
<h3 id="应用程序的内存分配">应用程序的内存分配</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/10.png" alt="10"></p>
<p>程序区域（代码段）：存放的就是我们写的一些代码。</p>
<p>数据区域：一般是存放一些全局变量。</p>
<p>堆：动态分配内存，自己管理内存。</p>
<p>栈：系统自动分配内存，不需要自己管理内存。</p>
<h3 id="Block类型总结">Block类型总结</h3>
<div class="note blue no-icon flat"><p>1、只要没有访问auto变量的Block都是<code>__NSGlobalBlock__</code>类型的。</p>
<p>2、访问了auto变量的Block是<code>__NSStackBlock__</code>类型的，因为我们是在ARC环境下，会自动进行copy操作，所以是<code>__NSMallocBlock__</code>类型的。</p>
<p>3、<code>__NSGlobalBlock__</code>类型的Block调用了copy还是<code>__NSGlobalBlock__</code>类型。</p>
</div>
<h3 id="Block的copy操作">Block的copy操作</h3>
<p>在ARC环境下，编译器会根据情况自动将栈上的Block复制到堆上，比如以下情况：</p>
<ul>
<li>block作为函数返回值</li>
<li>将block赋值给<code>__strong</code>指针时</li>
<li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li>
<li>block作为GCD API的方法参数时</li>
</ul>
<div class="note orange no-icon flat"><p><strong>注意</strong>：MRC下Block使用copy关键字修饰，ARC下Block使用strong或copy都可以，建议使用copy，与MRC下保持一致。</p>
</div>
<h2 id="写在最后-7">写在最后</h2>
<p>关于Block底层原理的第一篇我们就分享到这里，如有错误请多多指教。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】Category的底层原理</title>
    <url>/posts/dfd029e5/</url>
    <content><![CDATA[<h2 id="写在前面-14">写在前面</h2>
<p>本文博主将从<code>Category</code>的基本使用和底层原理来窥探一下Runtime下的<code>Category</code> 是如何实现的。博主这里参考的苹果源码版本是：<code>objc4_838</code>版本。</p>
<h2 id="Category的基本使用">Category的基本使用</h2>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person + Test 分类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>使用命令：<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc Person+Test.m -o Person+test.cpp</code>将<code>Person+Test.m</code>文件转化为c++底层代码，分析该c++文件，我们可以看到分类的底层结构为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> _category_t &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">char</span> *name; <span class="comment">// 类名</span></span><br><span class="line">	<span class="keyword">struct</span> _class_t *cls;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> _method_list_t *instance_methods; <span class="comment">// 实例方法列表</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> _method_list_t *class_methods; <span class="comment">// 类方法列表</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> _protocol_list_t *protocols; <span class="comment">// 协议列表</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> _prop_list_t *properties; <span class="comment">// 属性列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Person+Test.m</code>底层结构为：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/8.png" alt="8"></p>
<p>对应上面<code>_category_t</code>结构可以看到：</p>
<div class="note red no-icon flat"><p>1.本类名为<code>Person</code>。</p>
<p>2.因为<code>Person+Test.m</code>我们只写了一个test的实例方法，所以我这里也很明显看到这里传了一个方法列表。</p>
<p><strong>注</strong>：这里的<code>_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Test</code>其实就是一个结构体名称。</p>
</div>
<h2 id="Category底层原理窥探">Category底层原理窥探</h2>
<p>运行时Runtime入口：<code>objc-os.mm</code>文件。</p>
<p>Category源码阅读顺序：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-os.mm 文件</span></span><br><span class="line"><span class="number">1.</span> _objc_init </span><br><span class="line"><span class="number">3.</span> map_images_nolock</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc_runtime_new.mm 文件</span></span><br><span class="line"><span class="number">2.</span> map_images</span><br><span class="line"><span class="number">4.</span> loadAllCategories();</span><br><span class="line"><span class="number">5.</span> load_categories_nolock();</span><br><span class="line"><span class="number">6.</span> attachCategories();</span><br><span class="line"><span class="number">7.</span> attachLists();</span><br></pre></td></tr></table></figure>
<p>其中 4 - 7 是我们接下来需要重点分析的。</p>
<h3 id="Category-t-结构体">Category_t 结构体</h3>
<p>Runtime下<code>Category_t</code>结构体如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> category_t &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">char</span> *name;</span><br><span class="line">  classref_t cls;</span><br><span class="line">  WrappedPtr&lt;method_list_t, method_list_t::Ptrauth&gt; instanceMethods;</span><br><span class="line">  WrappedPtr&lt;method_list_t, method_list_t::Ptrauth&gt; classMethods;</span><br><span class="line">  <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">  <span class="keyword">struct</span> property_list_t *instanceProperties;</span><br><span class="line">  <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">  <span class="keyword">struct</span> property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">  method_list_t *methodsForMeta(<span class="type">bool</span> isMeta) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  property_list_t *propertiesForMeta(<span class="type">bool</span> isMeta, <span class="keyword">struct</span> header_info *hi);</span><br><span class="line"></span><br><span class="line">  protocol_list_t *protocolsForMeta(<span class="type">bool</span> isMeta) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> nullptr;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> protocols;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="map-images-nolock">map_images_nolock</h3>
<p><code>map_images_nolock</code>可以理解为是运行时的开始，内部实现如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/9.png" alt="9"></p>
<p>从上图可以看到：这里因为是倒序遍历也就影响了分类方法之间的优先级顺序，所以后编译的分类方法会放在先编译的前面。</p>
<h3 id="loadAllCategories">loadAllCategories</h3>
<p>该方法指的是：加载项目中所有分类。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> loadAllCategories() &#123;</span><br><span class="line">  mutex_locker_t lock(runtimeLock);</span><br><span class="line">  <span class="keyword">for</span> (auto *hi = FirstHeader; hi != <span class="literal">NULL</span>; hi = hi-&gt;getNext()) &#123;</span><br><span class="line">    <span class="comment">// 加载每个类所有的分类模块</span></span><br><span class="line">    load_categories_nolock(hi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="load-categories-nolock">load_categories_nolock</h3>
<p>该方法指的是：加载一个类所有的分类模块。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> load_categories_nolock(header_info *hi) &#123;</span><br><span class="line">  <span class="comment">// 是否有类属性</span></span><br><span class="line">  <span class="type">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">  size_t count;</span><br><span class="line">  auto processCatlist = [&amp;](category_t * <span class="keyword">const</span> *catlist) &#123;</span><br><span class="line">      <span class="comment">// 遍历需要处理的分类列表</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          category_t *cat = catlist[i];</span><br><span class="line">          <span class="comment">// 获取分类的主类</span></span><br><span class="line">          Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">          locstamped_category_t lc&#123;cat, hi&#125;;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">              <span class="comment">// 获取不到本类 可能是弱链接</span></span><br><span class="line">              <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                  _objc_inform(<span class="string">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span></span><br><span class="line">                               <span class="string">&quot;missing weak-linked target class&quot;</span>,</span><br><span class="line">                               cat-&gt;name, cat);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Process this category.</span></span><br><span class="line">          <span class="keyword">if</span> (cls-&gt;isStubClass()) &#123;</span><br><span class="line">              <span class="comment">// 无法确定元类对象是哪个 所以先附着在stubClass身上</span></span><br><span class="line">              <span class="comment">// Stub classes are never realized. Stub classes</span></span><br><span class="line">              <span class="comment">// don&#x27;t know their metaclass until they&#x27;re</span></span><br><span class="line">              <span class="comment">// initialized, so we have to add categories with</span></span><br><span class="line">              <span class="comment">// class methods or properties to the stub itself.</span></span><br><span class="line">              <span class="comment">// methodizeClass() will find them and add them to</span></span><br><span class="line">              <span class="comment">// the metaclass as appropriate.</span></span><br><span class="line">              <span class="keyword">if</span> (cat-&gt;instanceMethods ||</span><br><span class="line">                  cat-&gt;protocols ||</span><br><span class="line">                  cat-&gt;instanceProperties ||</span><br><span class="line">                  cat-&gt;classMethods ||</span><br><span class="line">                  cat-&gt;protocols ||</span><br><span class="line">                  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">              &#123;</span><br><span class="line">                  objc::unattachedCategories.addForClass(lc, cls);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// First, register the category with its target class.</span></span><br><span class="line">              <span class="comment">// Then, rebuild the class&#x27;s method lists (etc) if</span></span><br><span class="line">              <span class="comment">// the class is realized.</span></span><br><span class="line">              <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols</span><br><span class="line">                  ||  cat-&gt;instanceProperties)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span> (cls-&gt;isRealized()) &#123; <span class="comment">// 类对象已经初始化完毕 进行合并</span></span><br><span class="line">                      attachCategories(cls, &amp;lc, <span class="number">1</span>, ATTACH_EXISTING);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      objc::unattachedCategories.addForClass(lc, cls);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols</span><br><span class="line">                  ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123; <span class="comment">// 元类对象已经初始化完毕 进行合并</span></span><br><span class="line">                      attachCategories(cls-&gt;ISA(), &amp;lc, <span class="number">1</span>, ATTACH_EXISTING | ATTACH_METACLASS);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      objc::unattachedCategories.addForClass(lc, cls-&gt;ISA());</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  processCatlist(hi-&gt;catlist(&amp;count));</span><br><span class="line">  processCatlist(hi-&gt;catlist2(&amp;count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="attachCategories">attachCategories</h3>
<p>该方法指的是：合并分类的方法列表、属性列表、协议列表等到本类里面。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span></span><br><span class="line">attachCategories(Class cls, <span class="keyword">const</span> locstamped_category_t *cats_list, uint32_t cats_count,</span><br><span class="line">                 <span class="type">int</span> flags) &#123;</span><br><span class="line">  <span class="keyword">if</span> (slowpath(PrintReplacedMethods)) &#123;</span><br><span class="line">      printReplacements(cls, cats_list, cats_count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (slowpath(PrintConnecting)) &#123;</span><br><span class="line">      _objc_inform(<span class="string">&quot;CLASS: attaching %d categories to%s class &#x27;%s&#x27;%s&quot;</span>,</span><br><span class="line">                   cats_count, (flags &amp; ATTACH_EXISTING) ? <span class="string">&quot; existing&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                   cls-&gt;nameForLogging(), (flags &amp; ATTACH_METACLASS) ? <span class="string">&quot; (meta)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Only a few classes have more than 64 categories during launch.</span></span><br><span class="line"><span class="comment">   * This uses a little stack, and avoids malloc.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Categories must be added in the proper order, which is back</span></span><br><span class="line"><span class="comment">   * to front. To do that with the chunking, we iterate cats_list</span></span><br><span class="line"><span class="comment">   * from front to back, build up the local buffers backwards,</span></span><br><span class="line"><span class="comment">   * and call attachLists on the chunks. attachLists prepends the</span></span><br><span class="line"><span class="comment">   * lists, so the final result is in the expected order.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  constexpr uint32_t ATTACH_BUFSIZ = <span class="number">64</span>;</span><br><span class="line">  method_list_t   *mlists[ATTACH_BUFSIZ];</span><br><span class="line">  property_list_t *proplists[ATTACH_BUFSIZ];</span><br><span class="line">  protocol_list_t *protolists[ATTACH_BUFSIZ];</span><br><span class="line"></span><br><span class="line">  uint32_t mcount = <span class="number">0</span>;</span><br><span class="line">  uint32_t propcount = <span class="number">0</span>;</span><br><span class="line">  uint32_t protocount = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> fromBundle = <span class="literal">NO</span>;</span><br><span class="line">  <span class="type">bool</span> isMeta = (flags &amp; ATTACH_METACLASS);</span><br><span class="line">  auto rwe = cls-&gt;data()-&gt;extAllocIfNeeded();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历某个类的分类列表</span></span><br><span class="line">  <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; cats_count; i++) &#123;</span><br><span class="line">      auto&amp; entry = cats_list[i];</span><br><span class="line">      <span class="comment">// 取出分类里面的方法列表</span></span><br><span class="line">      method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">      <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">              prepareMethodLists(cls, mlists, mcount, <span class="literal">NO</span>, fromBundle, __func__);</span><br><span class="line">              rwe-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">              mcount = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将分类的方法列表放在创建好的容器里面</span></span><br><span class="line">          mlists[ATTACH_BUFSIZ - ++mcount] = mlist;</span><br><span class="line">          fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出分类里面的属性列表</span></span><br><span class="line">      property_list_t *proplist =</span><br><span class="line">          entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">      <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">          <span class="keyword">if</span> (propcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">              rwe-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">              propcount = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          proplists[ATTACH_BUFSIZ - ++propcount] = proplist;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出分类里面的协议列表</span></span><br><span class="line">      protocol_list_t *protolist = entry.cat-&gt;protocolsForMeta(isMeta);</span><br><span class="line">      <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">          <span class="keyword">if</span> (protocount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">              rwe-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">              protocount = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          protolists[ATTACH_BUFSIZ - ++protocount] = protolist;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mcount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果有剩下的方法列表</span></span><br><span class="line">      prepareMethodLists(cls, mlists + ATTACH_BUFSIZ - mcount, mcount,</span><br><span class="line">                         <span class="literal">NO</span>, fromBundle, __func__);</span><br><span class="line">      <span class="comment">// 将剩下的方法列表附着在本类的方法列表</span></span><br><span class="line">      rwe-&gt;methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);</span><br><span class="line">      <span class="keyword">if</span> (flags &amp; ATTACH_EXISTING) &#123;</span><br><span class="line">          flushCaches(cls, __func__, [](Class c)&#123;</span><br><span class="line">              <span class="comment">// constant caches have been dealt with in prepareMethodLists</span></span><br><span class="line">              <span class="comment">// if the class still is constant here, it&#x27;s fine to keep</span></span><br><span class="line">              <span class="keyword">return</span> !c-&gt;cache.isConstantOptimizedCache();</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rwe-&gt;properties.attachLists(proplists + ATTACH_BUFSIZ - propcount, propcount);</span><br><span class="line"></span><br><span class="line">  rwe-&gt;protocols.attachLists(protolists + ATTACH_BUFSIZ - protocount, protocount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="attachLists">attachLists</h3>
<p>该方法指的是：把分类方法真正合并在主类的方法列表里面。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> attachLists(List* <span class="keyword">const</span> * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">  		<span class="comment">// 如果添加的方法列表count为0 直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">          <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        	<span class="comment">// 本类里面有多个方法列表</span></span><br><span class="line">          uint32_t oldCount = array()-&gt;count;</span><br><span class="line">          uint32_t newCount = oldCount + addedCount;</span><br><span class="line">          array_t *newArray = (array_t *)malloc(array_t::byteSize(newCount));</span><br><span class="line">          newArray-&gt;count = newCount;</span><br><span class="line">          array()-&gt;count = newCount;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> i = oldCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">              newArray-&gt;lists[i + addedCount] = array()-&gt;lists[i]; <span class="comment">// 这个其实是在把之前的方法列表挪到新数组后面。</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">              newArray-&gt;lists[i] = addedLists[i]; <span class="comment">// 把分类的方法列表添加到新数组里面。</span></span><br><span class="line">          free(array());</span><br><span class="line">          setArray(newArray);</span><br><span class="line">          validate();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!list  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 本类原本没有方法列表 分类方法列表Count == 1</span></span><br><span class="line">          list = addedLists[<span class="number">0</span>];</span><br><span class="line">          validate();</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 本类原本只有一个方法列表 </span></span><br><span class="line">          Ptr&lt;List&gt; oldList = list;</span><br><span class="line">          uint32_t oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">          uint32_t newCount = oldCount + addedCount;</span><br><span class="line">          setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">          array()-&gt;count = newCount;</span><br><span class="line">          <span class="keyword">if</span> (oldList) array()-&gt;lists[addedCount] = oldList;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">              array()-&gt;lists[i] = addedLists[i];</span><br><span class="line">          validate();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> tryFree() &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">          <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; array()-&gt;count; i++) &#123;</span><br><span class="line">              try_free(array()-&gt;lists[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          try_free(array());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (list) &#123;</span><br><span class="line">          try_free(list);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  template&lt;<span class="keyword">typename</span> Other&gt;</span><br><span class="line">  <span class="type">void</span> duplicateInto(Other &amp;other) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">          array_t *a = array();</span><br><span class="line">          other.setArray((array_t *)memdup(a, a-&gt;byteSize()));</span><br><span class="line">          <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; a-&gt;count; i++) &#123;</span><br><span class="line">              other.array()-&gt;lists[i] = a-&gt;lists[i]-&gt;duplicate();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list) &#123;</span><br><span class="line">          other.list = list-&gt;duplicate();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          other.list = <span class="literal">nil</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>attachLists</code>方法是分类原理实现最核心的方法，我这里用一张图来模拟分类的底层原理如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/10.png" alt="10"></p>
<h3 id="模拟场景">模拟场景</h3>
<p>模拟场景：<code>Person</code>类有两个分类：<code>Person+Eat.h</code>和<code>Person+Run.h</code>，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test；</span><br><span class="line">- (<span class="type">void</span>)test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Person + Eat 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Eat</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)eat;</span><br><span class="line">- (<span class="type">void</span>)test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Person + Run 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Run</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run;</span><br><span class="line">- (<span class="type">void</span>)test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>按照上图的分析结果，<code>Person</code>类中<code>class_rw_ext_t</code>中<code>methods</code>结构如下：</p>
<div class="note red no-icon flat"><p><strong>解释</strong>：</p>
<p>1.把Person的方法列表挪动到数组最后</p>
<p>2.把Person的分类方法列表添加到前</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/11.png" alt="11"></p>
</div>
<div class="note orange no-icon flat"><p><strong>提示</strong>：</p>
<p>1、如果主类和分类都会有<code>-(void)test</code>方法，会优先调用分类的方法，原因是分类的方法列表在前面，注意这里不是覆盖了原来的方法。</p>
<p>2、<code>Person</code>两个分类都有<code>-(void)test</code>方法，调用哪个方法是根据<strong>编译顺序</strong>来决定的，后参与编译的优先级更高，比如上例中调用的是<code>Person+Eat</code>中的<code>test</code>方法。</p>
</div>
<h2 id="写在最后-8">写在最后</h2>
<p>啦啦啦，关于<code>Category</code>的底层原理窥探就到这里结束了，如有错误的地方还望各位大佬多多指教。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】KVC详解</title>
    <url>/posts/8583d944/</url>
    <content><![CDATA[<h2 id="KCV的基本使用">KCV的基本使用</h2>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设值</span></span><br><span class="line">- (<span class="type">void</span>)setValue:(<span class="type">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">void</span>)setValue:(<span class="type">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">- (<span class="type">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Student类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Student *student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体使用</span></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">person.student = [[Student alloc] init];</span><br><span class="line">[person setValue:@(<span class="number">10</span>) forKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">[person setValue:<span class="string">@&quot;Sunny&quot;</span> forKeyPath:<span class="string">@&quot;student.name&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;age:%@ name:%@&quot;</span>, [person valueForKey:<span class="string">@&quot;age&quot;</span>], [person valueForKeyPath:<span class="string">@&quot;student.name&quot;</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="KVC的设值原理">KVC的设值原理</h2>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">@public</span></span><br><span class="line">  <span class="type">int</span> _age;</span><br><span class="line">  <span class="type">int</span> _isAge;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">int</span> isAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认返回YES 如果没有找到Setter 会根据_setKey、_key、_isKey、key、isKey顺序去查找 如果返回NO不会按照前面顺序查找。</span></span><br><span class="line">+ (<span class="type">BOOL</span>)accessInstanceVariablesDirectly &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setAge:(<span class="type">int</span>)age &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)_setAge:(<span class="type">int</span>)age &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setValue:(<span class="type">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ViewController类</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">  Person *person = [[Person alloc] init];</span><br><span class="line">  [person setValue:@(<span class="number">10</span>) forKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<div class="note green no-icon flat"><p><strong>解释</strong>：</p>
<p>1、当存在<code>setKey</code>方法时，调用<code>setKey</code>。</p>
<p>2、当<code>setKey</code>方法不存在，存在<code>_setKey</code>方法时，调用<code>_setKey</code>。</p>
<p>3、当<code>setKey</code>和<code>_setKey</code>都不存在时，检查<code>+(BOOL)accessInstanceVariablesDirectly</code>返回值。</p>
<p>4、如果<code>+(BOOL)accessInstanceVariablesDirectly</code>返回NO，调用<code>-(void)setValue:(id)value forUndefinedKey:(NSString *)key</code>，程序结束。</p>
<p>5、如果<code>+(BOOL)accessInstanceVariablesDirectly</code>返回YES，按照<code>_key</code>、<code>_isKey</code>、<code>key</code>、<code>isKey</code>的顺序查找成员变量赋值。</p>
<p>6、如果按照上面的流程都没找到，调用<code>-(void)setValue:(id)value forUndefinedKey:(NSString *)key</code>，程序结束。</p>
</div>
<p>用一张图来总结KVC设值的查找顺序：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1121/1.png" alt="1"></p>
<p><strong>总结</strong>：</p>
<p>按照上面流程都没有查找到对应的方法或成员变量可以赋值就是调用我们常见的一个方法:<code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code>抛出异常。</p>
<p><strong>注意</strong>：</p>
<p>针对KVC赋值，即使没有找到<code>setKey</code>或<code>_setKey</code>，只要找到一个成员变量也是会触发KVO的，KVC本身自己在内部会去通知相应的observer观察者某个属性发生了变化。</p>
<p>其实就是在内部调用了:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>
<h2 id="KVC的取值原理">KVC的取值原理</h2>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">@public</span></span><br><span class="line">  <span class="type">int</span> _age;</span><br><span class="line">  <span class="type">int</span> _isAge;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">int</span> isAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)accessInstanceVariablesDirectly &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)getAge &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)age &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)isAge &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)_age &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// ViewController 类</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">  Person *person = [[Person alloc] init];</span><br><span class="line">  [person valueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<div class="note green no-icon flat"><p><strong>解释</strong>：</p>
<p>1、当存在<code>getKey</code>方法时，调用<code>getKey</code>。</p>
<p>2、当<code>getKey</code>方法不存在，存在<code>key</code>方法时，调用<code>key</code>。</p>
<p>3、当<code>getKey</code>、<code>key</code>方法不存在，存在<code>isKey</code>方法时，调用<code>isKey</code>。</p>
<p>4、当<code>getKey</code>、<code>key</code>、<code>isKey</code> 方法不存在，存在<code>_key</code>方法时，调用<code>_key</code>。</p>
<p>5、当<code>getKey</code>、<code>key</code>、<code>isKey</code> 、<code>_key</code>都不存在时，检查<code>+(BOOL)accessInstanceVariablesDirectly</code>返回值。</p>
<p>6、如果<code>+(BOOL)accessInstanceVariablesDirectly</code>返回NO，调用<code>- (id)valueForUndefinedKey:(NSString *)key</code>，程序结束。</p>
<p>7、如果<code>+(BOOL)accessInstanceVariablesDirectly</code>返回YES，按照<code>_key</code>、<code>_isKey</code>、<code>key</code>、<code>isKey</code>的顺序查找成员变量赋值。</p>
<p>8、如果按照上面的流程都没找到对应的方法或成员变量，调用<code>- (id)valueForUndefinedKey:(NSString *)key</code>，程序结束。</p>
</div>
<p>用一张图来总结KVC取值的查找顺序：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1121/2.png" alt="2"></p>
<p><strong>总结</strong>：</p>
<p>按照上面流程都没有查找到对应的方法或成员变量可以赋值就是调用我们常见的一个方法:<code>- (id)valueForUndefinedKey:(NSString *)key</code>抛出异常。</p>
<h2 id="写在最后-9">写在最后</h2>
<p>关于iOS里面的KVC设值、取值的相关顺序就写到这里了，如有错误请指教。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】KVO详解</title>
    <url>/posts/4223b330/</url>
    <content><![CDATA[<h2 id="KVO的基本使用">KVO的基本使用</h2>
<h3 id="基本使用">基本使用</h3>
<p>KVO：Key Value Observing（键值监听），用来监听某个对象属性值的改变。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// KVOViewController</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KVOViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Person *person1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Person *person2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KVOViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">self</span>.person1 = [[Person alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.person1.age = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">self</span>.person2 = [[Person alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.person2.age = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="literal">NULL</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">self</span>.person1.age = <span class="number">11</span>;</span><br><span class="line">  	<span class="keyword">self</span>.person2.age = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="type">id</span>&gt; *)change context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@对象的%@属性发生了改变：\n%@&quot;</span>,object, keyPath,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-15</span> <span class="number">20</span>:<span class="number">08</span>:<span class="number">33.563589</span>+<span class="number">0800</span> OC对象的本质[<span class="number">81675</span>:<span class="number">15955895</span>] &lt;Person: <span class="number">0x6000007519c0</span>&gt;对象的age属性发生了改变：</span><br><span class="line">&#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="number">11</span>;</span><br><span class="line">    old = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：在不需要监听的时候需要移除。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.person1 removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note green no-icon flat"><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1115/3.png" alt="3"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1115/4.png" alt="4"></p>
<p><strong>解释</strong>：</p>
<p>1、KVO是建立在KVC的基础之上的，即是说给成员变量赋值KVO是无法监听其变化的。</p>
<p>2、context意为上下文信息，我们平时用的时候一般传的<code>NULL</code>，但是苹果官方建议的是把这个参数用起来会更安全、扩展性更强。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1115/5.png" alt="5"></p>
<p><strong>注意</strong>：对于KVC赋值的，不关是否根据KVC找到对应的Setter方法 都可以实现KVO监听。</p>
</div>
<h3 id="KVO其他细节">KVO其他细节</h3>
<h4 id="1、是否打开自动观察的开关">1、是否打开自动观察的开关</h4>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>) automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>; <span class="comment">// 默认是YES</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、返回可能影响监听值的NSSet">2、返回可能影响监听值的NSSet</h4>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当writtenData发生改变的时候，downloadProgress就会发生改变</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">NSSet</span>&lt;<span class="type">NSString</span> *&gt; <span class="operator">*</span>)keyPathsForValuesAffectingValueForKey:(<span class="type">NSString</span> <span class="operator">*</span>)key &#123;</span><br><span class="line">    <span class="type">NSSet</span> <span class="operator">*</span>keyPaths <span class="operator">=</span> [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:@<span class="string">&quot;downloadProgress&quot;</span>]) &#123;</span><br><span class="line">        <span class="type">NSArray</span> <span class="operator">*</span>affectingKeys <span class="operator">=</span> @[@<span class="string">&quot;writtenData&quot;</span>];  <span class="comment">// 只要affectingKeys数组里面的属性发生变化 都会触发downloadProgress的KVO</span></span><br><span class="line">        keyPaths <span class="operator">=</span> [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、对可变数组的监听">3、对可变数组的监听</h4>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.person1.booksArr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">[<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;booksArr&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</span><br><span class="line">[[<span class="keyword">self</span>.person1 mutableArrayValueForKey:<span class="string">@&quot;booksArr&quot;</span>] addObjectsFromArray:@[<span class="string">@&quot;Hello&quot;</span>, <span class="string">@&quot;World&quot;</span>]];</span><br></pre></td></tr></table></figure>
<p>// 打印结果：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1115/6.png" alt="6"></p>
<h2 id="KVO的本质分析">KVO的本质分析</h2>
<p>从上面的例子咱们发现：两个不同的对象<code>person1</code>和<code>person2</code>，为什么<code>person1</code>添加了KVO可以监听到属性值的改变？</p>
<p>看起来<code>self.person1.age = 11</code> 和 <code>self.person2.age = 21</code>都是调用的<code>setAge:</code>方法，为什么<code>person1</code>就可以监听到属性值的改变了呢？我们可以大胆猜测一下<code>person1</code> 和<code>person2</code>的<code>setAge:</code>的具体实现肯定不一样了，也就是说<code>person1</code>的<code>isa</code>和<code>person2</code>的<code>isa</code>指向发生了变化，下面我们来验证一下我们的猜想。</p>
<div class="note green no-icon flat"><p><strong>验证一</strong>：</p>
<p>在<code>person1</code>添加KVO前后分别打印<code>person1</code>和<code>person2</code>的<strong>class对象</strong>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;person1添加监听之前：person1:%@ person2:%@&quot;</span>,object_getClass(<span class="keyword">self</span>.person1),object_getClass(<span class="keyword">self</span>.person2));</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;person1添加监听之后：person1:%@ person2:%@&quot;</span>,object_getClass(<span class="keyword">self</span>.person1),object_getClass(<span class="keyword">self</span>.person2));</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-15</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">21.161924</span>+<span class="number">0800</span> OC对象的本质[<span class="number">81836</span>:<span class="number">15966659</span>] person1添加监听之前：person1:Person person2:Person</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-15</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">21.162217</span>+<span class="number">0800</span> OC对象的本质[<span class="number">81836</span>:<span class="number">15966659</span>] person1添加监听之后：person1:<span class="built_in">NSKVONotifying_Person</span> person2:Person</span><br></pre></td></tr></table></figure>
<p>如上：我们发现在<code>person1</code>添加了KVO之后，<code>person1</code>的<code>isa</code>指向的是<code>NSKVONotifying_Person</code>类，<code>person2</code>的<code>isa</code>指向的还是<code>Person</code>类。</p>
</div>
<div class="note orange no-icon flat"><p><strong>验证二</strong>：</p>
<p>在<code>person1</code>添加KVO前后分别打印<code>person1</code>和<code>person2</code>的<code>setAge:</code>方法的函数地址（IMP）：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;person1添加监听之前：person1:%p person1:%p&quot;</span>,[<span class="keyword">self</span>.person1 methodForSelector:<span class="keyword">@selector</span>(setAge:)], [<span class="keyword">self</span>.person2 methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;person1添加监听之后：person1:%p person1:%p&quot;</span>,[<span class="keyword">self</span>.person1 methodForSelector:<span class="keyword">@selector</span>(setAge:)], [<span class="keyword">self</span>.person2 methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-15</span> <span class="number">20</span>:<span class="number">32</span>:<span class="number">28.980113</span>+<span class="number">0800</span> OC对象的本质[<span class="number">81977</span>:<span class="number">15975768</span>] person1添加监听之前：person1:<span class="number">0x102539e70</span> person1:<span class="number">0x102539e70</span></span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-15</span> <span class="number">20</span>:<span class="number">32</span>:<span class="number">28.980454</span>+<span class="number">0800</span> OC对象的本质[<span class="number">81977</span>:<span class="number">15975768</span>] person1添加监听之后：person1:<span class="number">0x7fff207b1cfb</span> person1:<span class="number">0x102539e70</span></span><br></pre></td></tr></table></figure>
<p>如上：我们发现在<code>person1</code>添加了KVO之后，<code>person1</code>的<code>IMP</code>跟<code>person2</code>的<code>IMP</code>不一样。</p>
<p>通过LLDB指令：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// person1</span></span><br><span class="line">p (IMP) <span class="number">0x7fff207b1cfb</span></span><br><span class="line">(IMP) $<span class="number">0</span> = <span class="number">0x00007fff207b1cfb</span> (Foundation`_NSSetIntValueAndNotify)</span><br><span class="line"></span><br><span class="line"><span class="comment">// person2</span></span><br><span class="line">p (IMP) <span class="number">0x102539e70</span></span><br><span class="line">(IMP) $<span class="number">1</span> = <span class="number">0x0000000102539e70</span> (OC对象的本质`-[Person setAge:] at Person.h:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p>如上：我们发现<code>person1</code>的<code>setAge:</code>方法其实是调用到了一个C函数：<code>_NSSetIntValueAndNotify</code>。</p>
</div>
<p>通过上面的分析：</p>
<p>1、我们看到<code>person1</code>添加了KVO之后，其<code>isa</code> 指针指向的是一个派生类<code>NSKVONotifying_Person</code>，这个类是Runtime在程序运行的过程中动态创建的一个类，这个类继承自<code>Person</code>。</p>
<p>2、在这个派生类里面调用了C函数：<code>_NSSetIntValueAndNotify</code>。</p>
<p>3、在<code>_NSSetIntValueAndNotify</code>里面实现如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">[<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">[<span class="variable language_">super</span> setAge:age];</span><br><span class="line">[<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>4、在<code>didChangeValueForKey</code>方法里面去通知监听器某个属性值发生了改变。</p>
<p><strong>用一张图来做一个总结</strong>：</p>
<p>未添加KVO监听的对象：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1115/1.png" alt="1"></p>
<p>使用KVO添加监听的对象：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1115/2.png" alt="2"></p>
<div class="note green no-icon flat"><p><strong>注意</strong>：</p>
<p>通过<code>Runtime</code>中的<code>object_class</code>拿到的class对象才是真正的class对象，通过<code>class</code>拿到的不一定是真正的class对象，比如使用了KVO监听的对象。</p>
</div>
<p>如何验证派生类<code>NSKVONotifing_Person</code>重写了哪些方法？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">Class cls = object_getClass(<span class="keyword">self</span>.person1);</span><br><span class="line">[<span class="keyword">self</span> printMethodNameOfClass:cls];</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)printMethodNameOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,<span class="built_in">NSStringFromSelector</span>(method_getName(method)));</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-16</span> <span class="number">13</span>:<span class="number">36</span>:<span class="number">32.484809</span>+<span class="number">0800</span> OC对象的本质[<span class="number">26389</span>:<span class="number">16561796</span>] setAge:</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-16</span> <span class="number">13</span>:<span class="number">36</span>:<span class="number">32.484965</span>+<span class="number">0800</span> OC对象的本质[<span class="number">26389</span>:<span class="number">16561796</span>] <span class="keyword">class</span></span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-16</span> <span class="number">13</span>:<span class="number">36</span>:<span class="number">32.485084</span>+<span class="number">0800</span> OC对象的本质[<span class="number">26389</span>:<span class="number">16561796</span>] dealloc</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-16</span> <span class="number">13</span>:<span class="number">36</span>:<span class="number">32.485195</span>+<span class="number">0800</span> OC对象的本质[<span class="number">26389</span>:<span class="number">16561796</span>] _isKVOA</span><br></pre></td></tr></table></figure>
<p>从上面打印可以看到：<code>NSKVONotifinh_Person</code>类重写了<code>setAge:</code>、<code>class</code>、<code>dealloc</code>、<code>_isKVOA</code>方法。</p>
<h2 id="KVO的触发场景">KVO的触发场景</h2>
<p>从上面KVO的本质分析可以看到：只要有<code>setter</code>方法就可以通过KVO来监听值的改变，比如：属性值发生改变、通过KVC赋值。</p>
<p>请看下面场景：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// KVOController</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KVOViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Person *person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KVOViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">  <span class="keyword">self</span>.person = [[Person alloc] init];</span><br><span class="line">  <span class="keyword">self</span>.person-&gt;age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">  [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">  <span class="comment">// 不会触发KVO</span></span><br><span class="line">  <span class="comment">// [self.person willChangeValueForKey:@&quot;age&quot;];</span></span><br><span class="line">  <span class="keyword">self</span>.person-&gt;age = <span class="number">11</span>;</span><br><span class="line">  <span class="comment">// [self.person didChangeValueForKey:@&quot;age&quot;];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="type">id</span>&gt; *)change context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%@对象的%@属性发生了改变：\n%@&quot;</span>,object, keyPath,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">  [<span class="keyword">self</span>.person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上：</p>
<p>通过<code>self.person-&gt;age = 11</code>不会触发KVO，原因相信大家都很清楚了，没有调用<code>setter</code>，可以在<code>self.person-&gt;age = 11</code>前后分别添加<code>[self.person willChangeValueForKey:@&quot;age&quot;]</code>和<code>[self.person didChangeValueForKey:@&quot;age&quot;]</code>来手动触发KVO。</p>
<p>也可以通过KVC赋值<code>[self.person setValue:@11 forKey:@&quot;age&quot;]</code>，这样就可以自动触发KVO。</p>
<h2 id="其他补充">其他补充</h2>
<p>如何查看某个方法的函数地址（IMP）？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (IMP)methodForSelector:(SEL)aSelector;</span><br><span class="line">+ (IMP)instanceMethodForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】On-Demand Resource的简单介绍和使用</title>
    <url>/posts/132ad7d9/</url>
    <content><![CDATA[<h2 id="关于On-Demand-Resource">关于On-Demand Resource</h2>
<p>在之前的文章<a href="https://codersunny.com/posts/94e6df10/">浅谈iOS的包体积优化（一）</a>中我们提到过On-Demand Resource，本文主要来详细介绍一下On-Demand Resource。</p>
<p>iOS9引入了一个新的功能 - On-Demand Resource（ODR），它是App Thinning的一部分，这个功能简单的说就是：在APP下载的时候，APP中包含的不重要的资源可以先不下载，等真正需要用到的时候再去下载，再由系统向苹果的server发送请求，下载这些资源包。</p>
<p>具体见<a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/index.html#//apple_ref/doc/uid/TP40015083-CH2-SW1">苹果官方文档</a></p>
<div class="note green no-icon flat"><p><strong>注意</strong>：</p>
<p>1、 ODR中的资源是在APP打包的时候确定的，不进行版本更新就无法更新这些资源。</p>
<p>2、ODR的资源是存放在苹果Server的，我们不需要再用自己的服务器。</p>
</div>
<h2 id="On-Demand-Resource使用前后安装包变化">On-Demand Resource使用前后安装包变化</h2>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1108/1.png" alt="1"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1108/2.png" alt="2"></p>
<h2 id="使用ODR的优点">使用ODR的优点</h2>
<p>1、可以减小应用的大小，使得下载更快，提升用户体验。</p>
<p>2、一些固定的应用资源懒加载</p>
<p>3、操作系统会在磁盘不够的时候清理ODR</p>
<h2 id="按需加载的资源类型">按需加载的资源类型</h2>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1108/3.png" alt="3"></p>
<h2 id="ODR的使用">ODR的使用</h2>
<h3 id="ODR的三种类型">ODR的三种类型</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1108/6.png" alt="6"></p>
<p><code>initial install Tags</code>：此种类型的资源会随着APP从App Store的下载而下载，会影响ipa的大小，也就是说资源会包含在ipa包内。</p>
<p><code>Prefetched Tag Order</code>：此种类型的资源会在APP下载后开始下载下载相应的资源，下载会有先后顺序，这种不会影响ipa包的大小，也就是说资源不在ipa包内。</p>
<p><code>Download Only On Demand</code>：此种类型的资源会在必须的时候主动触发下载，这是开发者自己控制下载时机的。</p>
<h3 id="如何设置ODR">如何设置ODR</h3>
<h4 id="Build-Settings-Enable-On-Demand-Resources-设置为YES（默认）">Build Settings - Enable On Demand Resources - 设置为YES（默认）</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1108/7.png" alt="7"></p>
<h4 id="为资源添加标签">为资源添加标签</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1108/8.png" alt="8"></p>
<div class="note green no-icon flat"><p><strong>说明</strong>：</p>
<p>1、标签名是可以任意取的</p>
<p>2、一个资源可以打多个标签：比如level1、level2等</p>
</div>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1108/9.png" alt="9"></p>
<p>如上图所示：打完标签后 在<code>Resource Tags</code>中会看到所有我们刚打的标签，比如：level1、level2。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1108/10.png" alt="10"></p>
<div class="note green no-icon flat"><p><strong>说明</strong>：</p>
<p>默认都是在<code>Download Only On Demand</code>类型下，可以自己手动移到想要的类型下面。</p>
</div>
<h3 id="ODR的具体使用">ODR的具体使用</h3>
<h4 id="相关API使用">相关API使用</h4>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line">// <span class="number">1</span>.检查资源是否被下载</span><br><span class="line">conditionallyBeginAccessingResourceWithCompletionHandler</span><br><span class="line"></span><br><span class="line">// <span class="number">2</span>.从APP Server开始下载资源</span><br><span class="line">beginAccessingResourceWithCompletionHandler</span><br></pre></td></tr></table></figure>
<h4 id="具体代码片段">具体代码片段</h4>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</span><br><span class="line">        NSSet *tags = [NSSet setWithObjects:@<span class="string">&quot;level1&quot;</span>, nil];</span><br><span class="line">        self.resourceRequest = [[NSBundleResourceRequest alloc] initWithTags:tags bundle:[NSBundle mainBundle]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查图片资源“home_function_broadcast”是否被下载 如果已经下载就可以直接使用</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">[self.resourceRequest conditionallyBeginAccessingResourcesWithCompletionHandler:^(BOOL resourcesAvailable) &#123;</span><br><span class="line">  <span class="keyword">if</span> (resourcesAvailable) &#123;</span><br><span class="line">      weakSelf.resourcesAvailable = resourcesAvailable;</span><br><span class="line">      dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          weakSelf.imageView.image = [UIImage imageNamed:@<span class="string">&quot;home_function_broadcast&quot;</span>];</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 开始下载图片资源</span><br><span class="line">[self.resourceRequest beginAccessingResourcesWithCompletionHandler:^(NSError * _Nullable <span class="keyword">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">error</span>) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [self showAlertViewVcWithTitle:@<span class="string">&quot;图片资源下载失败...&quot;</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [self showAlertViewVcWithTitle:@<span class="string">&quot;图片资源下载成功...&quot;</span>];</span><br><span class="line">            self.imageView.image = [UIImage imageNamed:@<span class="string">&quot;home_function_broadcast&quot;</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="写在最后-10">写在最后</h2>
<p>关于On-Demand Resource的简单介绍就到这里了，希望本文能对打开有所帮助。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】Runtime中常用的一些API汇总</title>
    <url>/posts/b38791c9/</url>
    <content><![CDATA[<h2 id="写在前面-15">写在前面</h2>
<p>本文主要是总结一下在我们日常项目中会用到的一些关于<code>Runtime</code>的相关API，便于以后查阅。</p>
<h2 id="isMemberOfClass-和-isKindOfClass-区别">isMemberOfClass 和 isKindOfClass 区别</h2>
<p>在正式总结<code>Runtime</code>下相关API之前，先看看<code>isMemberOfClass</code> 和 <code>isKindOfClass</code>的区别：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)isMemberOfClass:(Class)cls;</span><br><span class="line">+ (<span class="type">BOOL</span>)isMemberOfClass:(Class)cls;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)isKindOfClass:(Class)cls;</span><br><span class="line">+ (<span class="type">BOOL</span>)isKindOfClass:(Class)cls;</span><br></pre></td></tr></table></figure>
<p>我们来看一下这几个方法的底层实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>-&gt;ISA() == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="keyword">self</span>-&gt;ISA(); tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例1：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Student *student = [[Student alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1 - %d&quot;</span>,[student isMemberOfClass:[Student <span class="keyword">class</span>]]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;2 - %d&quot;</span>,[student isKindOfClass:[Student <span class="keyword">class</span>]]);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;3 - %d&quot;</span>,[student isMemberOfClass:[Person <span class="keyword">class</span>]]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;4 - %d&quot;</span>,[student isKindOfClass:[Person <span class="keyword">class</span>]]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">21</span>:<span class="number">04.801267</span>+<span class="number">0800</span> SuperDemo[<span class="number">32839</span>:<span class="number">16964367</span>] <span class="number">1</span> - <span class="number">1</span></span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">21</span>:<span class="number">04.801310</span>+<span class="number">0800</span> SuperDemo[<span class="number">32839</span>:<span class="number">16964367</span>] <span class="number">2</span> - <span class="number">1</span></span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">21</span>:<span class="number">04.801347</span>+<span class="number">0800</span> SuperDemo[<span class="number">32839</span>:<span class="number">16964367</span>] <span class="number">3</span> - <span class="number">0</span></span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">21</span>:<span class="number">04.801382</span>+<span class="number">0800</span> SuperDemo[<span class="number">32839</span>:<span class="number">16964367</span>] <span class="number">4</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>例2:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Student *student = [[Student alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1 - %d&quot;</span>,[Student isMemberOfClass:object_getClass([Student <span class="keyword">class</span>])]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;2 - %d&quot;</span>,[Student isKindOfClass:object_getClass([Student <span class="keyword">class</span>])]);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;3 - %d&quot;</span>,[Student isMemberOfClass:object_getClass([Person <span class="keyword">class</span>])]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;4 - %d&quot;</span>,[Student isKindOfClass:object_getClass([Person <span class="keyword">class</span>])]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">18.561752</span>+<span class="number">0800</span> SuperDemo[<span class="number">33188</span>:<span class="number">16979322</span>] <span class="number">1</span> - <span class="number">1</span></span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">18.562298</span>+<span class="number">0800</span> SuperDemo[<span class="number">33188</span>:<span class="number">16979322</span>] <span class="number">2</span> - <span class="number">1</span></span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">18.562390</span>+<span class="number">0800</span> SuperDemo[<span class="number">33188</span>:<span class="number">16979322</span>] <span class="number">3</span> - <span class="number">0</span></span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">18.562430</span>+<span class="number">0800</span> SuperDemo[<span class="number">33188</span>:<span class="number">16979322</span>] <span class="number">4</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<div class="note green no-icon flat"><p><strong>注意</strong>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[Student isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br></pre></td></tr></table></figure>
<p>结果返回的是：YES 因为NSObject的isa指向的是自己。</p>
</div>
<h2 id="Runtime下的一些常用API">Runtime下的一些常用API</h2>
<h3 id="类">类</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态创建一个类（参数：父类，类名，额外的内存空间）</span></span><br><span class="line">Class objc_allocateClassPair(Class  _Nullable __<span class="keyword">unsafe_unretained</span> superclass, <span class="keyword">const</span> <span class="type">char</span> * _Nonnull name, size_t extraBytes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个类（要在类注册之前添加成员变量）</span></span><br><span class="line"><span class="type">void</span>  objc_registerClassPair(Class  _Nonnull __<span class="keyword">unsafe_unretained</span> cls)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 销毁一个类</span></span><br><span class="line"><span class="type">void</span> objc_disposeClassPair(Class  _Nonnull __<span class="keyword">unsafe_unretained</span> cls)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 获取isa指向的Class</span></span><br><span class="line">Class object_getClass(<span class="type">id</span>  _Nullable obj)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 设置isa指向的Class</span></span><br><span class="line">Class object_setClass(<span class="type">id</span>  _Nullable obj, Class  _Nonnull __<span class="keyword">unsafe_unretained</span> cls)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个对象是否为Class</span></span><br><span class="line">object_isClass(<span class="type">id</span>  _Nullable obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个类是否为元类</span></span><br><span class="line">class_isMetaClass(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父类</span></span><br><span class="line">class_getSuperclass(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls)</span><br></pre></td></tr></table></figure>
<h3 id="成员变量">成员变量</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取一个实例变量</span></span><br><span class="line">Ivar class_getInstanceVariable(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, <span class="keyword">const</span> <span class="type">char</span> * _Nonnull name)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 拷贝实例变量列表（最后需要调用free释放）</span></span><br><span class="line">Ivar *class_copyIvarList(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, <span class="type">unsigned</span> <span class="type">int</span> * _Nullable outCount)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 设置和获取成员变量的值</span></span><br><span class="line"><span class="type">void</span> object_setIvar(<span class="type">id</span>  _Nullable obj, Ivar  _Nonnull ivar, <span class="type">id</span>  _Nullable value)</span><br><span class="line"><span class="type">id</span> object_getIvar(<span class="type">id</span>  _Nullable obj, Ivar  _Nonnull ivar)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态添加成员变量（已经注册的类是不能添加成员变量的）</span></span><br><span class="line"><span class="type">BOOL</span>  class_addIvar(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, <span class="keyword">const</span> <span class="type">char</span> * _Nonnull name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="type">char</span> * _Nullable types)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量的相关信息</span></span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> *ivar_getName(Ivar  _Nonnull v)</span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> *ivar_getTypeEncoding(Ivar  _Nonnull v)</span><br></pre></td></tr></table></figure>
<h3 id="方法">方法</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取一个实例方法、类方法</span></span><br><span class="line">Method class_getInstanceMethod(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, SEL  _Nonnull name)</span><br><span class="line">Method class_getClassMethod(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, SEL  _Nonnull name)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 方法实现相关操作</span></span><br><span class="line">IMP class_getMethodImplementation(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, SEL  _Nonnull name)</span><br><span class="line">IMP method_setImplementation(Method  _Nonnull m, IMP  _Nonnull imp)</span><br><span class="line"><span class="type">void</span> method_exchangeImplementations(Method  _Nonnull m1, Method  _Nonnull m2)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 拷贝方法列表（最后需要通过free来释放）</span></span><br><span class="line">Method *class_copyMethodList(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, <span class="type">unsigned</span> <span class="type">int</span> * _Nullable outCount)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态添加方法</span></span><br><span class="line"><span class="type">BOOL</span> class_addMethod(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, SEL  _Nonnull name, IMP  _Nonnull imp, <span class="keyword">const</span> <span class="type">char</span> * _Nullable types)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态替换方法</span></span><br><span class="line">IMP class_replaceMethod(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, SEL  _Nonnull name, IMP  _Nonnull imp, <span class="keyword">const</span> <span class="type">char</span> * _Nullable types)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法的相关信息（带copy的需要调用free去释放）</span></span><br><span class="line">SEL method_getName(Method  _Nonnull m)</span><br><span class="line">IMP method_getImplementation(Method  _Nonnull m)</span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> *method_getTypeEncoding(Method  _Nonnull m)</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> method_getNumberOfArguments(Method  _Nonnull m)</span><br><span class="line"><span class="type">char</span> *method_copyReturnType(Method  _Nonnull m)</span><br><span class="line"><span class="type">char</span> *method_copyArgumentType(Method  _Nonnull m, <span class="type">unsigned</span> <span class="type">int</span> index)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择器相关</span></span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> *sel_getName(SEL  _Nonnull sel)</span><br><span class="line">SEL sel_registerName(<span class="keyword">const</span> <span class="type">char</span> * _Nonnull str)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用block作为方法实现</span></span><br><span class="line">IMP imp_implementationWithBlock(<span class="type">id</span>  _Nonnull block)</span><br><span class="line"><span class="type">id</span> imp_getBlock(IMP  _Nonnull anImp)</span><br><span class="line"><span class="type">BOOL</span> imp_removeBlock(IMP  _Nonnull anImp)</span><br></pre></td></tr></table></figure>
<h2 id="如何拦截按钮的点击事件">如何拦截按钮的点击事件</h2>
<p>hook：可以理解为就是方法交换。</p>
<p>按钮的点击事件 会调用到UIControl的<code>- (void)sendAction:(SEL)action to:(nullable id)target forEvent:(nullable UIEvent *)event</code>这个方法。</p>
<p>拦截按钮的点击我们只需要拦截<code>sendAction</code>即可。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    Method method1 = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(sendAction:to:forEvent:));</span><br><span class="line">    Method method2 = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(ww_sendAction:to:forEvent:));</span><br><span class="line">    method_exchangeImplementations(method1, method2); <span class="comment">// 调用这个方法之后会去清空之前的缓存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)ww_sendAction:(SEL)action to:(<span class="type">id</span>)target forEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:<span class="built_in">UIButton</span>.class]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;我成功hook了按钮...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> ww_sendAction:action to:target forEvent:event]; <span class="comment">// 调用原来的sendAction</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Runtime总结">Runtime总结</h2>
<p>Runtime在实际开发中可能用到的场景：</p>
<ul>
<li>
<p>利用关联对象给分类添加属性</p>
</li>
<li>
<p>遍历某个类的所有成员变量（可以访问私有的成员变量 比如修改UITextField的占位label/ 字典转模型/ 归档解档）</p>
</li>
<li>
<p>交换方法实现（主要是交换系统的方法 利用方法交换做方法找不到导致的崩溃）</p>
<p>…</p>
</li>
</ul>
<h2 id="写在最后-11">写在最后</h2>
<p>关于Runtime中常用的一些常用的API就总结到这里，如有错误请多多指教。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【 iOS重学】class_rw_ext_t结构详解</title>
    <url>/posts/8948fead/</url>
    <content><![CDATA[<h2 id="写在前面-16">写在前面</h2>
<p>在<a href="https://codersunny.com/posts/b55a18a8/">iOS重学之窥探Class的结构</a>这篇文章中，我们分析Class的结构时提到了一个结构<code>class_rw_ext_t</code>，本文主要就这个结构来展开做个详细的分析，以及苹果为什么要这么做。</p>
<h2 id="class-rw-ext-t结构">class_rw_ext_t结构</h2>
<h3 id="简单介绍-2">简单介绍</h3>
<p>在WWDC2020中苹果介绍对类的修改时出现了一个新的结构：<code>class_rw_ext_t</code>，这个结构主要是Runtime在内存上做的一些优化而出现的，在苹果源码objc4_781版本开始出现<code>class_rw_ext_t</code>，大家也可以对照源码来阅读本文。</p>
<h3 id="clean-memory-和-dirty-memory">clean memory 和 dirty memory</h3>
<p>clean memory：加载后不会再发生变化的内存。</p>
<p>dirty memory：指的是在进程运行时会发生更改的内存。</p>
<div class="note red no-icon flat"><p><strong>提示</strong>：</p>
<p>dirty memory会比clean memory更加消耗性能和内存，dirty memory是只要进程在运行，它就必须一直存在，而clean memory可以在内存吃紧的时候移除来节省更多的内存空间，在需要的时候再次从磁盘中进行加载。</p>
</div>
<h3 id="class-rw-t-和-class-ro-t">class_rw_t 和 class_ro_t</h3>
<p>在<code>class_rw_ext_t</code>结构之前，整体Class 结构是：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/1.png" alt="1"></p>
<p>从上面的结构我们可以看到Class结构被拆分为两部分：<code>class_rw_t</code> 和 <code>class_ro_t</code>，这么拆分的原因就是为了保持更多的clean memory，从而节省内存空间，其中<code>class_rw_t</code>是dirty memory，而<code>class_ro_t</code>就是clean memory。</p>
<div class="note red no-icon flat"><p><strong>解释</strong>：</p>
<p>在没有<code>class_rw_ext_t</code>结构之前，当一个类被装载到内存中时就会初始化一个<code>class_rw_t</code>结构，并将<code>class_ro_t</code>结构中<code>Methods</code>、<code>Properties</code>、<code>Protocols</code>数据复制到<code>class_rw_t</code>中，我们上面提到过<code>class_rw_t</code>属于dirty memory，在程序运行的时候这块内存就必须一直存在，但是大概90%的类并不需要对其中的<code>Methods</code>进行修改，所以这部分的内存其实就是属于浪费，于是苹果拆分出来一个新的数据结构：<code>class_rw_ext_t</code>。</p>
</div>
<p>在<code>class_rw_ext_t</code>结构之后，整体Class结构是：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/2.png" alt="2"></p>
<p>从上面的结构图看到：苹果尽可能的减少dirty memory的大小来降低内存开销。他把<code>Methods</code>、<code>Properties</code>、<code>Protocols</code>、<code>Demangled Name</code>拆分到新的结构<code>class_rw_ext_t</code>中，这里的<code>ext</code>可以理解为extension（扩展）。</p>
<div class="note red no-icon flat"><p><strong>解释</strong>：</p>
<p>在有了<code>class_rw_ext_t</code>结构之后，当一个类被装载到内存中时就会初始化一个<code>class_rw_t</code>结构，但是并不会把<code>class_ro_t</code>中的相关数据完全复制到其中，这样就减少了<code>class_rw_t</code>的大小，利用懒加载的机制在确实需要额外的类的信息的时候再去初始化<code>class_rw_ext_t</code>结构来存放这些信息。</p>
</div>
<h3 id="验证内存变化">验证内存变化</h3>
<p>使用命令<code>heap xxx | egrep 'class_rw|COUNT'</code>来查看一些进程中<code>class_rw</code>类的内存情况，博主这里以微信和Xcode为例来看看：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/3.png" alt="3"></p>
<p>从上图看到：</p>
<p>WeChat中一共有6418个<code>class_rw_t</code>类，但是真的需要额外扩展<code>class_rw_ext_t</code>的只有474个，这个比例大概是7%，我们大概计算一下节省的内存：(6418 - 474) * 48 = 285312(B)。</p>
<p>Xcode中一共有15674个<code>class_rw_t</code>类，但是真的需要额外扩展<code>class_rw_ext_t</code>的只有2375个,这个比例大概是15%，节省的内存：（15674 - 2375） * 48 = 638352(B)。</p>
<p>对dirty memory而言，这是真正节省的内存，所以这个优化还是很可观的。</p>
<h3 id="查找方法的变化">查找方法的变化</h3>
<p>在<code>class_rw_ext_t</code>结构之前，runtime是直接遍历<code>class_rw_t</code>中的方法列表来查找方法，具体如下图：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/4.png" alt="4"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/5.png" alt="5"></p>
<p>在<code>class_rw_ext_t</code>结构之后，runtime查找方法的方式如下图：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/6.png" alt="6"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/7.png" alt="7"></p>
<h2 id="写在最后-12">写在最后</h2>
<p>关于<code>class_rw_ext_t</code>结构的分析和好处我们就分析到这里了，如果有什么不对的地方望指教。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】一篇文章讲清楚+load和+initialize</title>
    <url>/posts/8f7262c3/</url>
    <content><![CDATA[<h2 id="写在前面-17">写在前面</h2>
<p>本文主要从底层源码上来分析一下<code>+load</code>和<code>+initialize</code>方法的调用顺序以及它们之间的区别。</p>
<h2 id="load">+load</h2>
<p><code>+load</code>方法会在<code>Runtime</code>加载类、分类的时候调用，每个类、分类的<code>+load</code>方法在程序运行过程中只会调用一次。</p>
<h3 id="load的基本使用">+load的基本使用</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Person + Test1 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person + Test2 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student 类 继承自Person</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student + Test1 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student + Test2 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面场景，<code>+load</code>方法的打印顺序为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">34.392232</span>+<span class="number">0800</span> CategoryDemo[<span class="number">88835</span>:<span class="number">2251283</span>] +[Person load]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">34.392867</span>+<span class="number">0800</span> CategoryDemo[<span class="number">88835</span>:<span class="number">2251283</span>] +[Student load]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">34.392964</span>+<span class="number">0800</span> CategoryDemo[<span class="number">88835</span>:<span class="number">2251283</span>] +[Animal load]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">34.393013</span>+<span class="number">0800</span> CategoryDemo[<span class="number">88835</span>:<span class="number">2251283</span>] +[Student(Test1) load]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">34.393056</span>+<span class="number">0800</span> CategoryDemo[<span class="number">88835</span>:<span class="number">2251283</span>] +[Person(Test1) load]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">34.393107</span>+<span class="number">0800</span> CategoryDemo[<span class="number">88835</span>:<span class="number">2251283</span>] +[Student(Test2) load]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">34.393151</span>+<span class="number">0800</span> CategoryDemo[<span class="number">88835</span>:<span class="number">2251283</span>] +[Person(Test2) load]</span><br></pre></td></tr></table></figure>
<p>那么，它们之间究竟是什么样的一个加载顺序呢？</p>
<h3 id="load的底层源码">+load的底层源码</h3>
<p><code>+load</code>方法的源码查看顺序：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-os文件</span></span><br><span class="line"><span class="number">1.</span> _objc_init</span><br><span class="line"><span class="number">2.</span> load_images</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-runtime-new文件</span></span><br><span class="line"><span class="number">3.</span> prepare_load_methods</span><br><span class="line">  <span class="number">3.1</span> schedule_class_load</span><br><span class="line">  <span class="number">3.2</span> add_category_to_loadable_list</span><br><span class="line"><span class="number">4.</span> call_load_methods</span><br><span class="line">  <span class="number">4.1</span> call_class_loads - (*load_method)(cls, <span class="keyword">@selector</span>(load))</span><br><span class="line">  <span class="number">4.2</span> call_category_loads</span><br></pre></td></tr></table></figure>
<p>在<a href="https://codersunny.com/posts/dfd029e5/">【iOS重学】Category的底层原理</a>中博主提到<code>Runtime</code>入口就是：<code>objc-os</code>文件中的<code>_objc_init</code>方法，我们就从这里入手分析一下底层源码。</p>
<p><code>prepare_load_methods</code>方法源码如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1128/1.png" alt="1"></p>
<div class="note green no-icon flat"><p><strong>解释</strong>：</p>
<p>1、先按照编译顺序将所有的类<code>add_class_to_loadable_list</code>装载到<code>loadable_classes</code>的数组中。</p>
<p>2、再按照编译顺序将所有的分类<code>add_class_to_loadable_list</code>装载到<code>loadable_classes</code>的数组中。</p>
</div>
<p><code>schedule_class_load</code>方法源码如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1128/2.png" alt="2"></p>
<div class="note green no-icon flat"><p><strong>解释</strong>：</p>
<p>在装载类到<code>loadable_classes</code>数组中时，如果存在父类，先将父类装载到<code>loadable_classes</code>中，再将类加载到数组中。</p>
</div>
<p><code>call_load_methods</code>方法源码如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1128/3.png" alt="3"></p>
<div class="note green no-icon flat"><p><strong>解释</strong>：</p>
<p>在调用<code>+load</code>方法时，先调用类的<code>+load</code>方法再调用分类的<code>+load</code>方法。</p>
</div>
<h3 id="load的调用顺序总结">+load的调用顺序总结</h3>
<div class="note green no-icon flat"><p>1、先调用类的<code>+load</code></p>
<p>​	1.1 按照编译顺序进行调用（先编译 -&gt; 先调用）</p>
<p>​	1.2 调用子类<code>+load</code>之前会先调用父类的<code>+load</code></p>
<p>2、再调用分类的<code>+load</code></p>
<p>​	2.1 按照编译顺序进行调用（先编译 -&gt; 先调用）</p>
<p><strong>注意</strong>：<code>+load</code>只会调用一次，比如<code>Student</code>在<code>Person</code>之前编译，会先调用<code>Person</code>的<code>+load</code>方法，表示<code>Person</code>已经被装载进内存了，所以<code>+load</code>不会被调用多次。</p>
</div>
<h3 id="load的调用方式">+load的调用方式</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1128/4.png" alt="4"></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> loadable_class &#123;</span><br><span class="line">    Class cls;  <span class="comment">// may be nil</span></span><br><span class="line">    IMP method; <span class="comment">// 这个method 就是+load的IMP 这个loadable_class就是用来加载类的结构体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上图<code>call_class_loads</code>方法所示，<code>+load</code>方法的调用方式是：直接根据<code>+load</code>方法的函数地址直接去调用。</p>
<h2 id="initialize">+initialize</h2>
<p><code>+initialize</code>方法会在类第一次接收到消息的时候调用。</p>
<h3 id="initialize的基本使用">+initialize的基本使用</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Person + Test1 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person + Test2 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student 类 继承自Person</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student + Test1 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student + Test2 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面场景，<code>+initialize</code>方法的打印顺序为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">10.526685</span>+<span class="number">0800</span> CategoryDemo[<span class="number">57742</span>:<span class="number">2613672</span>] +[Person(Test2) initialize]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">10.527249</span>+<span class="number">0800</span> CategoryDemo[<span class="number">57742</span>:<span class="number">2613672</span>] +[Student(Test2) initialize]</span><br></pre></td></tr></table></figure>
<h3 id="initialize的底层源码">+initialize的底层源码</h3>
<p><code>+initialize</code>方法源码的查看顺序：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm文件</span></span><br><span class="line"><span class="number">1.</span> class_getInstanceMethod</span><br><span class="line"><span class="number">2.</span> lookUpImpOrForward</span><br><span class="line"><span class="number">3.</span> realizeAndInitializeIfNeeded_locked</span><br><span class="line"><span class="number">4.</span> initializeAndLeaveLocked</span><br><span class="line"><span class="number">5.</span> initializeAndMaybeRelock</span><br><span class="line"><span class="number">6.</span> initializeNonMetaClass</span><br><span class="line"><span class="number">7.</span> callInitialize</span><br></pre></td></tr></table></figure>
<p><code>initializeNonMetaClass</code>方法源码如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1128/5.png" alt="5"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1128/6.png" alt="6"></p>
<div class="note green no-icon flat"><p><strong>解释</strong>：</p>
<p>从上面的源码我们大概可以看到：在调用<code>callInitialize</code>方法之前会去检查是否存在父类和父类是否被初始化，会先去调用父类的<code>+initialize</code>方法。</p>
</div>
<h3 id="initialize的调用顺序总结">+initialize的调用顺序总结</h3>
<div class="note green no-icon flat"><p>先调用父类的<code>+initialize</code>，再调用子类的<code>+initialize</code>。</p>
<p><strong>注意</strong>：</p>
<p>1、先初始化父类再初始化子类，每个类只会被初始化一次，但是可能会被调用多次。</p>
<p>比如下面场景：</p>
<p>1.<code>Student</code>没有实现<code>+initialize</code>方法，调用<code> [Person alloc]</code> <code> [Student alloc]</code>会调用两次<code>Person</code> 的<code>+initialize</code>方法。</p>
<p>打印结果如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">01</span>:<span class="number">47.579047</span>+<span class="number">0800</span> CategoryDemo[<span class="number">57804</span>:<span class="number">2615728</span>] +[Person(Test2) initialize]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">01</span>:<span class="number">47.579702</span>+<span class="number">0800</span> CategoryDemo[<span class="number">57804</span>:<span class="number">2615728</span>] +[Person(Test2) initialize]</span><br></pre></td></tr></table></figure>
<p>2.<code>Student</code>实现了<code>+initialize</code>方法，<code>Person</code>调用过了<code>+initialize</code>，那么就不会再调用了。</p>
</div>
<h3 id="initialize调用方式">+initialize调用方式</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((<span class="type">void</span>(*)(Class, SEL))objc_msgSend)(cls, <span class="keyword">@selector</span>(initialize));</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上图<code>callInitialize</code>方法所示，<code>+initialize</code>方法的调用方式是：<code>obj_msgSend</code>。</p>
<h2 id="load和-initialize对比">+load和+initialize对比</h2>
<p>1、调用时机：</p>
<p><code>+load</code>是在<code>Runtime</code>加载类、分类的时候调用（只会调用一次），在<code>main</code>函数之前。</p>
<p><code>+initialize</code>是在类第一次接收到消息的时候调用，只会初始化一次（父类的<code>+initialize</code>可能会被调用多次），在<code>main</code>函数之后。</p>
<p>2、调用方式：</p>
<p><code>+load</code>是根据函数地址直接调用。</p>
<p><code>+initialize</code>是通过<code>objc_msgSend</code>调用。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】一篇文章讲清楚super</title>
    <url>/posts/d1a1e187/</url>
    <content><![CDATA[<h2 id="写在前面-18">写在前面</h2>
<p>经常在网上看到<code>[super xxx]</code>这种输出什么内容等类似的面试题，本文就主要来详细剖析一下这种<code>[super xxx]</code>中<code>super</code>调用的底层原理。</p>
<h2 id="场景">场景</h2>
<p>博主这里用一个常看到的面试题来引出本文的主题：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        [<span class="variable language_">super</span> <span class="keyword">class</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1 - %@&quot;</span>,[<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;2 - %@&quot;</span>,[<span class="variable language_">super</span> <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;3 - %@&quot;</span>,[<span class="keyword">self</span> superclass]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;4 - %@&quot;</span>,[<span class="variable language_">super</span> superclass]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-30</span> <span class="number">16</span>:<span class="number">10</span>:<span class="number">51.753257</span>+<span class="number">0800</span> SuperDemo[<span class="number">27224</span>:<span class="number">16387952</span>] <span class="number">1</span> - Student</span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-30</span> <span class="number">16</span>:<span class="number">10</span>:<span class="number">51.754489</span>+<span class="number">0800</span> SuperDemo[<span class="number">27224</span>:<span class="number">16387952</span>] <span class="number">2</span> - Student</span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-30</span> <span class="number">16</span>:<span class="number">10</span>:<span class="number">51.754682</span>+<span class="number">0800</span> SuperDemo[<span class="number">27224</span>:<span class="number">16387952</span>] <span class="number">3</span> - Person</span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-30</span> <span class="number">16</span>:<span class="number">10</span>:<span class="number">51.754821</span>+<span class="number">0800</span> SuperDemo[<span class="number">27224</span>:<span class="number">16387952</span>] <span class="number">4</span> - Person</span><br></pre></td></tr></table></figure>
<p>结果分析：</p>
<div class="note green no-icon flat"><p><code>[super class]</code> 和 <code>[self superclass]</code>打印结果分别为<code>Student</code> 和 <code>Person</code>毫无疑问。</p>
<p>可能大家比较好奇为什么<code>[super class]</code> 和 <code>[super superclass]</code> 的打印结果依然是<code>Student</code> 和 <code>Person</code>。</p>
</div>
<p>我们这里以<code>[super class]</code>为例来看其底层结构：</p>
<p>用命令<code> xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-10.0.0 Student.m</code>将Student.m文件转化为c++文件，<code>[super class]</code>底层如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">((<span class="built_in">Class</span> (*)(__rw_objc_super *, SEL))(<span class="type">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)<span class="built_in">class_getSuperclass</span>(<span class="built_in">objc_getClass</span>(<span class="string">&quot;Student&quot;</span>))&#125;, <span class="built_in">sel_registerName</span>(<span class="string">&quot;class&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>简化之后为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">objc_msgSendSuper</span>(__rw_objc_super&#123;</span><br><span class="line">			self,</span><br><span class="line">			<span class="built_in">class_getSuperclass</span>(<span class="built_in">objc_getClass</span>(<span class="string">&quot;Student&quot;</span>))</span><br><span class="line">&#125;,<span class="built_in">sel_registerName</span>(<span class="string">&quot;class&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>为了让大家更方便理解，最终结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__rw_objc_super</span> arg = &#123;</span><br><span class="line">			self,</span><br><span class="line">			<span class="built_in">class_getSuperclass</span>(<span class="built_in">objc_getClass</span>(<span class="string">&quot;Student&quot;</span>))</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">objc_msgSendSuper</span>(arg,<span class="built_in">sel_registerName</span>(<span class="string">&quot;class&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>在源码中我们搜索一下<code>objc_super</code>结构体：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/30/1.png" alt="1"></p>
<p>从上面的分析，我们可以看到：<code>[super class]</code>中消息接收者还是<code>self</code>也就是说还是<code>Student</code>，同理<code>[super superclas]</code>打印结果还是<code>Person</code>。</p>
<h2 id="写在最后-13">写在最后</h2>
<p>关于<code>super</code>调用本质的原理我们在这片文章就分析清楚了，如有错误请多多指教。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】从LCS到IGListKit框架中的Diff算法（上）</title>
    <url>/posts/da46549b/</url>
    <content><![CDATA[<h2 id="什么是LCS">什么是LCS</h2>
<h3 id="子序列">子序列</h3>
<p>假设有两个序列 <em>X, Z</em>：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo>&lt;</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>m</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">X = &lt;x_1,x_2,x_3,......x_m&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">......</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mo>&lt;</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>n</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">Y = &lt;y_1,y_2,y_3,......y_n&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">......</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p>若 <em>Z</em> 序列中的每个元素都能在 <em>X</em> 中找到，并且是<strong>严格递增</strong>的，那么就称 <em>Z</em> 是 <em>X</em> 的子序列。</p>
<h3 id="公共子序列">公共子序列</h3>
<p><em>Z</em> 既是 <em>X</em> 的子序列， 也是 <em>Y</em> 的子序列，则称 <em>X，Y</em> 的<strong>公共子序列</strong>是 <em>Z</em>，公共子序列长度为元素的个数。</p>
<h3 id="最长公共子序列">最长公共子序列</h3>
<p>最长公共子序列（<em>Longest Common SubSequence</em>），简称 <em>LCS</em>，指的是两个序列中元素个数<strong>最多</strong>的公共子序列。</p>
<h2 id="LCS的广泛应用"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span>的广泛应用</h2>
<p><em>LCS</em> 是一个经典的计算机科学问题，也是数据比较程序，LCS主要应用在：</p>
<ul>
<li>Git等版本控制中文件的对比</li>
<li>一些做图片、文件、文本等对比的软件</li>
<li>IGListKit框架中的Diff算法来做UICollectionView的刷新</li>
</ul>
<h2 id="如何求两个序列的LCS">如何求两个序列的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span></h2>
<p>给定两个序列：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo>&lt;</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>m</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">X = &lt;x_1,x_2,x_3,......x_m&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">......</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mo>&lt;</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>n</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">Y = &lt;y_1,y_2,y_3,......y_n&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">......</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p>求 <em>X，Y</em> 的最长公共子序列。</p>
<h3 id="蛮力算法">蛮力算法</h3>
<p>依次检查 <em>X</em> 中的每个子序列在 <em>Y</em> 中是否出现。</p>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msup><mn>2</mn><mi>m</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n2^m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<blockquote>
<p><strong>分析</strong>：这个时间复杂度是一个指数级，很明显这个算法是不合适的。</p>
</blockquote>
<h3 id="动态规划算法">动态规划算法</h3>
<p><strong>一</strong>、子问题界定</p>
<p>假设 <em>X</em> 序列终止位置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> ，<em>Y</em> 序列终止位置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> ：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo>&lt;</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>i</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">X = &lt;x_1,x_2,x_3,......x_i&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">......</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mo>&lt;</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">Y = &lt;y_1,y_2,y_3,......y_j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">......</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p>如图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220609/2022060901.png" alt="2022060901"></p>
<p><strong>二</strong>、子问题之间的依赖关系</p>
<p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo>&lt;</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>m</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">X = &lt;x_1,x_2,x_3,......x_m&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">......</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mo>&lt;</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>n</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">Y = &lt;y_1,y_2,y_3,......y_n&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">......</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>=</mo><mo>&lt;</mo><msub><mi>z</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>z</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>z</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>z</mi><mi>k</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">Z = &lt;z_1,z_2,z_3,......z_k&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">......</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span> 为 <em>X</em> 和 <em>Y</em> 的 <em>LCS</em>，那么：</p>
<p>（一）如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>m</mi></msub><mo>=</mo><msub><mi>y</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_m = y_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> =&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>k</mi></msub><mo>=</mo><msub><mi>x</mi><mi>m</mi></msub><mo>=</mo><msub><mi>y</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">z_k = x_m = y_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">Z_{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">X_{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">Y_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>的 <em>LCS</em>，如下图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220609/2022060902.png" alt="2022060902"></p>
<p>（二）如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>m</mi></msub><mo mathvariant="normal">≠</mo><msub><mi>y</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_m \neq y_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>k</mi></msub><mo mathvariant="normal">≠</mo><msub><mi>x</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">z_k \neq x_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> =&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">X_{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Y_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span>，如下图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220609/2022060903.png" alt="2022060903"></p>
<p>（三）如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>m</mi></msub><mo mathvariant="normal">≠</mo><msub><mi>y</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_m \neq y_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>k</mi></msub><mo mathvariant="normal">≠</mo><msub><mi>y</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">z_k \neq y_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> =&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">X_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">Y_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span>，如下图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220609/2022060904.png" alt="2022060904"></p>
<p><strong>三</strong>、递推方程</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的子序列：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>=</mo><mo>&lt;</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>i</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">X_i = &lt;x_1,x_2,x_3,......x_i&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">......</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>j</mi></msub><mo>=</mo><mo>&lt;</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">Y_j = &lt;y_1,y_2,y_3,......y_j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">......</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>P</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">DP[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">Y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span> 的长度，由此我们可以得到递推方程为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mi>P</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若</mtext><mi>i</mi><mo>=</mo><mn>0</mn><mtext>或</mtext><mi>j</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>D</mi><mi>P</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若</mtext><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><msub><mi>y</mi><mi>j</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mi>D</mi><mi>P</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>D</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若</mtext><mi>x</mi><mo separator="true">,</mo><mi>j</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo mathvariant="normal">≠</mo><msub><mi>y</mi><mi>j</mi></msub></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">DP[i,j] =
\begin{cases}
0,&amp;若i = 0 或 j = 0\\
DP[i-1,j-1]+1, &amp;若i,j &gt; 0,x_i = y_j\\
max\{DP[i,j-1],Dp[i-1,j]\}, &amp;若 x,j = 0, x_i \ne y_j
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]}</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">若</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span><span class="mord cjk_fallback">或</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">若</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord cjk_fallback">若</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h2 id="求解LCS的具体实例">求解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span>的具体实例</h2>
<p><strong>例1</strong>：两个序列</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>D</mi><mo separator="true">,</mo><mi>F</mi><mo separator="true">,</mo><mi>G</mi><mo separator="true">,</mo><mi>T</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">X = &lt;A,D,F,G,T&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>F</mi><mo separator="true">,</mo><mi>O</mi><mo separator="true">,</mo><mi>X</mi><mo separator="true">,</mo><mi>T</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">Y = &lt;A,F,O,X,T&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p>求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220609/2022060905.png" alt="2022060905"></p>
<p>可以得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span> 为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>F</mi><mo separator="true">,</mo><mi>T</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;A,F,T&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>， 长度为3。</p>
<p>具体求解算法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text1.length(), n = text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j]);</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>大家要有兴趣，也可以上<a href="https://leetcode.cn/">LeetCode</a>上找到这个求解 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span> 的算法题练习大家的算法。</p>
<h2 id="从LCS-到Diff">从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span> 到Diff</h2>
<p>如果我们仔细观察会从上图中得到一个特别有意思的地方，现在我们假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>D</mi><mo separator="true">,</mo><mi>F</mi><mo separator="true">,</mo><mi>G</mi><mo separator="true">,</mo><mi>T</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">X = &lt;A,D,F,G,T&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span> 为旧数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>F</mi><mo separator="true">,</mo><mi>O</mi><mo separator="true">,</mo><mi>X</mi><mo separator="true">,</mo><mi>T</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">Y = &lt;A,F,O,X,T&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span> 为新数据，再结合上图用<strong>蓝色箭头</strong>标记出来的路线图从<strong>右下角</strong>开始观察会发现：</p>
<ul>
<li>从<label style="color:green">左上角</label>走的单元里的元素是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 都存在的元素，那么旧数据里的这个元素会通过Move或Reload变成新数据的元素。</li>
<li>从<label style="color:green">左边</label>走的单元里的元素表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 里面没有，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>里面有的元素，那么就会通过Insert操作将元素插入新数据里面。</li>
<li>从<label style="color:green">上边</label>走的单元里的元素表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>里面有，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>里面没有的元素，那么就会通过Delete操作将元素从旧数据里面删除。</li>
</ul>
<p>最后，我们就可以得到旧数据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 变成新数据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的所有元素的操作如下：</p>
<ul>
<li><strong>Reload</strong>：A、T</li>
<li><strong>Insert</strong>：O、X</li>
<li><strong>Delete</strong>：D、G</li>
<li><strong>Move</strong>：F</li>
</ul>
<h2 id="LCS-存在的问题"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span> 存在的问题</h2>
<p>我们接下来再来简单的看一个例子：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>D</mi><mo separator="true">,</mo><mi>F</mi><mo separator="true">,</mo><mi>G</mi><mo separator="true">,</mo><mi>T</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">X = &lt;A,D,F,G,T&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>T</mi><mo separator="true">,</mo><mi>O</mi><mo separator="true">,</mo><mi>X</mi><mo separator="true">,</mo><mi>F</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">Y = &lt;A,T,O,X,F&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p>求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220609/2022060906.png" alt="2022060906"></p>
<p>可以得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span> 为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>F</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;A,F&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>T</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;A,T&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span> ，长度为2。</p>
<p>通过上面的分析，我们发现元素的操作如下：</p>
<ul>
<li><strong>Reload</strong>：A</li>
<li><strong>Insert</strong>：T、O、X</li>
<li><strong>Delete</strong>：D、G、T</li>
<li><strong>Move</strong>：F</li>
</ul>
<p>我们会发现<strong>元素T</strong>既进行了Delete操作也进行了Insert操作，但是却没有Move操作，我们会发现：当两个序列存在多个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span> 的时候，只会取其中的一组，其他的只能进行Delete或Insert操作。</p>
<p><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span> 存在的问题：</strong></p>
<ul>
<li>虽然通过动态规划的算法将时间复杂度降低到了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，但是当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>特别大的时候，这个时间复杂度依然比较可怕。</li>
<li>希望对新、旧数据都存在的元素的Move进行一些优化，而不是简单的Delete、Insert操作。</li>
</ul>
<h2 id="最后-7">最后</h2>
<p>问题我们已经抛出来了，我们如何解决上面的两个问题，在降低时间复杂度的同时对Move操作进行一些优化，下一篇我们将谈到iOS中IGListKit框架中的Diff是如何巧妙解决这两个问题的。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>LCS</tag>
        <tag>IGListKit</tag>
        <tag>Diff</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】从LCS到IGListKit框架中的Diff算法（下）</title>
    <url>/posts/62fa33fe/</url>
    <content><![CDATA[<h2 id="写在前面-19">写在前面</h2>
<p>在上一篇文章<a href="https://codersunny.com/%E4%BB%8ELCS%E5%88%B0IGListKit%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84Diff%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/">从LCS到IGListKit框架中的Diff算法（上）</a>中我们详细讲了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span> 是什么、怎么使用动态规划来求解 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span> ，最后我们也抛出了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span> 还存在的两个问题，本篇文章我们就主要来分析IGListKit框架中的Diff是如何来解决这两个问题的。</p>
<blockquote>
<p><strong>温馨提示</strong>：本文主要剖析IGListKit框架中的Diff算法，不会讲IGListKit框架的具体使用。</p>
</blockquote>
<h2 id="LCS-存在的问题带来的思考"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span> 存在的问题带来的思考</h2>
<p>上一篇文章我们提出了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span> 存在的两个问题：</p>
<ul>
<li>但是当n特别大的时候，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 这个时间复杂度依然比较可怕。</li>
<li>希望对新、旧数据都存在的元素的Move进行一些优化，而不是简单的Delete、Insert操作。</li>
</ul>
<p>Instagram团队的IGListKit框架结合Paul Heckel’s Diff（1978年）的<a href="https://dl.acm.org/doi/10.1145/359460.359467">一篇论文</a>做了进一步的优化，使用一些额外的内存空间，把时间复杂度降低到了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，并且能够准确获取数据元素的Move/Insert等操作。</p>
<p>这里，我们还以上一篇文章的两个序列为例：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>D</mi><mo separator="true">,</mo><mi>F</mi><mo separator="true">,</mo><mi>G</mi><mo separator="true">,</mo><mi>T</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">X = &lt;A,D,F,G,T&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>T</mi><mo separator="true">,</mo><mi>O</mi><mo separator="true">,</mo><mi>X</mi><mo separator="true">,</mo><mi>F</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">Y = &lt;A,T,O,X,F&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p>求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">LCS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span></span></span></span></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/2022060906.png" alt="2022060906"></p>
<p>我们首先需要处理的是避免使用二维数组，我们结合上图会发现重要的只是我们标记的这条线路，其他位置我们并没有用到，那么需要走一遍的距离就是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mi>L</mi><mi>C</mi><mi>S</mi><mtext>的长度</mtext></mrow><annotation encoding="application/x-tex">m + n - LCS的长度</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">CS</span><span class="mord cjk_fallback">的长度</span></span></span></span></p>
<p>所以，肯定要走过所有去重之后的元素，仔细思考一下，对于每个元素，我们需要的是什么？</p>
<p><label style="color:green">我们需要的是元素在新数据和旧数据里面的位置。</label></p>
<h2 id="IGListKit框架的刷新流程">IGListKit框架的刷新流程</h2>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220610/2022061001.png" alt="2022061001"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220610/2022061002.png" alt="2022061002"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220610/2022061003.png" alt="2022061003"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220610/2022061004.png" alt="2022061004"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220610/2022061005.png" alt="2022061005"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220610/2022061006.png" alt="2022061006"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220610/2022061007.png" alt="2022061007"></p>
<p>到这里，我们已经跟踪到IGListKit框架刷新机制的核心部分：<strong>IGListDiff类中的IGListDiffing函数</strong>，接下来就是本文的重点了：IGListDiff是如何实现的？</p>
<h2 id="IGListDiff算法详解">IGListDiff算法详解</h2>
<p>在理解Diff算法之前我们先来熟悉几个数据结构、函数体：<code>IGListIndexSetResult</code>、<code>IGListEntry</code>、<code>IGListRecord</code>、<code>IGListDiffable</code>、<code>IGListMoveIndex</code>。</p>
<h3 id="IGListMoveIndex">IGListMoveIndex</h3>
<p><code>IGListMoveIndex</code> 封装的是一个移动的操作，<code>from</code>是旧数组的索引，<code>to</code>是新数组的索引：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IGListMoveIndex</span> : <span class="title">NSObject</span></span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 旧数组的索引</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> from;</span><br><span class="line"><span class="comment">// 新数组的索引</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> to;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="IGListIndexSetResult">IGListIndexSetResult</h3>
<p><code>IGListIndexSetResult</code>封装的是一个关于插入、删除等操作的集合：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IGListIndexSetResult</span> : <span class="title">NSObject</span></span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 插入索引的集合（新数组的索引）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSIndexSet</span> *inserts;</span><br><span class="line"><span class="comment">// 删除索引的集合（旧数组的索引）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSIndexSet</span> *deletes;</span><br><span class="line"><span class="comment">// 更新索引的集合（旧数组的索引）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSIndexSet</span> *updates;</span><br><span class="line"><span class="comment">// 移动索引的集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;IGListMoveIndex *&gt; *moves;</span><br><span class="line"><span class="comment">// 是否发生改变</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> hasChanges;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="IGListDiffable">IGListDiffable</h3>
<p><code>IGListDiffable</code>是一个协议，要求数组里的对象都需要遵循这个协议才能有效地使用<code>diff</code>函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">IGListDiffable</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回对象唯一id，在diff算法中以它作为元素存入哈希表的key</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt;)diffIdentifier;</span><br><span class="line"><span class="comment">// 判断两个对象是否相等，在diff算法用这个方法判断两个对象是否是同一个对象</span></span><br><span class="line">- (<span class="type">BOOL</span>)isEqualToDiffableObject:(<span class="keyword">nullable</span> <span class="type">id</span>&lt;IGListDiffable&gt;)object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="IGListEntry">IGListEntry</h3>
<p><code>IGListEntry</code>是用于标记元素状态的结构体：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> IGListEntry &#123;</span><br><span class="line">    <span class="comment">// 该元素在旧数组中出现的次数</span></span><br><span class="line">    <span class="built_in">NSInteger</span> oldCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 该元素在新数组中出现的次数</span></span><br><span class="line">    <span class="built_in">NSInteger</span> newCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 存放元素在旧数组中的索引，在算法中，可以保证栈顶是较小的索引</span></span><br><span class="line">    stack&lt;<span class="built_in">NSInteger</span>&gt; oldIndexes;</span><br><span class="line">    <span class="comment">// 这个元素是否需要更新</span></span><br><span class="line">    <span class="type">BOOL</span> updated = <span class="literal">NO</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="IGListRecord">IGListRecord</h3>
<p><code>ICListRecord</code>是封装<code>entry</code>结构体和它所在的索引，主要用于插入和删除（如果<code>index</code>有值，则代表该元素需要插入或者更新，否则为<code>NSNotFound</code>，则是需要删除）</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> IGListRecord &#123;</span><br><span class="line">    IGListEntry *entry;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">NSInteger</span> index;</span><br><span class="line">    IGListRecord() &#123;</span><br><span class="line">        entry = <span class="literal">NULL</span>;</span><br><span class="line">        index = <span class="built_in">NSNotFound</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="IGListDiffing函数的算法流程">IGListDiffing函数的算法流程</h3>
<p><strong>变量的声明</strong>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">NSInteger</span> newCount = newArray.count;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">NSInteger</span> oldCount = oldArray.count;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMapTable</span> *oldMap = [<span class="built_in">NSMapTable</span> strongToStrongObjectsMapTable];</span><br><span class="line"><span class="built_in">NSMapTable</span> *newMap = [<span class="built_in">NSMapTable</span> strongToStrongObjectsMapTable];</span><br></pre></td></tr></table></figure>
<p><strong>处理特殊情况</strong>:</p>
<p>如果<code>newcount == 0</code> 或 <code>oldcount == 0</code>，即是删除所有旧元素或新增所有新元素，直接返回<code>IGListIndexSetResult</code>集合，不需要走下面的<code>diff</code>算法流程。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newCount == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [[IGListIndexSetResult alloc] initWithInserts:[<span class="built_in">NSIndexSet</span> new]</span><br><span class="line">                                               deletes:[<span class="built_in">NSIndexSet</span> indexSetWithIndexesInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, oldCount)]</span><br><span class="line">                                               updates:[<span class="built_in">NSIndexSet</span> new]</span><br><span class="line">                                                           moves:[<span class="built_in">NSArray</span> new]</span><br><span class="line">                                           oldIndexMap:oldMap</span><br><span class="line">                                           newIndexMap:newMap];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldCount == <span class="number">0</span>) &#123;</span><br><span class="line">  [newArray enumerateObjectsUsingBlock:^(<span class="type">id</span>&lt;IGListDiffable&gt; obj, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">        addIndexToMap(returnIndexPaths, toSection, idx, obj, newMap);</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="keyword">return</span> [[IGListIndexSetResult alloc] initWithInserts:[<span class="built_in">NSIndexSet</span> indexSetWithIndexesInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, newCount)]</span><br><span class="line">                                               deletes:[<span class="built_in">NSIndexSet</span> new]</span><br><span class="line">                                               updates:[<span class="built_in">NSIndexSet</span> new]</span><br><span class="line">                                                 moves:[<span class="built_in">NSArray</span> new]</span><br><span class="line">                                           oldIndexMap:oldMap</span><br><span class="line">                                           newIndexMap:newMap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Diff算法第一步</strong>：</p>
<p>先定义一个无序去重<code>unordered_map</code>的<code>table</code>，以<code>diffIdentifier</code>为Key，<code>entry</code>为Value，其查找复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt;, IGListEntry, IGListHashID, IGListEqualID&gt; table;</span><br></pre></td></tr></table></figure>
<p>正序遍历新数组：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">vector&lt;IGListRecord&gt; newResultsArray(newCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCount; i++) &#123;</span><br><span class="line">  <span class="comment">// 1.取每个元素的identifier</span></span><br><span class="line">  <span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt; key = IGListTableKey(newArray[i]);</span><br><span class="line">  <span class="comment">// 2.为每个元素创建一个entry,如果table里面不含这个key就创建</span></span><br><span class="line">  IGListEntry &amp;entry = table[key];</span><br><span class="line">  <span class="comment">// 3.entry的newCounter值 +1</span></span><br><span class="line">  entry.newCounter++;</span><br><span class="line">  <span class="comment">// 4.NSNotFound入栈：目的是防止oldIndexes为空，NSNotFound相当于栈底的标志位</span></span><br><span class="line">  entry.oldIndexes.push(<span class="built_in">NSNotFound</span>);</span><br><span class="line">  newResultsArray[i].entry = &amp;entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Diff算法第二步</strong>：</p>
<p>倒序遍历旧数组：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">vector&lt;IGListRecord&gt; oldResultsArray(oldCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = oldCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="comment">// 1.取每个元素的identifier</span></span><br><span class="line">  <span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt; key = IGListTableKey(oldArray[i]);</span><br><span class="line">  IGListEntry &amp;entry = table[key];</span><br><span class="line">  <span class="comment">// 2.entry的olderCounter值 + 1</span></span><br><span class="line">  entry.oldCounter++;</span><br><span class="line">  <span class="comment">// 4.将索引i入栈</span></span><br><span class="line">  entry.oldIndexes.push(i);</span><br><span class="line">  oldResultsArray[i].entry = &amp;entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>温馨提示</strong>：这里采用倒序遍历是为了保证，当存在多个key相同的时候，oldIndexes会有一系列的索引入栈，保证栈顶的索引是最小的。</p>
</blockquote>
<blockquote>
<p><strong>分析</strong>：</p>
<p>在上面两部之后，会建立一个用于存放<code>IGListRecord</code>的<code>oldResultsArray</code>，此时每个<code>IGListRecord</code>仍为<code>NSNotFound</code>，对于<code>oldResultsArray</code>和 <code>newResultsArray</code>中的<code>entry</code>，会有三种情况：</p>
<ul>
<li>该元素只有新数组有，则<code>entry</code>的<code>newCounter</code>&gt;0，<code>oldCounter</code>=0,<code>oldIndexes</code>栈顶为<code>NSNotFound</code>。</li>
<li>该元素只有旧数组有，则<code>entry</code>的<code>newCounter</code>=0，<code>oldCounter</code>&gt;0,<code>oldIndexes</code>栈顶不为<code>NSNotFound</code>，而是元素在旧数组中的最小索引。</li>
<li>该元素新旧数组都有，则<code>entry</code>的<code>newCounter</code>&gt;0，<code>oldCounter</code>&gt;0,<code>oldIndexes</code>栈顶不为<code>NSNotFound</code>，而是元素在旧数组中的最小索引,而<code>oldResultsArray</code>和<code>newResultsArray</code>都指向同一个<code>entry</code>。</li>
</ul>
</blockquote>
<p><strong>Diff算法第三步</strong>：</p>
<p>处理同时出现在新、旧数组里面的都存在的元素(<strong>注意</strong>：这里所说的存在的元素不是指两个元素的值相，而是我们指定的identifier相等，这一点大家要注意一下)，其IGListRecord的index会赋上新、旧数据的索引：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCount; i++) &#123;</span><br><span class="line">    <span class="comment">// 1. 取出新数组中元素对应的entry</span></span><br><span class="line">    IGListEntry *entry = newResultsArray[i].entry;</span><br><span class="line">    <span class="built_in">NSCAssert</span>(!entry-&gt;oldIndexes.empty(), <span class="string">@&quot;Old indexes is empty while iterating new item %li. Should have NSNotFound&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2.拿到oldIndexes的栈顶，也就是拿到该元素在oldArray的第一个索引，然后pop出来</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> originalIndex = entry-&gt;oldIndexes.top();</span><br><span class="line">    entry-&gt;oldIndexes.pop();</span><br><span class="line">    <span class="keyword">if</span> (originalIndex &lt; oldCount) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="type">id</span>&lt;IGListDiffable&gt; n = newArray[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="type">id</span>&lt;IGListDiffable&gt; o = oldArray[originalIndex];</span><br><span class="line">        <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">            <span class="keyword">case</span> IGListDiffPointerPersonality:</span><br><span class="line">            <span class="keyword">if</span> (n != o) &#123;</span><br><span class="line">                entry-&gt;updated = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IGListDiffEquality:</span><br><span class="line">            <span class="keyword">if</span> (n != o &amp;&amp; ![n isEqualToDiffableObject:o]) &#123;</span><br><span class="line">                <span class="comment">// 3.标记需要更新</span></span><br><span class="line">                entry-&gt;updated = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (originalIndex != <span class="built_in">NSNotFound</span> &amp;&amp; entry-&gt;newCounter &gt; <span class="number">0</span> &amp;&amp; entry-&gt;oldCounter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 4.如果用identifier标记的元素在新旧数据中都存在 那么新数组对应元素的index会指向这个元素在老数据中的索引</span></span><br><span class="line">        newResultsArray[i].index = originalIndex;</span><br><span class="line">        oldResultsArray[originalIndex].index = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p><strong>Diff算法第四步</strong>：</p>
<p>遍历老数据，处理需要删除的元素：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span> mInserts, mMoves, mUpdates, mDeletes;</span><br><span class="line"><span class="keyword">if</span> (returnIndexPaths) &#123;</span><br><span class="line">    mInserts = [<span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; new];</span><br><span class="line">    mMoves = [<span class="built_in">NSMutableArray</span>&lt;IGListMoveIndexPath *&gt; new];</span><br><span class="line">    mUpdates = [<span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; new];</span><br><span class="line">    mDeletes = [<span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; new];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mInserts = [<span class="built_in">NSMutableIndexSet</span> new];</span><br><span class="line">    mMoves = [<span class="built_in">NSMutableArray</span>&lt;IGListMoveIndex *&gt; new];</span><br><span class="line">    mUpdates = [<span class="built_in">NSMutableIndexSet</span> new];</span><br><span class="line">    mDeletes = [<span class="built_in">NSMutableIndexSet</span> new];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="built_in">NSInteger</span>&gt; deleteOffsets(oldCount), insertOffsets(newCount);</span><br><span class="line"><span class="built_in">NSInteger</span> runningOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; oldCount; i++) &#123;</span><br><span class="line">      deleteOffsets[i] = runningOffset;</span><br><span class="line">      <span class="keyword">const</span> IGListRecord record = oldResultsArray[i];</span><br><span class="line">  		<span class="comment">// 1.如果记录每个元素的entey记录record里面index的值不存在，则把该元素标记为删除</span></span><br><span class="line">      <span class="keyword">if</span> (record.index == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">          addIndexToCollection(returnIndexPaths, mDeletes, fromSection, i);</span><br><span class="line">          runningOffset++;</span><br><span class="line">      &#125;</span><br><span class="line">      addIndexToMap(returnIndexPaths, fromSection, i, oldArray[i], oldMap);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>Diff算法第五步</strong>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">runningOffset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCount; i++) &#123;</span><br><span class="line">  insertOffsets[i] = runningOffset;</span><br><span class="line">  <span class="keyword">const</span> IGListRecord record = newResultsArray[i];</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">NSInteger</span> oldIndex = record.index;</span><br><span class="line">  <span class="comment">// 1.如果记录每个元素的entey记录record里面index的值不存在，则把该元素标记为插入</span></span><br><span class="line">  <span class="keyword">if</span> (record.index == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">      addIndexToCollection(returnIndexPaths, mInserts, toSection, i);</span><br><span class="line">      runningOffset++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 2.如果记录每个元素的entey里面updated标记为YES，则标记该元素为更新</span></span><br><span class="line">      <span class="keyword">if</span> (record.entry-&gt;updated) &#123;</span><br><span class="line">          addIndexToCollection(returnIndexPaths, mUpdates, fromSection, oldIndex);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 3.标记该元素为移动</span></span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">NSInteger</span> insertOffset = insertOffsets[i];</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">NSInteger</span> deleteOffset = deleteOffsets[oldIndex];</span><br><span class="line">      <span class="keyword">if</span> ((oldIndex - deleteOffset + insertOffset) != i) &#123;</span><br><span class="line">          <span class="type">id</span> move;</span><br><span class="line">          <span class="keyword">if</span> (returnIndexPaths) &#123;</span><br><span class="line">              <span class="built_in">NSIndexPath</span> *from = [<span class="built_in">NSIndexPath</span> indexPathForItem:oldIndex inSection:fromSection];</span><br><span class="line">              <span class="built_in">NSIndexPath</span> *to = [<span class="built_in">NSIndexPath</span> indexPathForItem:i inSection:toSection];</span><br><span class="line">              move = [[IGListMoveIndexPath alloc] initWithFrom:from to:to];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              move = [[IGListMoveIndex alloc] initWithFrom:oldIndex to:i];</span><br><span class="line">          &#125;</span><br><span class="line">          [mMoves addObject:move];</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Diff算法第六步</strong>：</p>
<p>处理完<code>插入</code>、<code>删除</code>、<code>更新</code>、<code>移动</code>之后，返回<code>IGListIndexSetResult</code>类型的值，到这里，IGListKit框架中整个<code>Diff</code> 核心部分就结束了，只讲原理肯定很空洞，我们这里举一个实际的例子来走一遍这个<code>Diff</code>的流程，加深印象和理解。</p>
<h2 id="实际刷新举例说明">实际刷新举例说明</h2>
<p><strong>一</strong>、现在比如一个UICollectionView列表中的初始数据为<code>oldDatasource</code>，数据如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">BasicModel *model0 = [[BasicModel alloc] init];</span><br><span class="line">model0.modelId = <span class="string">@&quot;123&quot;</span>;</span><br><span class="line">model0.title = <span class="string">@&quot;A&quot;</span>;</span><br><span class="line">BasicModel *model1 = [[BasicModel alloc] init];</span><br><span class="line">model1.modelId = <span class="string">@&quot;234&quot;</span>;</span><br><span class="line">model1.title = <span class="string">@&quot;B&quot;</span>;</span><br><span class="line">BasicModel *model2 = [[BasicModel alloc] init];</span><br><span class="line">model2.modelId = <span class="string">@&quot;345&quot;</span>;</span><br><span class="line">model2.title = <span class="string">@&quot;C&quot;</span>;</span><br><span class="line">[<span class="keyword">self</span>.oldDatasource addObjectsFromArray:@[model0,model1,model2]];</span><br></pre></td></tr></table></figure>
<p><strong>二</strong>、刷新后的数据为<code>freshDatasource</code>，数据如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">BasicModel *model3 = [[BasicModel alloc] init];</span><br><span class="line">model3.modelId = <span class="string">@&quot;123&quot;</span>;</span><br><span class="line">model3.title = <span class="string">@&quot;D&quot;</span>;</span><br><span class="line">BasicModel *model4 = [[BasicModel alloc] init];</span><br><span class="line">model4.modelId = <span class="string">@&quot;345&quot;</span>;</span><br><span class="line">model4.title = <span class="string">@&quot;C&quot;</span>;</span><br><span class="line">BasicModel *model5 = [[BasicModel alloc] init];</span><br><span class="line">model5.modelId = <span class="string">@&quot;456&quot;</span>;</span><br><span class="line">model5.title = <span class="string">@&quot;E&quot;</span>;</span><br><span class="line">[<span class="keyword">self</span>.freshDatasource addObjectsFromArray:@[model3,model4,model5]];</span><br></pre></td></tr></table></figure>
<p><strong>三</strong>、在<code>BasicModel</code>中遵守<code>&lt;IGListDiffable&gt;</code>协议，实现下面两个方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BasicModel</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象唯一id，在diff算法中以它作为元素存入哈希表的key</span></span><br><span class="line">- (<span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt;)diffIdentifier &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.modelId) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.modelId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个对象是否相等，在diff算法用这个方法判断两个对象是否是同一个对象</span></span><br><span class="line">- (<span class="type">BOOL</span>)isEqualToDiffableObject:(BasicModel &lt;IGListDiffable&gt;*)object &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> isEqual:object];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>四</strong>、经过<code>Diff核心算法第一步</code>之后的结构如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">newResultsArray里面有三个 IGListRecord 类型的元素，元素里面的entry情况如下：</span><br><span class="line">  </span><br><span class="line">entry[D].newCounter = <span class="number">1</span>;</span><br><span class="line">entry[D].oldIndexes.pop() = <span class="built_in">NSNotFound</span>;</span><br><span class="line">entry[D].updated = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">entry[C].newCounter = <span class="number">1</span>;</span><br><span class="line">entry[C].oldIndexes.pop() = <span class="built_in">NSNotFound</span>;</span><br><span class="line">entry[C].updated = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">entry[E].newCounter = <span class="number">1</span>;</span><br><span class="line">entry[E].oldIndexes.pop() = <span class="built_in">NSNotFound</span>;</span><br><span class="line">entry[E].updated = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>
<p><strong>五</strong>、经过<code>Diff核心算法第二步</code>之后的结构如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">oldResultsArray里面有三个 IGListRecord 类型的元素，元素里面的entry情况如下：</span><br><span class="line"></span><br><span class="line">entry[C].oldCounter = <span class="number">1</span>;</span><br><span class="line">entry[C].oldIndexes.pop() = <span class="number">2</span>;</span><br><span class="line">entry[C].updated = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">entry[B].oldCounter = <span class="number">1</span>;</span><br><span class="line">entry[B].oldIndexes.pop() = <span class="number">1</span>;</span><br><span class="line">entry[B].updated = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">entry[A].oldCounter = <span class="number">1</span>;</span><br><span class="line">entry[A].oldIndexes.pop() = <span class="number">0</span>;</span><br><span class="line">entry[A].updated = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>
<p><strong>六</strong>、经过<code>Diff核心算法第三步</code>之后的结构如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">entry[D].updated = <span class="literal">YES</span>; <span class="comment">// 因为A元素 和 D元素的 modelID一样 标记为刷新</span></span><br><span class="line">entry[C].updated = <span class="literal">YES</span>; <span class="comment">// 新老数据里面都有C元素 并且modelID一样 标记为刷新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A 和 D 的record</span></span><br><span class="line">newResultsArray[<span class="number">0</span>].index = <span class="number">0</span>;</span><br><span class="line">oldResultsArray[<span class="number">0</span>].index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C 在新老数据中的record</span></span><br><span class="line">newResultsArray[<span class="number">1</span>].index = <span class="number">2</span>;</span><br><span class="line">oldResultsArray[<span class="number">2</span>].index = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>七</strong>、经过<code>Diff核心算法第四步</code>之后的结构如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">因为 oldResultsArray[<span class="number">1</span>].index = <span class="built_in">NSNotFound</span>，所以老数据中这个位置元素需要被删除，即是数据B。</span><br></pre></td></tr></table></figure>
<p><strong>八</strong>、经过<code>Diff核心算法第五步</code>之后的结构如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">因为 newResultsArray[<span class="number">2</span>].index = <span class="built_in">NSNotFound</span>，所以新数据中这个位置元素需要插入，即是数据E。</span><br><span class="line"></span><br><span class="line">D元素是更新，C元素是移动。</span><br></pre></td></tr></table></figure>
<p><strong>九</strong>、最后的结论：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Insert: E</span><br><span class="line">Update: D(A -&gt; D)</span><br><span class="line">Move: C</span><br><span class="line">Delete: B</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>看到这里，相信大家对IGListKit框架中Diff算法实现原理有了一个更加清晰的了解，这个算法的时间复杂度就变成了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，ICListKit框架就是通过这种刷新机制来提升了APP的整体性能。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>IGListKit</tag>
        <tag>Diff</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】关于RunLoop的简单介绍</title>
    <url>/posts/a5190dfd/</url>
    <content><![CDATA[<h2 id="写在前面-20">写在前面</h2>
<p>本文主要是记录关于RunLoop的一些简单介绍。</p>
<h2 id="RunLoop">RunLoop</h2>
<h3 id="基本认识">基本认识</h3>
<p>RunLoop：翻译过来叫运行时循环，指的是在程序运行过程中循环的做一些事情。</p>
<p>主要应用在：</p>
<ul>
<li>定时器（Timer）、PerformSelector</li>
<li>GCD</li>
<li>事件响应、手势识别、界面刷新</li>
<li>网络请求</li>
<li>AutoReleasePool</li>
</ul>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/02/13/1.png" alt="1"></p>
<p>上面是我们一个iOS程序的入口<code>main</code>函数，在<code>UIApplicationMain</code>函数中会去创建主线程的RunLoop对象，它用来保证程序不退出从而保证程序的持续执行。<br>
我们可以把RunLoop运行时循环理解成一个<code>do - while</code>循环，伪代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">  <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="type">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 1.在休眠中等待消息</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 2.如果有消息 处理消息</span></span><br><span class="line">      </span><br><span class="line">    &#125;<span class="keyword">while</span>(retVal = <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunLoop的基本作用：</p>
<ul>
<li>保证程序的持续运行</li>
<li>处理App中的各种事件（比如触摸事件、定时器等）</li>
<li>节省CPU资源，提高程序的性能：在有消息的时候处理消息 没有消息的时候休眠。</li>
</ul>
<h3 id="RunLoop对象">RunLoop对象</h3>
<p>iOS中有两套API来访问和使用RunLoop：</p>
<ul>
<li>Foundation框架：<code>NSRunLoop</code></li>
<li>Core Foundation框架：<code>CFRunLoopRef</code>（开源代码：<a href="https://opensource.apple.com/tarballs/CF/">https://opensource.apple.com/tarballs/CF/</a>）</li>
</ul>
<h3 id="RunLoop与线程的关系">RunLoop与线程的关系</h3>
<ul>
<li>每条线程都有唯一的与之相对应的RunLoop对象</li>
<li>RunLoop保存在一个全局的字典里面，线程为<code>key</code>，RunLoop为<code>value</code></li>
<li>线程刚创建的时候并没有RunLoop对象，而是在第一次获取RunLoop对象时去创建</li>
<li>RunLoop会在线程结束时销毁</li>
<li>主线程的RunLoop已经自动获取（创建），子线程的RunLoop默认是没有开启的</li>
</ul>
<h3 id="获取RunLoop对象">获取RunLoop对象</h3>
<p>Foundation框架：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSRunLoop</span> currentRunLoop]; <span class="comment">// 获取当前线程的RunLoop对象</span></span><br><span class="line">[<span class="built_in">NSRunLoop</span> mainRunLoop]; <span class="comment">// 获取主线程的RunLoop对象</span></span><br></pre></td></tr></table></figure>
<p>Core Foundation框架：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopGetCurrent</span>(); <span class="comment">// 获取当前线程的RunLoop对象</span></span><br><span class="line"><span class="built_in">CFRunLoopGetMain</span>();<span class="comment">// 获取主线程的RunLoop对象</span></span><br></pre></td></tr></table></figure>
<h3 id="RunLoop相关的类">RunLoop相关的类</h3>
<p>Core Foundation框架中关于RunLoop的五个类：</p>
<ul>
<li><code>CFRunLoopRef</code></li>
<li><code>CFRunLoopModeRef</code></li>
<li><code>CFRunLoopSourceRef</code></li>
<li><code>CFRunLoopTimerRef</code></li>
<li><code>CFRunLoopObserverRef</code></li>
</ul>
<div class="note green no-icon flat"><p><code>RunLoop</code>对象结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoop</span> &#123;</span><br><span class="line">	<span class="type">pthread_t</span> _pthread;</span><br><span class="line">	CFMutableSetRef _commonModes;</span><br><span class="line">	CFMutableSetRef _commonModeItems;</span><br><span class="line">	CFRunLoopModeRef _currentMode;</span><br><span class="line">	CFMutableSetRef _modes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>RunLoopMode</code>结构如下：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">	CFStringRef _name<span class="comment">;</span></span><br><span class="line">	CFMutableSetRef _sources0<span class="comment">;</span></span><br><span class="line">	CFMutableSetRef _sources1<span class="comment">;</span></span><br><span class="line">	CFMutableArrayRef _observers<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</div>
<p>各个类之间的关系如下图：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/02/13/2.png" alt="2"></p>
<h3 id="RunLoop的运行模式">RunLoop的运行模式</h3>
<p><code>CFRunLoopModeRef</code>表示是RunLoop的运行模式，一个RunLoop可以有若干个Mode，每个Mode里面又包含Source0、Source1、Timer、Observer。<br>
RunLoop在启动时只能选择其中的一个Mode作为CurrentMode。<br>
如果需要切换Mode需要退出当前RunLoop重新选择一个Mode进入。<br>
不同模式下的Source0/Source1/Timer/Observer能分隔开来，互不影响。<br>
如果一个Mode中没有任何Source0/Source1/Timer/Observer，这个RunLoop会立马退出。</p>
<div class="note green no-icon flat"><p>常见的Mode有两种：</p>
<p><code>NSDefaultRunLoopMode(kCFRunLoopDefaultMode)</code>：App的默认Mode，通常主线程在这个Mode下运行。<br>
<code>UITrackingRunLoopMode</code>：界面跟踪Mode，ScrollView的滑动，保证界面滑动时不受其他的影响。</p>
</div>
<h3 id="RunLoop的几种状态">RunLoop的几种状态</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入RunLoop</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中被唤醒</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出RunLoop</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如下可以监听RunLoop的所有状态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CFRunLoopObserverRef observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, <span class="number">0</span>, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;kCFRunLoopEntry...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;kCFRunLoopBeforeTimers...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;kCFRunLoopBeforeSources...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;kCFRunLoopBeforeWaiting...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;kCFRunLoopAfterWaiting...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;kCFRunLoopExit...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line"><span class="built_in">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure>
<h3 id="RunLoop的运行逻辑">RunLoop的运行逻辑</h3>
<p>1、 Source0</p>
<ul>
<li>触摸事件处理</li>
<li>performSelector:onThread:</li>
</ul>
<p>2、Source1</p>
<ul>
<li>基于Port的线程之间的通信</li>
<li>系统事件的捕捉</li>
</ul>
<p>3、Timers</p>
<ul>
<li>NSTimer</li>
<li>performSelector：withObject：afterDelay：</li>
</ul>
<p>4、Observers</p>
<ul>
<li>用于监听RunLoop的状态</li>
<li>UI刷新（BeforeWaiting）</li>
<li>AutoReleasePool（BeforeWaiting）</li>
</ul>
<p>RunLoop的运行逻辑如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/02/13/3.png" alt="3"></p>
<h3 id="RunLoop在实际开发中的应用">RunLoop在实际开发中的应用</h3>
<ul>
<li>控制线程的生命周期（线程保活）</li>
<li>解决NSTimer在滑动时停止工作的问题</li>
<li>监控应用卡顿</li>
<li>性能优化</li>
</ul>
<h3 id="RunLoop的源码查看">RunLoop的源码查看</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/02/13/4.png" alt="4"></p>
<p>从上面看到：RunLoop的源码入口在<code>CFRunLoopRunSpecific</code>。</p>
<div class="note green no-icon flat"><p><strong>注意</strong>：</p>
<p>1、使用Foundation框架打印出来的主线程RunLoop和Core Foundation框架打印出来的主线程RunLoop地址值不一样，原因在于Foundation框架的RunLoop是对Core Foundation框架RunLoop的一层封装。<br>
2、系统事件是通过Source1来捕捉，之后分发到Source0去处理的。<br>
3、RunLoop在休眠之前会去释放自动释放池和刷新UI等。<br>
4、线程阻塞和RunLoop休眠不一样：线程阻塞还是在执行代码 当前线程根本没有真的休眠 RunLoop休眠真的是休眠 没有执行代码 CPU不会为此分配资源 就会省电。</p>
</div>
<h2 id="写在最后-14">写在最后</h2>
<p>关于RunLoop的一些基本介绍、各种模式以及它整个完整的运行逻辑就介绍到这里了，如有错误请多多指教。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】关联对象的底层原理</title>
    <url>/posts/baafbb5e/</url>
    <content><![CDATA[<h2 id="写在前面-21">写在前面</h2>
<p>本文主要探究一下iOS中如何给分类添加属性以及关联对象的底层原理是什么，建议大家看本篇文章的时候参考objc4源码一起看会更好。</p>
<h2 id="如何给分类添加属性">如何给分类添加属性</h2>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person + Test 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<div class="note red no-icon flat"><p><strong>解释</strong>：</p>
<p><code>objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</code>参数解释：</p>
<p>1、<code>object</code>：需要关联的对象</p>
<p>2、<code>key</code>：关联key</p>
<p>3、<code>value</code>：关联值</p>
<p>4、<code>policy</code>：关联策略</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>, <span class="comment">// 对应 assign       </span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">//  对应 strong，nonatomic</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>, <span class="comment">// 对应 copy，nonatomic </span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>, <span class="comment">// 对应 strong，atomic                                     </span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span> <span class="comment">// 对应 copy，atomic</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div>
<h2 id="关联对象的底层原理">关联对象的底层原理</h2>
<div class="note red no-icon flat"><p>博主这里的源码是 objc4 - 838 版本，不同的版本有的方法实现可能会有一些差异但是原理都是基本不变的，建议大家下载最新版本的源码阅读。</p>
</div>
<h3 id="设值原理">设值原理</h3>
<p>设值调用的是<code>objc_setAssociatedObject</code>，里面调用的是<code>_objc_set_associative_reference</code>，设值的核心方法就在<code>_objc_set_associative_reference</code>里面，如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1130/1.png" alt="1"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1130/2.png" alt="2"></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_object_set_associative_reference(<span class="type">id</span> object, <span class="keyword">const</span> <span class="type">void</span> *key, <span class="type">id</span> value, uintptr_t policy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This code used to work when nil was passed for object and key. Some code</span></span><br><span class="line">    <span class="comment">// probably relies on that to not crash. Check and handle it explicitly.</span></span><br><span class="line">    <span class="comment">// rdar://problem/44094390</span></span><br><span class="line">    <span class="keyword">if</span> (!object &amp;&amp; !value) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object-&gt;getIsa()-&gt;forbidsAssociatedObjects())</span><br><span class="line">        _objc_fatal(<span class="string">&quot;objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects&quot;</span>, object, object_getClassName(object));</span><br><span class="line">    <span class="comment">// 把关联对象object包装成一个DisguisedPtr类型的数据结构</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; disguised&#123;(objc_object *)object&#125;;</span><br><span class="line">    <span class="comment">// 把关联策略policy和具体关联的值value包装成一个ObjcAssociation的数据结构</span></span><br><span class="line">    ObjcAssociation association&#123;policy, value&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    <span class="comment">// 根据不同的策略类型做相应的处理</span></span><br><span class="line">    association.acquireValue();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isFirstAssociation = <span class="literal">false</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// AssociationsManager 是关联对象管理类，里面有一个静态变量_mapStorage，要注意的是manager并不是唯一的。</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="comment">// 通过 manager.get()来获取所有的关联表associations 类型是 AssociationsHashMap</span></span><br><span class="line">        AssociationsHashMap &amp;associations(manager.get());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            <span class="comment">// 根据关联的对象disguised去关联表associations中查找对应的ObjectAssociationMap类型的value，如果没有就创建一个插入到associations里面</span></span><br><span class="line">            auto refs_result = associations.try_emplace(disguised, ObjectAssociationMap&#123;&#125;);</span><br><span class="line">            <span class="keyword">if</span> (refs_result.second) &#123;</span><br><span class="line">                <span class="comment">/* it&#x27;s the first association we make */</span></span><br><span class="line">                isFirstAssociation = <span class="literal">true</span>; <span class="comment">// 设置为true</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* establish or replace the association */</span></span><br><span class="line">            auto &amp;refs = refs_result.first-&gt;second;</span><br><span class="line">            auto result = refs.try_emplace(key, std::move(association)); <span class="comment">// 根据传入的key找到对应的bucket，替换掉原来的或者插入新的association，并且设置关联策略。</span></span><br><span class="line">            <span class="keyword">if</span> (!result.second) &#123;</span><br><span class="line">                association.swap(result.first-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果value值为nil 通过传入的关联对象disguised找到相应的AssociationsHashMap</span></span><br><span class="line">            auto refs_it = associations.find(disguised);</span><br><span class="line">            <span class="keyword">if</span> (refs_it != associations.end()) &#123;</span><br><span class="line">                auto &amp;refs = refs_it-&gt;second;</span><br><span class="line">                auto it = refs.find(key); <span class="comment">// 通过传入的key去找到ObjectAssociation</span></span><br><span class="line">                <span class="keyword">if</span> (it != refs.end()) &#123;</span><br><span class="line">                    association.swap(it-&gt;second); <span class="comment">// 进行擦除操作</span></span><br><span class="line">                    refs.erase(it);</span><br><span class="line">                    <span class="keyword">if</span> (refs.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        associations.erase(refs_it);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call setHasAssociatedObjects outside the lock, since this</span></span><br><span class="line">    <span class="comment">// will call the object&#x27;s _noteAssociatedObjects method if it</span></span><br><span class="line">    <span class="comment">// has one, and this may trigger +initialize which might do</span></span><br><span class="line">    <span class="comment">// arbitrary stuff, including setting more associated objects.</span></span><br><span class="line">    <span class="keyword">if</span> (isFirstAssociation)</span><br><span class="line">        <span class="comment">// 如果有关联对象</span></span><br><span class="line">        object-&gt;setHasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="comment">// 对association进行一次release操作</span></span><br><span class="line">    association.releaseHeldValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看到设置关联的四个主要对象：</p>
<p><code>AssociationsManager</code></p>
<p><code>AssociationsHashMap</code></p>
<p><code>ObjectAssociationMap</code></p>
<p><code>ObjcAssociation</code></p>
<p>其中，<code>AssociationsManager</code>的结构为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> AssociationsManager &#123;</span><br><span class="line">  using Storage = ExplicitInitDenseMap&lt;DisguisedPtr&lt;objc_object&gt;, ObjectAssociationMap&gt;;</span><br><span class="line">  <span class="keyword">static</span> Storage _mapStorage;</span><br><span class="line">  </span><br><span class="line">   AssociationsHashMap &amp;get() &#123;</span><br><span class="line">      <span class="keyword">return</span> _mapStorage.get();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">void</span> init() &#123;</span><br><span class="line">      _mapStorage.init();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>AssociationsHashMap</code>的结构为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">DenseMap&lt;DisguisedPtr&lt;objc_object&gt;, ObjectAssociationMap&gt; </span><br></pre></td></tr></table></figure>
<p><code>ObjectAssociationMap</code>的结构为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> DenseMap&lt;<span class="keyword">const</span> <span class="type">void</span> *, ObjcAssociation&gt; ObjectAssociationMap;</span><br></pre></td></tr></table></figure>
<p><code>ObjcAssociation</code>的结构为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> ObjcAssociation &#123;</span><br><span class="line">  uintptr_t _policy; <span class="comment">// 关联策略</span></span><br><span class="line">  <span class="type">id</span> _value; <span class="comment">// 关联值value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这四个对象之间的关系如下图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1130/3.png" alt="3"></p>
<p>对照<code>objc_setAssociatedObject(id object, cons void *key, id value, objc_AssociationPolicy policy)</code>方法：</p>
<ol>
<li>通过<code>AssociationsManager</code>的<code>manager.get()</code>获得<code>AssociationsHashMap</code>。</li>
<li><code>AssociationsHashMap</code>中的<code>key</code>是关联对象<code>object</code>，<code>value</code>是<code>ObjectAssociationMap</code>。</li>
<li><code>ObjectAssociationMap</code>中的<code>key</code>是方法中的<code>key</code>，<code>value</code>是<code>ObjectAssociation</code>。</li>
<li><code>ObjectAssociation</code>中存放的就是方法中的<code>value</code>和关联策略<code>policy</code>。</li>
</ol>
<p>通过上面的分析，设置关联对象的底层原理现在就很清晰了。</p>
<h3 id="取值原理">取值原理</h3>
<p>取得调用的是<code>objc_getAssociatedObject</code>，里面调用的是<code>_object_get_associative_reference</code>，取值的核心方法就在<code>_object_get_associative_reference</code>里面，如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1130/4.png" alt="4"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1130/5.png" alt="5"></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span></span><br><span class="line">_object_get_associative_reference(<span class="type">id</span> object, <span class="keyword">const</span> <span class="type">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    ObjcAssociation association&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.get());</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find((objc_object *)object); <span class="comment">// 通过object可以获取ObjectAssociationMap</span></span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            <span class="comment">// 遍历AssociationsHashMap</span></span><br><span class="line">            ObjectAssociationMap &amp;refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs.find(key); <span class="comment">// 通过key可以获得ObjcAssociation</span></span><br><span class="line">            <span class="keyword">if</span> (j != refs.end()) &#123;</span><br><span class="line">                <span class="comment">// 遍历ObjectAssociationMap</span></span><br><span class="line">                association = j-&gt;second;</span><br><span class="line">                association.retainReturnedValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> association.autoreleaseReturnedValue(); <span class="comment">// 返回取到的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-2">总结</h3>
<p>通过上面分析，我们需要知道：</p>
<ol>
<li>关联对象并不是存储在被关联对象本身的内存里面，而是存储在一个全局的<code>AssociationsHashMap</code>里面。</li>
<li>设置关联对象为<code>nil</code>就相当于是移除关联对象。</li>
<li>移除所有的关联对象：<code>objc_removeAssoociatedObjects</code>。</li>
<li>关联对象的策略里面没有 <code>weak</code>属性。</li>
<li>关联对象被移除的时候，相应的关联属性也会被移除。</li>
</ol>
<h2 id="写在最后-15">写在最后</h2>
<p>关于关联对象的底层原理我们就简单分析到这里，如有错误请多多指教。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】制作.a静态库和.framework静态库最全流程</title>
    <url>/posts/38437bd9/</url>
    <content><![CDATA[<h2 id="写在前面-22">写在前面</h2>
<p>本文记录的主要有两点：</p>
<ul>
<li><code>.a</code>静态库的制作流程以及使用</li>
<li><code>.framework</code>静态库的制作流程以及使用</li>
</ul>
<h2 id="制作-a静态库">制作.a静态库</h2>
<p>第一步：Xcode新建项目 - Frame &amp; Library - Static Library。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/1.png" alt="1"></p>
<p>第二步：博主这里取名为：StaticLibrary，这里出现的两个文件没有用可以删掉。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/2.png" alt="2"></p>
<p>第三步：把想要打成静态库的文件放在<code>StaticLibrary</code>文件夹下面，博主这里以<code>WWPerson</code>文件为例。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/3.png" alt="3"></p>
<p>第四步：修改<code>BuildSetting</code>配置，将<code>Build Active Architeture Only</code> 设置为<code>NO</code>。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/4.png" alt="4"></p>
<p>第五步：添加需要暴露在外面的<code>.h</code>文件，<code>.m</code>文件会自动编译到<code>.a</code>文件中。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/5.png" alt="5"></p>
<p>在未添加之前是下图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/6.png" alt="6"></p>
<p>点击+添加，添加之后：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/7.png" alt="7"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/8.png" alt="8"></p>
<p>需要注意的是：这里需要暴露的<code>.h</code>文件需要放在<code>Public</code>列表栏里面。</p>
<p>第六步：<code>Edit Scheme</code> - 模式改为<code>release</code>模式。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/9.png" alt="9"></p>
<p>第八步：分别在真机和模拟器上都要<code>Command+B</code>编译，编译之后我们可以看到如下内容。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/10.png" alt="10"></p>
<p>其中，<code>Release-iphoneos</code>代表的是真机下的静态库文件，<code>Release-iphonesimulator</code>表示的是模拟器下的静态文库文件。</p>
<div class="note pink no-icon flat"><p><strong>温馨提示</strong>：</p>
<ol>
<li>在模拟器上编译静态库时最好选择高端一点的设备，这样低端设备也可以用，如果选择低端设备可能会出现在高端模拟器上出现错误等问题。</li>
<li>通过<code>Xcode</code> -<code>Preferences</code>- <code>Location</code> 可以找到上面的静态库内容。</li>
</ol>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/11.png" alt="11"></p>
</div>
<p>到这里静态库的制作方法就基本完成了，但是还有一个重要的问题我们还没有解决，那就是模拟器和真机下的静态库需要合并，接下来我们看一下如何合并静态库。</p>
<h2 id="合并静态库">合并静态库</h2>
<ul>
<li>新建一个文件夹用来存放真机和模拟器下打包出来的静态库，博主这里新建一个“合并静态库”的文件夹</li>
</ul>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/12.png" alt="12"></p>
<ul>
<li>打开终端，在终端输入<code>lipo -create 模拟器下的.a 真机下的.a -output 新合并的静态库的存放路径</code>，如下：</li>
</ul>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/13.png" alt="13"></p>
<div class="note green no-icon flat"><p><strong>温馨提示</strong>：</p>
<p>如果在合并的过程中有人碰到跟博主一样的错误的话，请按照下面的方式修改Xcode配置，然后重新编译生成新的.a静态库：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/14.png" alt="14"></p>
<p>出现错误的原因在于：在Xcode12之后编译的模拟器静态库也支持arm64，会导致真机和模拟器有相同的支持架构arm64，这也就导致模拟器和真机不能合并的问题。</p>
<p>上面Xcode设置就是将arm64架构移除。</p>
</div>
<ul>
<li>合并之后，可以在目标文件夹下看到我们刚合并的静态库：</li>
</ul>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/15.png" alt="15"></p>
<ul>
<li>可以使用<code>lipo -info</code>看一下我们打出来的这个静态库支持的架构是哪些：</li>
</ul>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/16.png" alt="16"></p>
<h2 id="a静态库的使用">.a静态库的使用</h2>
<p>静态库的使用很简单，只需要将暴露在外面的<code>.h</code>文件和<code>.a</code>静态库放在项目中即可使用：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/17.png" alt="17"></p>
<h2 id="framework静态库制作流程">.framework静态库制作流程</h2>
<p>第一步：Xcode新建项目 - Frame &amp; Library - Framework。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/18.png" alt="18"></p>
<div class="note green no-icon flat"><p><strong>配置framwork</strong>:</p>
<ol>
<li>
<p><code>Build Settings</code>配置：</p>
<ul>
<li><code>Product Name</code> ：可以修改名称，这里的名称是最终打包出来的<code>framework</code>的名称，博主这里叫<code>PrintFramework</code>。</li>
<li><code>Mac-O Type</code>：选择<code>Static Library</code>。</li>
<li><code>Build Active Architeture Only</code>：设置为<code>NO</code>。</li>
<li><code>Base SDK</code>：选择<code>iOS</code>。</li>
<li><code>iOS Deployment Target</code>：选择打包出来的<code>framework</code>最低支持的iOS版本。</li>
</ul>
</li>
<li>
<p><code>Build Phases</code>配置：</p>
<ul>
<li><code>Copy Bundle Resource</code>：在这里面添加 <code>framework</code>项目使用到的一些资源文件，包括：<code>xib</code>、<code>plist</code>、图片等。</li>
<li><code>Link Binary With Libraries</code>：在这里面添加 <code>framework</code>项目的依赖库。</li>
<li><code>Compile Sources </code>：<code>framework</code>项目包含的实现文件。</li>
<li><code>Headers</code>：将要暴露出来的头文件放在<code>public</code> 下，不需要暴露在外面的头文件放在<code>project</code>下。</li>
</ul>
</li>
</ol>
</div>
<p>第二步：如果项目中用到了图片、<code>Xib</code>等资源时需要创建一个<code>Bundle</code>：File - New - Target - macOS - Bundle。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/19.png" alt="19"></p>
<div class="note red no-icon flat"><p><strong>注意</strong>：</p>
<p>在创建<code>Bundle</code>时的名称不能和<code>framework</code>的名称一样，一样会导致失败。</p>
<p><strong>配置Bundle</strong>：</p>
<ul>
<li>
<p>选中<code>Bundle</code>Target，<code>Product Name</code> - 修改<code>Bundle</code>名称，博主这里叫<code>PrintFramework</code>。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/22.png" alt="22"></p>
</li>
<li>
<p><code>Base SDK</code>：修改为<code>iOS</code>。</p>
</li>
<li>
<p><code>Supported Platforms</code>：修改为<code>iOS</code>。</p>
</li>
<li>
<p><code>Enable Bitcode</code>：设置为<code>NO</code>。</p>
</li>
<li>
<p><code>COMBILE_HIDPI_IMAGES</code>：设置为<code>NO</code>。（避免<code>Bundle</code>中的图片变成<code>tiff</code>格式而无法使用）</p>
</li>
</ul>
</div>
<p>第三步：将创建好的<code>Bundle</code>添加到<code>framework</code>项目的依赖中去。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/23.png" alt="23"></p>
<p>第四步：<code>Edit Scheme</code> - 模式改为<code>release</code>模式。</p>
<p>第五步：分别在真机和模拟器下编译<code>framework</code>项目，得到两个文件如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/24.png" alt="24"></p>
<p>到这里，我们制作的<code>framework</code>静态库就基本完成，接下来就是和制作<code>.a</code>静态库一样需要合并静态库，博主这里久不过多阐述了，按照上面的方式产生新的<code>framework</code>静态库。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/21.png" alt="21"></p>
<p>第六步：将新合并的<code>framework</code>文件替换掉之前的<code>xxx.framework</code>中的<code>framework</code>文件。</p>
<h2 id="framework静态库使用">.framework静态库使用</h2>
<p>将打包出来的<code>xxx.framework</code>和<code>Bundle</code>导入项目中即可使用：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/05/02/25.png" alt="25"></p>
<p>到这里，关于<code>.framework</code>静态库的制作方法就结束了。</p>
<h2 id="写在最后-16">写在最后</h2>
<p>iOS中关于制作<code>.a</code>和<code>.framework</code>静态库的流程到这里就基本结束了，下一篇文章博主将来详细讲一下静态库和动态库的区别。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】启动优化（一）</title>
    <url>/posts/a5b508b2/</url>
    <content><![CDATA[<h2 id="APP是如何启动的">APP是如何启动的</h2>
<h3 id="APP启动">APP启动</h3>
<p>热启动：系统里面存在APP的进程缓存信息，比如杀掉APP后短时间内重启APP。</p>
<p>冷启动：系统里面没有APP的进程缓存信息，例如重启手机打开应用、APP长时间不用系统替换掉已有的进程缓存。</p>
<p>APP的启动流程图如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220525/20220525_01.png" alt="20220525_01"></p>
<h4 id="main函数之前">main函数之前</h4>
<p>main函数之前所干的事大概可以总结为：</p>
<p><code>dyld</code>：动态链接器，把所有的可执行文件所依赖的动态库递归加载到内存中。</p>
<p><code>rebase/bindging</code>：<code>rebase</code> 是指调整镜像内部的指针，<code>binding</code>是指绑定外部函数的指针。</p>
<p><code>objc setup</code>：Runtime的初始化，对class和category注册，对selector的唯一性判断。</p>
<p><code>load &amp; initialize &amp; constructor</code>：调用所有类的+load方法，初始化C&amp;C++静态常量，调用<code>__attribute__((constructor))</code>修饰的函数。</p>
<p>总结为如下图：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220525/20220525_02.png" alt="20220525_02"></p>
<p>其他的都很好理解，我这里重点解释一下<code>rebase</code>和<code>binding</code>到底在干什么？</p>
<p><strong>rebase &amp; binding</strong></p>
<p><strong>虚拟内存 &amp; 物理内存</strong></p>
<p>物理内存：指的是通过物理内存条获取的内存空间。</p>
<p>虚拟内存：指的是将硬盘的一块区域划分出来作为内存。</p>
<p>在long long ago，没有虚拟内存的概念，那时候每个进程运行的时候是整个应用全部丢进物理内存，概述图如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220525/20220525_03.png" alt="20220525_03"></p>
<p>物理内存存在的问题：</p>
<ol>
<li>内存问题 - 每次直接把一个进程全部丢进物理内存，很可能出现内存不够用的情况。</li>
<li>进程安全问题 - 很容易拿到其他应用的内存地址，就会出现进程不安全的问题。</li>
</ol>
<p>操作系统出现虚拟内存的技术之后，进程运行时并不是整个被装载进物理内存，而是通过内存分页的技术来装载进物理内存的，概述图如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220525/20220525_04.png" alt="20220525_04"></p>
<p>虚拟内存的技术出现以后，就出现一个ASLR（地址空间布局随机），比如一个应用每次运行的地址是变化的，比如下图：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220525/20220525_05.png" alt="20220525_05"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220525/20220525_06.png" alt="20220525_06"></p>
<p><strong>修正偏移（rebase）</strong></p>
<p>那么问题来了：既然我们每次启动应用地址都是随机的，那我们怎么找到真正存储某个函数的地址呢？</p>
<p>Link Map File：链接映射文件，里面记录了每个类所生成的可执行文件的路径、CPU架构、目标文件、符号等信息。</p>
<p>请现在Xcode - Build Settings - 设置Write Link Map File为YES，将Link Map File（链接映射文件）写入到本地。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220525/20220525_07.png" alt="20220525_07"></p>
<p>按照上图的Path找到我们的Link Map File文件，打开如下图：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220525/20220525_08.png" alt="20220525_08"></p>
<p>根据我们前面的ASLR 和 Link Map File中某个方法的偏移量来修复成这个函数的真实内存地址，这个过程就是rebase。</p>
<p>比如：ASLR为<code>0x000000010260f000</code>，偏移量为<code>0x1E80</code></p>
<p>rebase结果如下图：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220525/20220525_09.png" alt="20220525_09"></p>
<p>从上面的打印可以看到：通过rebase之后的地址就是存放<code>-[ViewController viewDidload]</code>的真实地址。</p>
<p><strong>绑定符号（binding）</strong></p>
<p>binding（符号绑定）主要是针对外部函数的绑定，指的是在运行时通过外部符号去找到真正的存放这个外部函数的地址。</p>
<p>举例：我们如何绑定<code>Foundation</code>框架中的<code>NSLog</code>函数？</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220525/20220525_10.png" alt="20220525_10"></p>
<p>上图是通过汇编看到的<code>NSLog</code>的地址存放内容：会发现打印的<code>NSLog</code> 其实还是项目本身的，并不是我们要找的<code>Foundation</code>的<code>NSLog</code>。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220525/20220525_11.png" alt="20220525_11"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220525/20220525_12.png" alt="20220525_12"></p>
<p>ASLR为<code>0x00000001017ab000</code>，通过烂苹果工具可以看到<code>NSLog</code>的符号为<code>0x4020</code>，我们看一下内存分布：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220525/20220525_13.png" alt="20220525_13"></p>
<p>通过上图可以清晰的发现：原来我们<code>Foundation</code>框架的<code>NSLog</code>地址为：<code>0x7fff25762dfa</code>。</p>
<p><strong>注意</strong>：因为<code>binding</code>的都是针对外部函数的绑定，所以我们可以肯定符号和这个外部函数的真实地址针对一个函数是相同的。</p>
<h4 id="main函数">main函数</h4>
<p>在经过了<code>main</code>函数之前的过程之后，这个时候就会调用一个项目的<code>main</code>函数，在这里面一般我们什么都不会干。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    NSString * appDelegateClassName;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">        appDelegateClassName = NSStringFromClass([AppDelegate class]);</span><br><span class="line">    &#125;</span><br><span class="line">    return UIApplicationMain(argc, argv, nil, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main函数之后">main函数之后</h4>
<p><code>main</code>函数之后，接着调用的是<code>didFinishLaunchingWithOptions</code>方法，一般我们在这里面做一些SDK的初始化，初始化RootVc等操作，因为这里面的代码都是我们开发者自己写的，所以可操作性也是最强的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="衡量APP的启动时长">衡量APP的启动时长</h2>
<h3 id="main函数之前的时长统计">main函数之前的时长统计</h3>
<p>首先在<code>Edit Scheme</code> - <code>Run</code> - <code>Arguments</code> - <code>DYLD_PRINT_STATISTICS</code>设置为1:</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220525/20220525_14.png" alt="20220525_14"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220525/20220525_15.png" alt="20220525_15"></p>
<h3 id="main函数之后的时长统计">main函数之后的时长统计</h3>
<p><code>main</code>函数之后的时长统计我们可以从<code>didFinishLaunchingWithOptions</code>调用开始计时到第一个页面渲染出来结束的时长，我们可以直接在这两个地方打点估算这个时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    CFAbsoluteTime startTime = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    sleep(2.0);//假装我是didFinishLaunchingWithOptions里的耗时方法</span><br><span class="line">    CFAbsoluteTime endTime = CFAbsoluteTimeGetCurrent() - startTime;</span><br><span class="line">    NSLog(@&quot;main函数之后的时长统计1：%f ms&quot;,endTime * 1000);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动优化的方案">启动优化的方案</h2>
<h3 id="Main函数之前的优化">Main函数之前的优化</h3>
<h4 id="dyld加载">dyld加载</h4>
<ul>
<li>严格控制动态库的引入，Apple官方建议一个项目使用的动态库不要超过6个，如果大于6个就需要考虑合并动态库。</li>
</ul>
<h4 id="rebase-binding">rebase &amp; binding</h4>
<ul>
<li>
<p>减少类、分类、方法的数量，定期检查项目中不用的类或方法及时清理等。</p>
</li>
<li>
<p>减少C++虚函数数量（创建虚函数表也是有开销）</p>
</li>
</ul>
<h4 id="objc-setup">objc setup</h4>
<ul>
<li>如果前面两步做了处理，这一步就没有什么可以优化的空间了。</li>
</ul>
<h4 id="load-initialize-Constructor">load &amp; initialize &amp; Constructor</h4>
<ul>
<li>load方法尽量不要使用</li>
<li><code>__attribute__((constructor))</code> 修饰的函数尽量不要使用</li>
</ul>
<h3 id="Main函数之后的优化">Main函数之后的优化</h3>
<ul>
<li>
<p>使用纯代码的方式而不是Storyboard加载首页UI。</p>
</li>
<li>
<p>对于didFinishLaunchingWithOptions：里的方法挖掘是否有可能延迟加载。</p>
</li>
<li>
<p>跟各个业务方PM和RD共同check一些已经下线的业务，删除冗余的代码</p>
<p>…</p>
</li>
</ul>
<h2 id="一些检测工具推荐">一些检测工具推荐</h2>
<ul>
<li><a href="https://github.com/HSFGitHub/XcodeProjectArrangementTool">https://github.com/HSFGitHub/XcodeProjectArrangementTool</a></li>
<li><a href="https://github.com/dblock/fui">https://github.com/dblock/fui</a></li>
<li><a href="https://github.com/nst/objc_cover">https://github.com/nst/objc_cover</a></li>
<li><a href="https://www.jetbrains.com/objc">https://www.jetbrains.com/objc</a></li>
<li><a href="https://github.com/yan998/SelectorsUnrefs">https://github.com/yan998/SelectorsUnrefs</a></li>
</ul>
<h2 id="最后-8">最后</h2>
<p>下一篇预告：<a href="https://codersunny.com/posts/23c5d0e7/">iOS重学之启动优化（二）- 二进制重排</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>启动优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【 iOS重学】启动优化（三）- Clang插桩</title>
    <url>/posts/37cd28e5/</url>
    <content><![CDATA[<h2 id="写在前面-23">写在前面</h2>
<p>在 上一篇文章<a href="https://codersunny.com/posts/23c5d0e7/">iOS重学之启动优化（二）- 二进制重排</a> 最后我们提出了一个问题：如何精确获取应用启动时刻的符号调用顺序，本篇文章我们就来详细介绍如何通过Clang插桩来对所有的符号进行100%的Hook。</p>
<h2 id="Clang插桩">Clang插桩</h2>
<p>LLVM内置了一个简单的代码覆盖率检测(SanitizerCoverage)。它在函数级、基本块级和边缘级插入对用户定义函数的调用，并提供了这些回调的默认实现。在认为启动结束的位置添加代码，就能够拿到启动到指定位置调用到的所有函数符号。</p>
<p><a href="https://clang.llvm.org/docs/SanitizerCoverage.html">LLVM官方文档</a> 也具体介绍了如何使用<code>Tracing PCs with guards</code>来做到Hook所有的函数符号。</p>
<div class="note pink no-icon flat"><p><strong>Tracing PCs with guards:</strong></p>
<p>可以理解为跟踪代码执行逻辑的一个工具，Clang编译器就可以通过插桩来获取调用的符号顺序。</p>
</div>
<h3 id="Xcode配置">Xcode配置</h3>
<p>在项目Buiding Setting中<code>Other C Flags</code>里面添加 <code>-fsanitize-coverage=trace-pc-guard</code>标识，如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220626/2022061601.png" alt="2022061601"></p>
<h3 id="添加Hook代码">添加Hook代码</h3>
<p>在项目里面添加如下两个函数：</p>
<p>首先导入头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sanitizer/coverage_interface.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start, <span class="type">uint32_t</span> *stop) &#123;</span><br><span class="line">      <span class="type">static</span> <span class="type">uint64_t</span> N;</span><br><span class="line">      <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;INIT: %p %p\n&quot;</span>, start, stop);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">uint32_t</span> *x = start; x &lt; stop; x++)</span><br><span class="line">        *x = ++N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span> *guard) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">  <span class="type">char</span> PcDescr[<span class="number">1024</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;guard: %p %x PC %s\n&quot;</span>, guard, *guard, PcDescr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数分析">函数分析</h3>
<p><strong>一、</strong> void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop)</p>
<p>运行项目，打印结果如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220626/2022062602.png" alt="2022062602"></p>
<blockquote>
<p>可以看到目前stop存放的是14</p>
</blockquote>
<p>如果我们在项目里面添加一个方法比如：<code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</code>，运行项目之后再看打印结果如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220626/2022062603.png" alt="2022062603"></p>
<blockquote>
<p>可以看到目前stop存放的是15</p>
</blockquote>
<p>大家如果有兴趣，可以在项目里面再添加几个函数看看stop存放的数字的变化，变化规律是：每添加一个函数、方法、block等，stop存放的数值就会+1。</p>
<div class="note pink no-icon flat"><p><strong>结论:</strong></p>
<p><code>__sanitizer_cov_trace_pc_guard_init</code> 函数作用是：获取整个项目中符号的个数。</p>
</div>
<p><strong>二、</strong> void __sanitizer_cov_trace_pc_guard(uint32_t *guard)</p>
<p>我们的需求是：能够获取所有方法、函数、block的调用顺序并且知道符号的名称，这样我们就能排列order文件。</p>
<p><strong>1</strong>、在项目添加一个OC方法：<code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</code></p>
<p>在合适位置下断点，运行项目，查看函数调用栈：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220626/2022062604.png" alt="2022062604"></p>
<p>通过查看汇编也可以看到：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220626/2022062605.png" alt="2022062605"></p>
<p><label style="color:green">会发现：调用一个OC方法时，会调用到<code>__sanitizer_cov_trace_pc_guard(uint32_t *guard)</code> 方法。</label></p>
<p><strong>2</strong>、在项目里面添加一个C函数：<code>void test()</code></p>
<p>在合适位置下断点，运行项目，查看函数调用栈：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220626/2022062606.png" alt="2022062606"></p>
<p>通过查看汇编也可以看到：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220626/2022062607.png" alt="2022062607"></p>
<p><label style="color:green">会发现：调用一个C函数时，会调用到<code>__sanitizer_cov_trace_pc_guard(uint32_t *guard)</code> 方法。</label></p>
<p>同理，你也可以添加一个block然后去看函数调用栈和汇编可以得出相同的结论：</p>
<div class="note pink no-icon flat"><p><strong>结论:</strong></p>
<p><code>__sanitizer_cov_trace_pc_guard</code> 函数作用是：Hook了项目所有的方法、函数、block。</p>
</div>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import &lt;dlfcn.h&gt;</span></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>; // 把这个注释掉 +<span class="keyword">load</span>方法也会hook到</span><br><span class="line">    Dl_info <span class="keyword">info</span>;</span><br><span class="line">    <span class="type">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    dladdr(PC, &amp;<span class="keyword">info</span>);</span><br><span class="line">    NSLog(@&quot;name:%s\n&quot;,<span class="keyword">info</span>.dli_sname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PC的值是指返回到上一个函数里面，比如是test()函数调用到该方法里面，那么PC的值就是test()函数的值。</p>
</blockquote>
<p>我们通过汇编可以看到PC返回的就是上一个符号的函数地址：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220626/2022062608.png" alt="2022062608"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220626/2022062609.png" alt="2022062609"></p>
<p>通过控制台打印：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220626/2022062610.png" alt="2022062610"></p>
<div class="note green no-icon flat"><p><strong>分析:</strong></p>
<p>这个空项目启动时刻调用的方法有上面打印的这些，一共是14个，也和我们前面讲<code>void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop)</code>这个函数的作用时的打印是一致的。</p>
<p>我们已经通过上面的函数解决了我们的问题：拿到调用顺序和函数的名称，二进制重排最大的问题我们已经解决。</p>
</div>
<h3 id="Order文件">Order文件</h3>
<p>现在我们就可以创建一个.order文件，在文件里面对符号进行排序，把应用启动时刻调用的方法排到前面，这样就可以减少PageFault次数从而减少启动时长，具体如何创建Order文件可以参考上一篇文章：<a href="https://codersunny.com/posts/23c5d0e7/">iOS重学之启动优化（二）- 二进制重排</a> 。</p>
<h2 id="总结-3">总结</h2>
<p>关于用Clang插桩的方法去解决二进制重排如何排序的问题到这里就基本结束了，当然也遗留了一些问题：比如如果项目里面有Swift、循环等，这个时候我们的Clang应该如何去做进一步的优化，大家有兴趣的可以自己去研究一下。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>启动优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】启动优化（二）- 二进制重排</title>
    <url>/posts/23c5d0e7/</url>
    <content><![CDATA[<h2 id="写在前面-24">写在前面</h2>
<p>在第一部分<a href="https://codersunny.com/posts/a5b508b2/">iOS重学之启动优化（一）</a>中，我们主要从<code>Pre-main</code>和<code>main</code>之后两个时间来衡量一个iOS应用启动的时长，以及详细分析了<code>Pre-main</code>的四个阶段，其中也提到了一些概念：比如<strong>物理内存</strong>、<strong>虚拟内存</strong>、<strong>缺页中断</strong>等，感兴趣的可以移步上一篇文章了解一下，本文主要跟大家详细讨论一下什么是<strong>二进制重排</strong>、<strong>二进制重排为什么能够优化iOS应用启动时间</strong>等问题。</p>
<h2 id="物理内存-虚拟内存">物理内存 &amp; 虚拟内存</h2>
<p><strong>物理内存</strong>：指的是通过物理内存条获得的内存空间。</p>
<p><strong>虚拟内存</strong>：跟物理内存相反，虚拟内存指的一种计算机系统内存管理技术，它使得应用程序认为它拥有连续可用的内存，实际上它通常被分隔成多个物理内存碎片。</p>
<p>只谈概念太空洞，下面我们用图来解释什么是物理内存、什么是虚拟内存。</p>
<p>物理内存的概述图如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061501.png" alt="2022061501"></p>
<div class="note pink no-icon flat"><p><strong>分析</strong>：</p>
<p>在没有虚拟内存的概念之前，每个应用一启动，操作系统就会把整个应用放进物理内存里面。</p>
</div>
<div class="note green no-icon flat"><p><strong>物理内存存在的问题</strong>：</p>
<ul>
<li>内存紧张的问题 - 由于每次都是直接把整个应用放进物理内存里面，很可能出现内存不够用的情况。</li>
<li>进程的安全问题 - 没个进程之间的物理地址是连续的，可以拿到别的进程的地址，容易出现进程不安全的问题。</li>
</ul>
</div>
<p>虚拟内存的概述图如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061502.png" alt="2022061502"></p>
<div class="note pink no-icon flat"><p><strong>分析</strong>：</p>
<p>虚拟内存的技术出现之后，每个进程并不是直接全部扔进物理内存，而是给每个应用分配一个虚拟的内存，虚拟内存通过<strong>虚拟页表</strong>来把相应数据放进物理内存里面。</p>
<p><strong>虚拟内存</strong>的技术出现之后，也有了<strong>内存分页</strong>的概念，<strong>虚拟页表</strong>把一个进程分成若干页，比如：<code>Page1</code>、<code>Page2</code>、<code>Page3</code>…，当启动进程1的时候，只需要把<code>Page1</code>装载进物理内存，以此类推，如上图。</p>
<p><strong>PS</strong>：大家注意上图的颜色区分能够很好的理解虚拟内存相关概念。</p>
</div>
<div class="note green no-icon flat"><p><strong>虚拟内存</strong>解决了<strong>物理内存</strong>存在的两个问题，由于每个进程的数据被分成了很多页装载进内存，不会再出现内存紧张的问题，而且一个应用在物理内存里面的地址是不连续的，所以无法访问到别的进程的地址，也保证了线程安全。</p>
</div>
<p><strong>注意</strong>：虽然一个应用在物理内存中的内存是不连续的，但是访问数据的时候是连续的，原因就在于我们访问数据访问的是对应的虚拟映射表，这个虚拟映射表记录的某个方法、函数对应在物理内存的真实地址。</p>
<h2 id="缺页中断（PageFault）">缺页中断（PageFault）</h2>
<p>在上面我们说过在有了<strong>虚拟内存</strong>技术之后，内存以分页的形式装载进物理内存里面，比如我们现在启动一个应用只需要先把启动相关的内存<code>Page1</code>到<code>Page10</code>装载进物理内存，当用到A功能的时候发现数据没有在物理内存里面，此时操作系统会阻塞APP进程触发一次<strong>PageFault</strong>，操作系统会从磁盘中读取相应的数据到物理内存上，再将其映射到虚拟内存页表上面。<strong>PageFault</strong>耗时非常短，平均在0.5ms左右，所以用户一般感知不到，但是有一种情况可能会造成大量的<strong>PageFault</strong>，那就是启动时刻，所以我们就可以思考如何减少启动时的<strong>PageFault</strong>次数，从而优化启动时长。</p>
<h2 id="二进制重排">二进制重排</h2>
<p>在分析二进制重排之前，我们先了解一下Link Map File是个什么东西。</p>
<h3 id="链接映射文件">链接映射文件</h3>
<p><strong>链接映射文件</strong>：Link Map File，里面记录的是每个类所生成的可执行文件的路径、CPU架构、符号等信息，可以简单的理解为这个文件告诉了我们一个应用的可执行文件的排列顺序。</p>
<div class="note pink no-icon flat"><p>BuildSetting - Write Link Map File设置为YES。</p>
</div>
<p>如图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061504.png" alt="2022061504"></p>
<p>编译项目之后根据上图的地址找到我们需要的Link Map 文件，如图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061505.png" alt="2022061505"></p>
<p>文件资源的编译顺序如下图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061506.png" alt="2022061506"></p>
<div class="note green no-icon flat"><p>从上图可以看出一个项目可执行文件的排列顺序为：</p>
<ul>
<li>先按照项目 - Build Phases - Compile Sources中的顺序排列</li>
<li>再按每个文件里面从上至下的方法顺序排列</li>
</ul>
</div>
<h3 id="什么是二进制重排">什么是二进制重排</h3>
<p>重新排列函数符号的位置，降低Mach-o文件载入物理内存时触发的<strong>PageFault</strong>次数，这个就叫<strong>二进制重排</strong>。</p>
<h3 id="为什么二进制重排能优化启动时长">为什么二进制重排能优化启动时长</h3>
<p>我们先来举个例子，一个应用启动需要调用<code>方法1</code>、<code>方法3</code>、<code>方法4</code>、<code>方法6</code>、<code>方法7</code>，其中<code>方法1</code>在Page1页上，<code>方法6</code>在Page2页上，<code>方法3</code>、<code>方法7</code>在Page3页上，<code>方法4</code>在Page4页上，如下图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061503-20220616141820096.png" alt="2022061503"></p>
<p>二进制排列后，如下图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061507.png" alt="2022061507"></p>
<div class="note green no-icon flat"><p>经过二进制重排之后，我们把启动需要调用的方法全部集中在了Page1里面，这样在启动时只需要装载Page1即可，相比之前减少了Page2、Page3、Page4的装载，这就减少了<strong>PageFault</strong>的次数，节省的时间大约为：0.5ms * 3 = 1.5ms。</p>
<p>这也就解释了为什么二进制重排能够优化启动时长。</p>
</div>
<h3 id="二进制重排-2">二进制重排</h3>
<p>iOS 应用之所以能够进行二进制重排其实是因为苹果爸爸早就有了这一套机制，其实<code>libobjc.order</code>就是利用二进制重排进行了优化。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061508.png" alt="2022061508"></p>
<p>现在我们来举个简单的例子做二进制重排：</p>
<p>以一个新的项目<code>LaunchDemo</code>为例，我在<code>ViewController.m</code>文件里面新加了几个方法如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061510.png" alt="2022061510"></p>
<p><strong>一</strong>、在项目根目录下创建一个<code>.order</code>文件，我们这里叫：<code>LaunchDemo.order</code>文件：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061509.png" alt="2022061509"></p>
<p>我们先看一下默认的一个排列顺序：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061511.png" alt="2022061511"></p>
<p><strong>二</strong>、在<code>LaunchDemo.order</code>文件里面指定每个符号的排列顺序：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061512.png" alt="2022061512"></p>
<p><strong>三</strong>、在<code>Build Setting</code>里面指定<code>Order File</code>地址，如图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061513.png" alt="2022061513"></p>
<p><strong>四</strong>、编译项目，打开Link Map File，如下图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220615/2022061514.png" alt="2022061514"></p>
<div class="note orange no-icon flat"><p><strong>分析</strong>：</p>
<p>经过二进制重排之后我们发现<code>Link Map File</code>文件里面的符号排列顺序已经按照我们指定的顺序排列，其中我们在<code>LaunchDemo.order</code>文件里面指定的<code>-[LaunchDemo test]</code>符号，项目里面没有这个方法，所以只会被忽略不会报错。</p>
</div>
<p>到这里为止，二进制重排的整个核心我们就分析得差不多了，但是这个二进制重排有个最大的问题，那就是：我们如何才能准确获取项目启动时刻调用的方法顺序，换句话说我怎么知道我这个项目启动需要调用到哪些方法。</p>
<h2 id="写在最后-17">写在最后</h2>
<p>二进制重排最大的问题我们已经抛出来了，有兴趣的也可以想想应该怎么办，<a href="https://codersunny.com/posts/37cd28e5/">下一篇文章</a>我们将重点分析如何精确获取项目启动时刻调用的方法顺序。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>启动优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【 iOS重学】探究OC对象的本质</title>
    <url>/posts/431bd9b3/</url>
    <content><![CDATA[<h2 id="写在前面-25">写在前面</h2>
<p>苹果官方源码下载：<a href="http://opensource.apple.com/tarballs">opensource.apple.com/tarballs</a> -&gt; 搜索objc/4 -&gt; 下载最新源码</p>
<h2 id="Objective-C的本质">Objective-C的本质</h2>
<p>在iOS开发中如果我们使用OC编写的代码，其底层都是C/C++代码。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202208/0810/2022081001.png" alt="2022081001"></p>
<p>所以我们可以理解为：Objective-C中面向对象都是基于C/C++的数据结构【<strong>结构体</strong>】实现的。</p>
<p>在面试的时候有的面试官会问到我们OC对象的本质是什么？我们可以说是【<strong>结构体</strong>】。</p>
<div class="note green no-icon flat"><p>生成C++文件的一些命令：</p>
<p><code>clang -rewrite-objc main.m -o main.cpp</code>：无法区分平台 不建议使用</p>
<p><code>xcrun -sdk iphonesimulator clang -rewrite-objc main.m  -o main.cpp</code>：模拟器</p>
<p><code>xcrun -sdk iphoneos clang -rewrite-objc main.m -o main.cpp</code>：真机</p>
<p><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc 源文件名 -o 输出的cpp文件名</code>：arm64架构 这个命令我用得最多</p>
</div>
<h2 id="OC对象的本质">OC对象的本质</h2>
<h3 id="NSObject对象的底层实现">NSObject对象的底层实现</h3>
<p>先从一个最简单的例子说起：</p>
<p>在main函数里面创建一个<code>NSObject</code>的对象：<code> NSObject *objc = [[NSObject alloc] init];</code></p>
<p>使用上面的命令生成相应的C++代码如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202208/0810/2022081002.png" alt="2022081002"></p>
<p>分析C++文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSObject Implementation(NSObject 底层实现)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NSObject_IMPL</span> &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_class</span> *Class;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure>
<p>这句代码的意思：创建完对象之后，给这个对象分配完存储空间，把这个对象的内存地址赋值给objc这个指针 这样我们才能通过objc这个指针找到这个对象。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202208/0810/2022081003.png" alt="2022081003"></p>
<div class="note green no-icon flat"><p>如何让项目中的某个文件不参与编译？</p>
<p>项目设置 - Build Phases - Compile Sources - 删除不需要参与编译的文件</p>
</div>
<h3 id="class-getInstanceSize-和-malloc-size">class_getInstanceSize 和 malloc_size</h3>
<p>创建一个实例对象 至少需要多少内存？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="comment">// 输出值：8</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;class_getInstanceSize : %zu&quot;</span>,class_getInstanceSize(objc.class)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码</span></span><br><span class="line">size_t class_getInstanceSize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个实例对象 实际分配了多少内存？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"><span class="comment">// 输出值：16</span></span><br><span class="line">malloc_size((__bridge <span class="keyword">const</span> <span class="type">void</span> *)obj); </span><br></pre></td></tr></table></figure>
<p>源码：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202208/0810/2022081004.png" alt="2022081004"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202208/0810/2022081005.png" alt="2022081005"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202208/0810/2022081006.png" alt="2022081006"></p>
<p>按照上面的源码可以看到：存在【内存对齐】的概念 当size&lt;16时 会赋值为16。</p>
<h3 id="窥探NSObject的内存">窥探NSObject的内存</h3>
<p>拿到<code>NSObject</code>对象的内存地址：<code>0x6000021ac070</code></p>
<p>通过Debug - Debug Workflow - View Memory(shift + command + M) 查看内存情况：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202208/0810/image-20220810161623329.png" alt="image-20220810161623329"></p>
<div class="note green no-icon flat"><p><strong>内存分析</strong>：</p>
<p>上图是16进制的内存分布。</p>
<p>一个16进制位对应4个二进制位 比如二进制的1001 等于 16进制的9</p>
<p>上图中的【10】对应的就是8个二进制位 也就是一个字节</p>
<p>从80开始就是新的对象的内存 这样我们可以看到NSObject确实是分配了<label style="color:red">16个字节</label>。</p>
</div>
<p><label style="color:red">memory read（x）</label>：读取内存</p>
<p><label style="color:red">memory write</label>：改写内存</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202208/0810/2022081008.png" alt="2022081008"></p>
<h3 id="更复杂的对象的底层探究">更复杂的对象的底层探究</h3>
<p>🌰 现创建一个<strong>Person</strong>对象继承自<strong>NSObject</strong>，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *person = [[Person alloc] init];</span><br><span class="line">        person.name = <span class="string">@&quot;Sunny&quot;</span>;</span><br><span class="line">        person.age = <span class="number">12</span>;</span><br><span class="line">      	<span class="comment">// 输出值：24</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;class_getInstanceSize: %zu&quot;</span>,class_getInstanceSize(person.class));</span><br><span class="line">      	<span class="comment">// 输出值：32</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;malloc_size: %zu&quot;</span>,malloc_size((__bridge <span class="keyword">const</span> <span class="type">void</span> *)(person)));</span><br><span class="line">      </span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转化为C++底层代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person_IMPL &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> <span class="built_in">NSObject_IVARS</span>;</span><br><span class="line">	<span class="built_in">NSString</span> *_name;</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看<code>person</code>对象的内存分布如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202208/0810/2022081009.png" alt="2022081009"></p>
<p><label style="color:red"><strong>分析</strong>：</label></p>
<p><code>f8 d5 e1 07 01 00 00 00</code>段存储的是<code>person</code>对象的内存地址。</p>
<p><code>0c 00 00 00 00 00 00 00</code>段存储的是age的值12。</p>
<p><code>a0 80 e1 07 01 00 00 00</code>段存储的是name的值Sunny。</p>
<p>计算机里面分大端模式、小端模式，不同的端读取数据的方式不一样，在iOS里面 是按照【小端模式】的方式读取数据，【小端模式】即是从<label style="color:red"><strong>地址较大的位置</strong></label>开始读取 比如<code>0c 00 00 00 00 00 00 00</code>段读取就是：0x0000000c = 12。</p>
<p><label style="color:red"><strong>注意</strong>：</label>结构体的大小必须是最大成员大小的【倍数】，比如上面的例子中class_getInstanceSize的值为24而不是20。</p>
<div class="note green no-icon flat"><p>class_getInstanceSize：至少需要的内存大小 值大于等于16 并且是8的倍数</p>
<p>malloc_size：实际分配的内存大小  必须是16的倍数</p>
</div>
<div class="note pink no-icon flat"><p>一些基本数据类型占用的字节数：</p>
<p>BOOL：1位</p>
<p>int：4位</p>
<p>float：4位</p>
<p>double：8位</p>
<p>NSInteger：8位</p>
<p>NSUIteger：8位</p>
<p>CGFloat：8位</p>
</div>
<p><code>sizeof</code>可以得出某种数据类型所占的字节数:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">size_t BOOL_ByteCount = <span class="keyword">sizeof</span>(<span class="type">BOOL</span>);</span><br><span class="line">size_t <span class="built_in">NSInteger_ByteCount</span> = <span class="keyword">sizeof</span>(<span class="built_in">NSInteger</span>);</span><br></pre></td></tr></table></figure>
<h3 id="其他总结">其他总结</h3>
<div class="note green no-icon flat"><p>1、一个实例对象的内存里面为什么不存储方法而是只存储了成员变量？</p>
<p>方法是相同的 只需要存储一份即可，存储在【类对象】的方法列表里面，成员变量可以有不同的值所以需要存储在实例对象的内存里面。</p>
<p>2、<code>sizeof</code>是在编译阶段就需要确认的 是个运算符。</p>
<p>3、内存对齐是为了提高CPU的访问速度。</p>
</div>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】方法缓存cache_t的分析</title>
    <url>/posts/39324100/</url>
    <content><![CDATA[<h2 id="写在前面-26">写在前面</h2>
<p>本文我们主要来分析一下方法缓存<code>cache_t</code>的数据结构是什么样的，苹果是怎么实现方法缓存的。</p>
<h2 id="Class的结构">Class的结构</h2>
<p>在<a href="!https://codersunny.com/posts/b55a18a8/">【iOS重学】窥探Class的结构</a>文中，我们主要分析了<code>Class</code>的结构，结构主要如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">  Class isa; <span class="comment">// isa</span></span><br><span class="line">  Class superclass; <span class="comment">// superclass</span></span><br><span class="line">  cache_t cache; <span class="comment">// 方法缓存</span></span><br><span class="line">  class_data_bits_t bits; <span class="comment">// 具体的类信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>isa</code>、<code>superclass</code>、<code>bits</code>我们都已经讲过了，相关的文章可以参考<a href="!https://codersunny.com/posts/9efafc5a/">【iOS重学】详细分析isa和superclass</a>和<a href="!https://codersunny.com/posts/8948fead/">【iOS重学】class_rw_ext_t结构详解</a>，现在我们就来主要分析一下方法缓存<code>cache_t</code>。</p>
<h2 id="方法缓存cache-t">方法缓存cache_t</h2>
<p>我们都知道查找一个方法的流程大概是：根据<code>isa</code>指针找到类对象，在类对象上找是否有对应的方法，如果没有找到就根据<code>superclass</code>指针找到其父类查看是否有方法实现，以此往上找：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1221/2.png" alt="2"></p>
<p>但是如果每次都这么寻找，效率肯定会很低，所以苹果就有自己的一套方法缓存机制，调用过的方法我们会缓存起来方便下次调用提高效率。</p>
<h3 id="cache-t结构">cache_t结构</h3>
<p>方法缓存<code>cache_t</code>结构如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1221/1.png" alt="1"></p>
<p>主要结构我们可以看成如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cache_t</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cache_t</span> &#123;</span><br><span class="line">	explicit_atomic&lt;<span class="type">mask_t</span>&gt; _maybeMask; <span class="comment">// 散列表的长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __LP64__</span></span><br><span class="line">  <span class="type">uint16_t</span>                _flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">uint16_t</span>                _occupied; <span class="comment">// 已缓存的方法数量</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">bucket_t</span> *<span class="built_in">buckets</span>() <span class="type">const</span>; <span class="comment">// 散列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucket_t</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bucket_t</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __arm64__</span></span><br><span class="line">    explicit_atomic&lt;<span class="type">uintptr_t</span>&gt; _imp;</span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line">    explicit_atomic&lt;<span class="type">uintptr_t</span>&gt; _imp;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="苹果如何实现方法缓存">苹果如何实现方法缓存</h3>
<p>苹果是利用【散列表】来存储曾经调用过的方法，这样可以提高方法的查找速度。</p>
<p>散列表的结构如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1221/3.png" alt="3"></p>
<p>方法缓存的基本步骤为：</p>
<ul>
<li>通过<code>SEL &amp; _maybeMask</code>得到方法在散列表里面对应的索引值<code>index</code>。</li>
<li>调用方法的时候通过<code>index</code>放在散列表的具体位置。</li>
</ul>
<h3 id="具体场景">具体场景</h3>
<p>我们这里列举一个具体的例子并结合方法缓存的底层代码来详细说明整个过程。</p>
<p>首先我们根据底层源码来仿照写一个方法缓存的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ww_bucket_t</span> &#123;<span class="comment">// 相当于bucket_t</span></span><br><span class="line">    SEL _sel;</span><br><span class="line">    IMP _imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ww_cache_t</span> &#123;<span class="comment">// 相当于cache_t</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ww_bucket_t</span>  *buckets;</span><br><span class="line">    <span class="type">uint32_t</span>            _maybeMask;</span><br><span class="line">    <span class="type">uint16_t</span>            _flags;</span><br><span class="line">    <span class="type">uint16_t</span>            _occupied;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ww_class_data_bits_t</span> &#123;<span class="comment">// 相当于class_data_bits_t</span></span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ww_objc_class</span>&#123;<span class="comment">// 相当于objc_class</span></span><br><span class="line">    Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">ww_cache_t</span> cache;</span><br><span class="line">    <span class="type">ww_class_data_bits_t</span> bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体的场景代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">Class personClass = [Person <span class="keyword">class</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ww_objc_class *ww_class = (__bridge <span class="keyword">struct</span> ww_objc_class *)(personClass);</span><br><span class="line">uint32_t index1 = ((<span class="type">long</span> <span class="type">long</span>)<span class="keyword">@selector</span>(init) &amp; ww_class-&gt;cache._maybeMask);</span><br><span class="line"><span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; ww_class-&gt;cache._maybeMask; i++) &#123;</span><br><span class="line">    <span class="keyword">struct</span> ww_bucket_t bucket = ww_class-&gt;cache.buckets[i];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;索引值：%u - SEL：%@ - IMP：%p&quot;</span>,i, <span class="built_in">NSStringFromSelector</span>(bucket._sel),bucket._imp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;已缓存的方法个数：%hu - 散列表实际长度：%u &quot;</span>,ww_class-&gt;cache._occupied,ww_class-&gt;cache._maybeMask);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">[person personTest];</span><br><span class="line">uint32_t index2 = ((<span class="type">long</span> <span class="type">long</span>)<span class="keyword">@selector</span>(personTest) &amp; ww_class-&gt;cache._maybeMask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; ww_class-&gt;cache._maybeMask; i++) &#123;</span><br><span class="line">    <span class="keyword">struct</span> ww_bucket_t bucket = ww_class-&gt;cache.buckets[i];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;索引值：%u - SEL：%@ - IMP：%p&quot;</span>,i, <span class="built_in">NSStringFromSelector</span>(bucket._sel),bucket._imp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;已缓存的方法个数：%hu - 散列表实际长度：%u &quot;</span>,ww_class-&gt;cache._occupied,ww_class-&gt;cache._maybeMask);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;--------------------------&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.814393</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 索引值：<span class="number">0</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815222</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 索引值：<span class="number">1</span> - SEL：init - IMP：<span class="number">0x7fe150</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815306</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 索引值：<span class="number">2</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815359</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 已缓存的方法个数：<span class="number">1</span> - 散列表实际长度：<span class="number">3</span> </span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815406</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] ----------------------</span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815450</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] -[Person personTest]</span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815493</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 索引值：<span class="number">0</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815646</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 索引值：<span class="number">1</span> - SEL：init - IMP：<span class="number">0x7fe150</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815704</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 索引值：<span class="number">2</span> - SEL：personTest - IMP：<span class="number">0xbbb0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815753</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 已缓存的方法个数：<span class="number">2</span> - 散列表实际长度：<span class="number">3</span> </span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815794</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] --------------------------</span><br></pre></td></tr></table></figure>
<p>对照源码来分析一下这个打印结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cache_t::insert</span><span class="params">(SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...... <span class="comment">// 此处省略了一些无关代码</span></span><br><span class="line">  <span class="type">mask_t</span> newOccupied = <span class="built_in">occupied</span>() + <span class="number">1</span>; <span class="comment">// 记录新的缓存方法数量</span></span><br><span class="line">  <span class="type">unsigned</span> oldCapacity = <span class="built_in">capacity</span>(), capacity = oldCapacity;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">isConstantEmptyCache</span>())) &#123; <span class="comment">// 第一次进来缓存为空的</span></span><br><span class="line">      <span class="keyword">if</span> (!capacity) capacity = INIT_CACHE_SIZE; <span class="comment">// 计算申请空间的大小</span></span><br><span class="line">      <span class="built_in">reallocate</span>(oldCapacity, capacity, <span class="comment">/* freeOld */</span><span class="literal">false</span>); <span class="comment">// 申请空间</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">fastpath</span>(newOccupied + CACHE_END_MARKER &lt;= <span class="built_in">cache_fill_ratio</span>(capacity))) &#123; <span class="comment">// 已经开辟的空间还没有缓存满 可以继续缓存</span></span><br><span class="line">      <span class="comment">// Cache is less than 3/4 or 7/8 full. Use it as-is.</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CACHE_ALLOW_FULL_UTILIZATION</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (capacity &lt;= FULL_UTILIZATION_CACHE_SIZE &amp;&amp; newOccupied + CACHE_END_MARKER &lt;= capacity) &#123;</span><br><span class="line">      <span class="comment">// Allow 100% cache utilization for small buckets. Use it as-is.</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 已经开辟的空间已经缓存满了 进行双倍扩容</span></span><br><span class="line">      capacity = capacity ? capacity * <span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line">      <span class="keyword">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">          capacity = MAX_CACHE_SIZE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">reallocate</span>(oldCapacity, capacity, <span class="literal">true</span>); <span class="comment">// 开辟新的缓存空间</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bucket_t</span> *b = <span class="built_in">buckets</span>();<span class="comment">// 取出方法缓存列表buckets</span></span><br><span class="line">  <span class="type">mask_t</span> m = capacity - <span class="number">1</span>; <span class="comment">// 计算散列表实际的长度maybemask</span></span><br><span class="line">  <span class="type">mask_t</span> begin = <span class="built_in">cache_hash</span>(sel, m); <span class="comment">// 使用散列表计算插入的位置</span></span><br><span class="line">  <span class="type">mask_t</span> i = begin; <span class="comment">// i表示插入的位置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">fastpath</span>(b[i].<span class="built_in">sel</span>() == <span class="number">0</span>)) &#123; <span class="comment">// 如果插入的位置是空的 表示可以插入 在当前索引值处插入该方法</span></span><br><span class="line">          <span class="built_in">incrementOccupied</span>();</span><br><span class="line">          b[i].<span class="built_in">set</span>&lt;Atomic, Encoded&gt;(b, sel, imp, <span class="built_in">cls</span>());</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (b[i].<span class="built_in">sel</span>() == sel) &#123; <span class="comment">// 判断其他线程是否缓存过该方法</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">fastpath</span>((i = <span class="built_in">cache_next</span>(i, m)) != begin)); <span class="comment">// 如果i位置没有插入成功 通过cache_next找下一个可以插入的位置</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">bad_cache</span>(receiver, (SEL)sel);<span class="comment">// 如果do/while循环走完了都没有找到可以插入的位置就缓存失败</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子分析：</p>
<ul>
<li>
<p>当调用方法<code>init</code>的时候，会调用到上面的源码<code>cache_t::insert</code>方法，此时新的已缓存的方法数<code>newOccupied == 1</code> ，容量<code>capacity == 0</code>。</p>
</li>
<li>
<p>因为是第一次进来所以之前没有缓存会调用到<code>slowpath(isConstantEmptyCache()</code>里面。</p>
</li>
<li>
<p>去计算散列表容量<code>capacity</code>的大小：<code>capacity = INIT_CACHE_SIZE</code>。</p>
<div class="note green no-icon flat"><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1221/4.png" alt="4"></p>
<p><code>INIT_CACHE_SIZE</code>是1向左移动<code>INIT_CACHE_SIZE_LOG2</code>位，那就是4，所以<code>capacity</code>的值为4。</p>
</div>
</li>
<li>
<p>调用<code>reallocate</code>方法去申请空间。</p>
</li>
<li>
<p>根据我们上面讲到的散列表的索引值计算方式<code>cache_hash(sel, m)</code>去获取<code>init</code>方法在散列表里面的索引值<code>begin</code>。</p>
</li>
<li>
<p>如果散列表当前位置是空的可以插入就把<code>init</code>方法插入到当前位置。</p>
</li>
</ul>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1221/5.png" alt="5"></p>
<p>调用<code>init</code>时，我们根据方法缓存散列表索引值的计算方式看到<code>init</code>方法的索引值为：1，然后看打印结果:</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1221/6.png" alt="6"></p>
<p>索引值为1的位置确实缓存的是我们刚调用的<code>init</code>方法。</p>
<p>同理当调用<code>personTest</code>时，我们根据方法缓存散列表计算索引值的计算方式看到<code>personTest</code>方法的索引值为：2，然后对照打印结果索引值为2的位置确实缓存的是<code>personTest</code>方法。</p>
<p>现在我们继续调用<code>personTest1</code>方法，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[person personTest1];</span><br><span class="line">uint32_t index3 = ((<span class="type">long</span> <span class="type">long</span>)<span class="keyword">@selector</span>(personTest1) &amp; ww_class-&gt;cache._maybeMask);</span><br><span class="line"><span class="comment">//        [person personTest2];</span></span><br><span class="line"><span class="comment">//        [person personTest3];</span></span><br><span class="line"><span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; ww_class-&gt;cache._maybeMask; i++) &#123;</span><br><span class="line">    <span class="keyword">struct</span> ww_bucket_t bucket = ww_class-&gt;cache.buckets[i];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;索引值：%u - SEL：%@ - IMP：%p&quot;</span>,i, <span class="built_in">NSStringFromSelector</span>(bucket._sel),bucket._imp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;已缓存的方法个数：%hu - 散列表实际长度：%u &quot;</span>,ww_class-&gt;cache._occupied,ww_class-&gt;cache._maybeMask);</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.509028</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] -[Person personTest1]</span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515237</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 索引值：<span class="number">0</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515293</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 索引值：<span class="number">1</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515343</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 索引值：<span class="number">2</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515390</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 索引值：<span class="number">3</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515440</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 索引值：<span class="number">4</span> - SEL：personTest1 - IMP：<span class="number">0xba60</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515486</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 索引值：<span class="number">5</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515531</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 索引值：<span class="number">6</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515577</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 已缓存的方法个数：<span class="number">1</span> - 散列表实际长度：<span class="number">7</span> </span><br></pre></td></tr></table></figure>
<p>我们发现：已缓存的方法个数为1，散列表实际长度变成了7，我们发现之前缓存的方法被清空了并且扩容了，我们来对照源码来看一下它是不是该去扩容并且清空之前的缓存了。</p>
<p>在这里我们需要重点看一下已经开辟的空间是否缓存满的判断：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fastpath</span>(newOccupied + CACHE_END_MARKER &lt;= <span class="built_in">cache_fill_ratio</span>(capacity))</span><br></pre></td></tr></table></figure>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1221/7.png" alt="7"></p>
<p>当我们调用了<code>init</code>时候，<code>capacity</code>的值为4。</p>
<ul>
<li>
<p>当调用<code>personTest1</code>方法时候，我们要去根据<code>newOccupied + CACHE_END_MARKER &lt;= cache_fill_ratio(capacity)</code>来判断之前开辟的缓存空间是否还足够，<code>newOccupied == 3</code>，<code>CACHE_END_MARKER == 1</code>，显然缓存空间不够，所以我们需要进行扩容，那么<code>capacity == 8</code>。</p>
</li>
<li>
<p>调用<code>reallocate</code>去重新分配新的缓存空间，并且清空之前的缓存。</p>
<div class="note green no-icon flat"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cache_t::reallocate</span><span class="params">(<span class="type">mask_t</span> oldCapacity, <span class="type">mask_t</span> newCapacity, <span class="type">bool</span> freeOld)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bucket_t</span> *oldBuckets = <span class="built_in">buckets</span>();</span><br><span class="line">    <span class="type">bucket_t</span> *newBuckets = <span class="built_in">allocateBuckets</span>(newCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT</span>(newCapacity &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ASSERT</span>((<span class="type">uintptr_t</span>)(<span class="type">mask_t</span>)(newCapacity<span class="number">-1</span>) == newCapacity<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setBucketsAndMask</span>(newBuckets, newCapacity - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (freeOld) &#123;</span><br><span class="line">        <span class="built_in">collect_free</span>(oldBuckets, oldCapacity); <span class="comment">// 释放之前的缓存空间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>
</li>
<li>
<p>调用<code>personTest1</code>时，根据方法缓存散列表计算索引值的计算方式看到<code>personTest1</code>方法的索引值为：4,对照打印结果看到索引值为4的位置确实存放了<code>personTest1</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.334284</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 索引值：<span class="number">0</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.335782</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 索引值：<span class="number">1</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.335872</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 索引值：<span class="number">2</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.335940</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 索引值：<span class="number">3</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.336055</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 索引值：<span class="number">4</span> - SEL：personTest1 - IMP：<span class="number">0xb510</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.336156</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 索引值：<span class="number">5</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.336222</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 索引值：<span class="number">6</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.336292</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 已缓存的方法个数：<span class="number">1</span> - 散列表实际长度：<span class="number">7</span> </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>再调用<code>personTest2</code>、<code>personTest3</code>时，我们计算索引值分别为0、4，但是索引值为4的位置已经有内容了，所以我们会根据<code>cache_next</code>去找到合适的索引值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CACHE_END_MARKER</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">mask_t</span> <span class="title">cache_next</span><span class="params">(<span class="type">mask_t</span> i, <span class="type">mask_t</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i+<span class="number">1</span>) &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __arm64__</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">mask_t</span> <span class="title">cache_next</span><span class="params">(<span class="type">mask_t</span> i, <span class="type">mask_t</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i ? i<span class="number">-1</span> : mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据<code>(4+1) &amp; mask</code>得到<code>personTest3</code>的索引值为5，对照打印结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.305299</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 索引值：<span class="number">0</span> - SEL：personTest2 - IMP：<span class="number">0xb540</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.305390</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 索引值：<span class="number">1</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.317936</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 索引值：<span class="number">2</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.318011</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 索引值：<span class="number">3</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.318081</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 索引值：<span class="number">4</span> - SEL：personTest1 - IMP：<span class="number">0xb5b0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.318147</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 索引值：<span class="number">5</span> - SEL：personTest3 - IMP：<span class="number">0xb510</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.318214</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 索引值：<span class="number">6</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.318280</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 已缓存的方法个数：<span class="number">3</span> - 散列表实际长度：<span class="number">7</span></span><br></pre></td></tr></table></figure>
<h3 id="cache-t总结">cache_t总结</h3>
<p>方法缓存散列表其实就是利用空间来换时间，提高了方法查找的效率。</p>
<h2 id="写在最后-18">写在最后</h2>
<p>关于方法缓存的底层实现我们就写到这里了，希望对大家有所帮助，如有错误请多多指教。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】浅谈iOS的包体积优化（一）</title>
    <url>/posts/94e6df10/</url>
    <content><![CDATA[<h2 id="为什么要做包体积优化">为什么要做包体积优化</h2>
<p>随着应用的不断更新迭代，应用安装包的体积会越来越大，用户下载应用消耗流量产生的资费就会进一步增长，会导致用户下载意愿会相对下降。</p>
<p>随着包体积的不断增大，安装应用的时间变长会影响用户的使用感受，对于内存比较小的低端机型来说，应用解压后内存占用更大也会影响用户的使用。</p>
<p>苹果对iOS APP 大小有严格的限制，虽然苹果官方也一直在提高可执行文件的上限，在iOS13 还取消了强制的OTA限制，但是下载大小超过200MB的会默认请求用户下载许可，并且在iOS13以下的设备依然会受到OTA的限制，影响新用户转化和老用户的更新。</p>
<p>苹果对可执行文件大小有明确的限制，超过该限制可能会APP审核被拒。</p>
<div class="note green no-icon flat"><p><strong>具体的限制如下：</strong></p>
<p>1、iOS7 之前，二进制文件中所有的__TEXT段总和不得超过80MB</p>
<p>2、iOS7.x - iOS 8.x，二进制文件中，每个特定架构中的__TEXT段不得超过60MB</p>
<p>3、iOS9 之后，二进制文件中所有的__TEXT段总和不得超过500MB</p>
</div>
<p>所以，为了更好的用户体验和减少用户等待的时间，包体积优化都是APP优化中非常重要的一环。</p>
<h2 id="IPA安装包分析">IPA安装包分析</h2>
<h3 id="相关知识">相关知识</h3>
<p>【APP原始包体积】：上传前ipa解包后，实际App的大小</p>
<p>【下载大小】：App压缩包（.ipa文件）所占用的空间，用户在App Store下载应用时下载的是压缩包，这么做可以节省流量。</p>
<p>【安装大小】：当压缩包下载完成之后就会自动解压（这个解压过程也就是我们看到的安装过程），安装大小就是指压缩包解压之后所占用的空间。</p>
<p>【APP原始包体积】：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202208/0810/1.png" alt="1"></p>
<p>【下载大小】：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/2.png" alt="2"></p>
<p>【安装大小】：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/3.png" alt="3"></p>
<h3 id="安装大小和下载大小是如何生成的">安装大小和下载大小是如何生成的</h3>
<p>App的ipa包上传到苹果后台后，苹果会对上传的ipa包解包后，对二进制进行了DRM加密（这个加密过程会导致包体积增大）和App Thinning，App Thinning会根据不同的机型对原始包的资源和代码进行不同程度的裁剪，从而生成适配具体机型的版本，下图是借用网友整理的一张图来描述iOS APP的包的生成过程：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/4.png" alt="4"></p>
<h3 id="安装包的构成">安装包的构成</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/5.png" alt="5"></p>
<h3 id="松果出行安装包现状分析">松果出行安装包现状分析</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/6.png" alt="6"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/7.png" alt="7"></p>
<h2 id="包体积的优化方案">包体积的优化方案</h2>
<h3 id="Xcode编译设置">Xcode编译设置</h3>
<p>一般这一步比较容易被忽略，因为提到优化大家最先想到的就是资源优化，比如：图片压缩、无用代码删除等，对Xcode自身的编译优化提及的反而不多，而且有的设置需要针对与实际项目结合起来才可以，比如：去掉断点调试、异常支持等。</p>
<h4 id="Build-Settings去掉异常支持">Build Settings去掉异常支持</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/8.png" alt="8"></p>
<h4 id="Build-Settings-Architectures设置">Build Settings -&gt; Architectures设置</h4>
<p>Architetures 可以指定工程被编译成可支持哪些指令集类型，支持的指令集越多就会编译出越多个指令集的代码包，也就会导致ipa包变大，默认的standrad architetures（armv7，arm64）参数打的包里面有32位、64位两份指令集，根据是否需要32位来选择是否更改指令集。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/9.png" alt="9"></p>
<p>修改设置后，ipa包体积大小变化：<strong>78.1MB -&gt; 55.1MB</strong></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/10.png" alt="10"></p>
<h4 id="Build-Settings不生成调试符号">Build Settings不生成调试符号</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/11.png" alt="11"></p>
<h4 id="Build-Settings-Development-PostProcessing设置">Build Settings -&gt; Development PostProcessing设置</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/12.png" alt="12"></p>
<h4 id="Build-Settings-Make-Strings-Read-Only设置为YES（默认）">Build Settings -&gt; Make Strings Read-Only设置为YES（默认）</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/13.png" alt="13"></p>
<h4 id="Build-Settings-Dead-Code-Stripping设置为YES（默认）">Build Settings -&gt; Dead Code Stripping设置为YES（默认）</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/14.png" alt="14"></p>
<h4 id="Pod优化">Pod优化</h4>
<p>如果项目是OC但是使用了Swift三方库，可以针对单个Swift库使用 use_frameworks！而不是全部第三方库都使用。</p>
<p>在OC项目中使用Swift库 直接使用use_frameworks！会导致Pod中所有的库都会打成动态库，以及Swift和OC库的依赖问题会导致依赖库增加从而造成ipa包体积增大。</p>
<h4 id="Asset-Catalog-Compiler编译设置优化">Asset Catalog Compiler编译设置优化</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/15.png" alt="15"></p>
<p>Xcode内置的actool使用打压缩算法包括： lzfse、 palette_img、 deepmap2、 deepmap_lzfse、zip，具体使用哪种算法跟iOS系统版本、Asset Catalog Compiler 中Optimization配置有关。</p>
<p>iOS 11.x：对应算法是 lzfse、zip</p>
<p>iOS 12.x - iOS 12.4.x：对应算法是 deepmap_lzfse、palette_img</p>
<p>iOS 13.x：对应算法是 deepmap2</p>
<p><strong>注意</strong>：CocoaPods管理库中的Assets catalog的编译过程在CocoaPods生成的Copy Pods Resources这个脚本里面，所以上面的设置对Pod库组件无效。</p>
<h4 id="Build-Settings-Optimization-Level-改为-Oz">Build Settings -&gt; Optimization Level 改为-Oz</h4>
<p>Optimization Level默认为-Os，-Oz是Xcode 11之后才出现的编译优化选项，核心原理是对重复的连续机器指令外联成函数进行复用，因此开启Oz，能减少二进制的大小，但同时会带来执行效率的额外消耗。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/16.png" alt="16"></p>
<h4 id="Build-Settings-Link-Time-Optimization设置为Incremental">Build Settings -&gt; Link-Time Optimization设置为Incremental</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/17.png" alt="17"></p>
<p>苹果在2016年的WWDC What’s new in LLVM 中详细介绍了这个功能，LTO能带来的优化有：</p>
<div class="note green no-icon flat"><p>将一些函数内联化：不用进行调用函数前的压栈、调用函数后的出栈操作，提高运行效率和栈空间的利用率。</p>
<p>去除一些无用代码</p>
<p>对程序有全局的优化作用：比如if方法下的某个分支永远不会执行，那么在生成的二进制文件里面就不应该包含这部分代码。</p>
</div>
<p>另外苹果还称LTO对app的运行速度也有正向的帮助，但是会降低LTO的编译链接的速度，因此只建议在打正式包时设置改选项，同时也会导致link map的可读性明显降低。</p>
<h4 id="Build-Settings-Enable-On-Demand-Resources设置为YES（默认）">Build Settings -&gt; Enable On Demand Resources设置为YES（默认）</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/18.png" alt="18"></p>
<h3 id="Xcode编译设置优化总结">Xcode编译设置优化总结</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/19.png" alt="19"></p>
<h3 id="资源文件优化">资源文件优化</h3>
<p>资源文件的优化是需要持续进行的，在前面咱们提到的Xcode编译优化设置配置好之后后续的开发只要不修改配置不需要过分关注。但是资源文件优化不同，随着项目的不断更新迭代会不断引入新的资源文件，同时也会不断有废弃资源的文件产生，因此资源优化是要持续进行的。</p>
<p>资源文件的优化分为两步：无用资源的删除 和 已用资源的压缩。</p>
<h4 id="无用资源的删除">无用资源的删除</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/20.png" alt="20"></p>
<h4 id="图片资源的清理">图片资源的清理</h4>
<p>使用【LSUnusedResources】工具检测没有用到的图片资源，确认后进行删除。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/21.png" alt="21"></p>
<h4 id="重复资源的引入">重复资源的引入</h4>
<p>检查项目中是否有功能类似的SDK，建议只保留一个，另外有些三方库引入时可以只引入实际使用的部分不需要全量引入。</p>
<p>使用【fdupes】工具进行重复文件的扫描，仅保留一份即可。</p>
<div class="note green no-icon flat"><p>fdupes工具的安装和使用：</p>
<p>brew install fdupes</p>
<p>fdupes -Sr /Users/sunny/Desktop/TTPinecone &gt; /Users/sunny/Desktop/fdupesResult.txt</p>
</div>
<h4 id="未用到的类、方法的清理">未用到的类、方法的清理</h4>
<h3 id="已用资源的压缩">已用资源的压缩</h3>
<p>项目中引入的图片、网页、json、音频等文件的压缩，这里主要了解一下图片的压缩。</p>
<p><strong>Build Settings -&gt; Compress PNG Files</strong> <strong>设置为</strong> <strong>YES</strong> <strong>（默认）</strong></p>
<p>表示打包的时候自动对图片进行无损压缩。</p>
<p><strong>注意</strong>：该选项对Assets中的资源无效 只对零散的资源文件。</p>
<p><strong>Build Settings -&gt; Remove Text Metadata From PNG Files</strong> <strong>设置为****YES</strong> <strong>（默认）</strong></p>
<p>表示移除PNG资源的文本字符。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/22.png" alt="22"></p>
<p><strong>resources</strong></p>
<p>把资源文件都打包直接copy到framework的根目录下。</p>
<p><strong>注意</strong>：如果Pod里面没有使用use_frameworks!不会生成对应的Framework的，则是直接把资源文件copy到app的根目录下。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/23.png" alt="23"></p>
<p><strong>resource_bundles</strong></p>
<p>CocoaPods 官方强烈建议使用resource_bundles，这样可以避免相同名称资源的名称冲突，使用resource_bundles会为指定的资源打一个.bundle资源包。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/24.png" alt="24"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/25.png" alt="25"></p>
<h4 id="单色图标、功能简单的图标可以使用IconFont矢量图标库的方式">单色图标、功能简单的图标可以使用IconFont矢量图标库的方式</h4>
<h4 id="普通图片可以使用-tinypng来进行压缩">普通图片可以使用 <a href="https://tinypng.com/"><strong>tinypng</strong></a>来进行压缩</h4>
<h4 id="尽量使用xcassets来存放图片资源">尽量使用xcassets来存放图片资源</h4>
<p>放入xcassets的2x和3x图片在上传时会根据具体设备分开对应分辨率的图片，不会同时包含。而放入.bundle中的都会包含，所以建议把图片放在xcassets里面管理。</p>
<div class="note green no-icon flat"><p><strong>注意</strong>：</p>
<ol>
<li>Assets.car在编译过程中会选择一些小图片拼凑成一张大图来提高图片的加载效率，被放进这张大图的小图会通过偏移量的引用。建议使用频率高且小的图片放到Assets.car里面，Assets.car能保证加载和渲染速度最优。</li>
<li>大图（大于100KB的图片）就不要放到Assets里面，考虑使用WebP格式，这个格式可以将图片压缩到最小。但是WebP在CPU消耗和解码上是PNG的2倍，所以我们需要在性能和体积上做取舍。</li>
</ol>
</div>
<h4 id="Xcode中关于图片压缩的设置">Xcode中关于图片压缩的设置</h4>
<p>有时候压缩了图片发现ipa包并没有改变太多，原因大概是：</p>
<div class="note green no-icon flat"><p>因为Xcode的Compress PNG Files选项的原因，建议如果自己压缩图片就把该项设置设置为NO。</p>
<p>Xcode 在构建过程中有一个步骤叫compile assets catalog，Xcode会用自己的算法自行对png做图片压缩，并且会压缩成能够快速读取渲染的格式。</p>
</div>
<h3 id="资源文件优化总结">资源文件优化总结</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20221102/26.png" alt="26"></p>
<h2 id="优化总结">优化总结</h2>
<p>是不是项目变大了做包体积优化才有意义？</p>
<p>绝对不是，包体积优化应该是一种习惯而不是等到包体积变得很大了才去思考做优化，应该是只要觉得有优化的空间就去做优化。</p>
<p>如果打出来的ipa包比较小，说明我们的历史负担不严重，俗话说船小好掉头而且编译的速度也快，试错成本也低，恰恰才是该优化的时候，优化总结出来的教训落地到文档形成一种规范，后续开发时也能时刻引起注意，这样对于开发来说是最好的。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】浅谈iOS的包体积优化（二）</title>
    <url>/posts/a2dbd15f/</url>
    <content><![CDATA[<h2 id="LinkMap分析可执行文件">LinkMap分析可执行文件</h2>
<h3 id="LinkMap结构分析">LinkMap结构分析</h3>
<h4 id="基础信息">基础信息</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1104/1.png" alt="1"></p>
<h4 id="类表">类表</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1104/2.png" alt="2"></p>
<div class="note green no-icon flat"><p>里面保存的是所有用到的类生成的.o文件，也包括用到的dylib库。[num]指的是序号，类是按照顺序保存的，后续可以通过序号查到具体对应的哪个类。</p>
</div>
<h4 id="段表">段表</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1104/3.png" alt="3"></p>
<div class="note green no-icon flat"><p>段表里面描述了不同功能的数据保存地址，通过这个地址可以查到对应内存里面存储的是什么数据。</p>
<p>第一列：起始地址</p>
<p>第二列：段占用的大小</p>
<p>第三列：段类型</p>
<p>第四列：段名称</p>
<p>每一行初始地址 = 上一行处始地址 + 占用大小</p>
</div>
<p>__TEXT：代码段</p>
<p>__DATA：数据段</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1104/4.png" alt="4"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1104/5.png" alt="5"></p>
<h4 id="后续符号表内容">后续符号表内容</h4>
<p><strong>代码节</strong></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1104/6.png" alt="6"></p>
<div class="note green no-icon flat"><p>第一列：起始地址 通过这个地址可以查上面的段表</p>
<p>第二列：方法占用的大小 通过这个可以计算出方法占用的大小</p>
<p>第三列：归属的类</p>
<p>通过这部分我们可以分析出每个类对应的方法的大小。</p>
</div>
<p><strong>方法名节</strong></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1104/7.png" alt="7"></p>
<div class="note green no-icon flat"><p>这部分保存的是：类中方法的字符串信息</p>
</div>
<p><strong>如何分析</strong></p>
<p>查看第一列初始位置 比如<code>0x1016FF830</code> 然后看这个地址在【段表】中的哪个节里面 我们这里看到是在<code>__objc_methodname</code>里面。</p>
<h3 id="分析LinkMap的工具">分析LinkMap的工具</h3>
<p><a href="https://github.com/jayden320/LinkMap">LinkMap分析工具</a></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1104/8.png" alt="8"></p>
<h2 id="TEXT代码段迁移方案">__TEXT代码段迁移方案</h2>
<h3 id="Mach-O文件格式简介">Mach-O文件格式简介</h3>
<p>可执行文件中<code>Data</code>部分主要是以<code>Segment（段）</code>和<code>Section（节）</code>的方式来组织内容，使用命令<code>xcrun size -lm</code>可执行文件路径 来详细查看<code>Data</code>部分的结构和<code>Segment/Section</code>的大小信息。</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1104/9.png" alt="9"></p>
<p><code>Data</code>有四个<code>Segment</code>：<code>__PAGEZERO</code>、<code>__TEXT</code>、<code>__DATA</code>、<code>__LINKEDIT</code>，除了<code>__PAGEZERO</code>、<code>__LINKEDIT</code>，每个段中有多个<code>Section</code>。</p>
<p><code>__PAGEZERO</code>：大小是4G，指的是可执行文件装载进内存后，<code>__PAGEZERO</code>在内存中的大小，主要是用来捕捉<code>NULL</code>指针的引用。<code>__PAGEZERO</code>在可执行文件中并不占用<code>Data</code>部分的空间。</p>
<p><code>__TEXT</code>、<code>__DATA</code>：用于保存程序的代码指令和数据。</p>
<p><code>__LINKEDIT</code>：包含App启动需要的信息，比如代码签名符号表等。</p>
<h3 id="TEXT段迁移的原理">__TEXT段迁移的原理</h3>
<p>程序的过程主要有：预处理 - 编译 - 汇编 - 链接 四个主要阶段，完成之后就可以得到Mach-O可执行文件。</p>
<div class="note green no-icon flat"><p>苹果要求：</p>
<p>iOS7 之前，二进制文件中所有的__TEXT段总和不得超过80MB</p>
<p>iOS7.x - iOS 8.x，二进制文件中，每个特定架构中的__TEXT段不得超过60MB</p>
<p>iOS9 之后，二进制文件中所有的__TEXT段总和不得超过500MB</p>
</div>
<p>苹果只会扫描<code>__TEXT</code>段，所以我们的想法是迁移<code>__TEXT</code>段就可以避免上面的问题，这个方案在国内很大大型APP上其实也是比较常见的。</p>
<h3 id="迁移-TEXT会减少下载大小的原理">迁移__TEXT会减少下载大小的原理</h3>
<p>苹果会对APP中的可执行文件进行DRM加密，然后将APP压缩成ipa文件再发布到App Store，加密对可执行文件大小本身影响比较小，它影响的是可执行文件的压缩效率，导致压缩后的ipa大小增加也就是下载大小增大。</p>
<p>使用命令【otool -l 可执行文件路径】来查看可执行文件是否被加密过：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1104/10.png" alt="10"></p>
<p>苹果只会对可执行文件中的<code>__TEXT</code>段加密，而不会对其他段加密。所以我们可以想到如果可以把<code>__TEXT</code>段中的节移到其它段，就能减少苹果的加密范围，从而使压缩效率提升减少下载大小。</p>
<div class="note orange no-icon flat"><p><strong>一般来说</strong>：</p>
<p>APP中可执行文件占80%的大小，加密内容占可执行文件大小的70%，加密会影响60%的压缩率，因此移走该加密部分可以提升34%的下载大小。</p>
<p><code>__TEXT</code>段迁移方案只适用于iOS13以下的设备，苹果本身已经对iOS13以上的设备做了进一步的优化。</p>
</div>
<h3 id="迁移-TEXT段具体方案">迁移__TEXT段具体方案</h3>
<p>通过命令<code>man ld</code>可以查看链接器参数，如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1104/11.png" alt="11"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1104/12.png" alt="12"></p>
<p><code>-rename _section</code>：<code>orgSegment/orgSection</code>的名称修改为<code>newSegment/newSection</code></p>
<p><code>-segprot</code>：为<code>Segment</code>添加读、写、可执行权限等</p>
<p>在 <code>Xcode - Build Settings - Other Linker Flags</code>中添加如下参数：</p>
<div class="note green no-icon flat"><p><code>-Wl,-rename_section,__TEXT,__stubs,__TT_TEXT,__stubs</code></p>
<p><code>-Wl,-rename_section,__TEXT,__text,__TT_TEXT,__text</code></p>
<p><code>-Wl,-rename_section,__TEXT,__const,__RODATA,__const</code></p>
<p><code>-Wl,-rename_section,__TEXT,__gcc_except_tab,__RODATA,__gcc_except_tab</code></p>
<p><code>-Wl,-rename_section,__TEXT,__objc_methtype,__RODATA,__objc_methtype</code></p>
<p><code>-Wl,-rename_section,__TEXT,__objc_classname,__RODATA,__objc_classname</code></p>
<p><code>-Wl,-rename_section,__TEXT,__objc_methname,__RODATA,__objc_methname</code></p>
<p><code>-Wl,-rename_section,__TEXT,__cstring,__RODATA,__cstring</code></p>
<p><code>-Wl,-segprot,__TT_TEXT,rx,rx</code></p>
<p><strong>注意</strong>：以上添加的参数是博主针对自己的项目做的一些添加 各位一定要根据自己项目的实际情况去做相应的添加。</p>
</div>
<p><strong>解释</strong>：</p>
<p>-Wl 是告诉Xcode 后面的参数是添加给链接器ld的，这些参数在链接阶段生效。</p>
<p>第一行参数：创建一个新的<code>__TT_TEXT</code>段，并把<code>__TEXT</code>,<code>__text</code>移动到<code>__TT_TEXT</code>,<code>__text</code>。</p>
<p>第一行参数：创建一个新的<code>__TT_TEXT</code>段，并把<code>__TEXT</code>,<code>__text</code>移动到<code>__TT_TEXT</code>,<code>__text</code>。</p>
<p>第二行参数：给<code>__TT_TEXT</code>段添加可读和可执行权限。</p>
<p>使用命令<code>xcrun size -lm 可执行文件路径</code>可以查看可执行文件的Data内容，如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1104/13.png" alt="13"></p>
<p>通过上面的截图我们会发现：<code>Data</code>里面会多了我们创建的<code>__TT_TEXT</code>和<code>__RODATA</code>两个<code>Segment</code>,原本的<code>__TEXT</code>和<code>__DATA</code>的大小也会发生变化，至此，关于<code>__TEXT</code>段具体如何迁移我们就简单的了解到这里了，本文也只是博主的一个学习笔记，如各位看官发现有任何问题请指正 在此感激不尽。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】消息发送的完整流程</title>
    <url>/posts/4a47f2ea/</url>
    <content><![CDATA[<h2 id="写在前面-27">写在前面</h2>
<p>​	在OC里面，调用对象的某个方法其实就是给这个对象发送一个消息，这个过程我们把它分为三大阶段，分别为：消息发送阶段、动态解析阶段、消息转发阶段，本文将细细剖析这三个阶段，但是在剖析这三大阶段之前我们需要先回顾一下Class的结构。</p>
<h2 id="Class结构">Class结构</h2>
<p>苹果源码最新下载地址请点击：<a href="https://opensource.apple.com/tarballs/objc4/">苹果源码</a><br>
在<code>objc-runtime-new.h</code>中可以看到<code>objc_class</code>结构如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">      Class superclass; </span><br><span class="line">      cache_t cache;  <span class="comment">// 方法缓存</span></span><br><span class="line">      class_data_bits_t bits; <span class="comment">// 获取具体类信息</span></span><br><span class="line">    ...... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的结构我们可以看到有一个类<code>cache_t</code>，这个类就是专门拿来做方法缓存相关的类，结构如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    <span class="keyword">struct</span> bucket_t *buckets();</span><br><span class="line">    uint16_t _occupied();</span><br><span class="line">    mask_t _maybeMask;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> bucket_t &#123;</span><br><span class="line">    SEL _sel;</span><br><span class="line">    IMP _imp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>class_data_bits_t</code>用于获取具体的类信息，结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">class_data_bits_t</span> &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readWrite：可读可写</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">class_rw_t</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> witness;</span><br><span class="line">  	Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    <span class="type">class_rw_ext_t</span> *ext;</span><br><span class="line">    <span class="type">const</span> <span class="type">class_ro_t</span> *ro;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">class_rw_ext_t</span> &#123;</span><br><span class="line">  <span class="type">class_ro_t</span> *ro;</span><br><span class="line">  <span class="type">method_array_t</span> methods;<span class="comment">// 方法列表</span></span><br><span class="line">  <span class="type">property_array_t</span> properties; <span class="comment">// 属性列表</span></span><br><span class="line">  <span class="type">protocol_array_t</span> protocols; <span class="comment">// 协议列表</span></span><br><span class="line">  <span class="type">char</span> *demangledName;</span><br><span class="line">   <span class="type">uint32_t</span> version;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readOnly:只读</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">class_ro_t</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="type">uint32_t</span> instanceSize; </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="type">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * ivarLayout;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * name;  <span class="comment">// 类名</span></span><br><span class="line">    <span class="type">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="type">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="type">const</span> <span class="type">ivar_list_t</span> * ivars;  <span class="comment">// 成员变量列表</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="type">property_list_t</span> *baseProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>分析到这里，Class结构我们已了解清楚，接下来就是调用对象的方法来研究一下消息发送的完整流程。</p>
<h2 id="消息发送阶段">消息发送阶段</h2>
<p>在OC里面，调用对象的某个方法就是给这个对象发送一条消息，这里我们新建一个Person类，以[person personRun]为例来看看消息发送阶段的流程。</p>
<p>在<a href="https://codersunny.com/posts/39324100/">【iOS重学】方法缓存cache_t的分析</a>这篇文章中我们主要分析了方法缓存，建议大家先看一下缓存可以帮助我们理解接下来的流程。</p>
<p>我们知道OC中的方法调用其实就是转成<code>objc_msgSend()</code>函数的调用（load方法除外），如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220604/1.png" alt="1"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息发送阶段源码跟读顺序</span></span><br><span class="line"><span class="number">1.</span> objc-msg-arm64 汇编文件</span><br><span class="line">	ENTRY _objc_msgSend</span><br><span class="line">	b.le LNilOrTagged</span><br><span class="line">	CacheLookup NORMAL, _objc_msgSend, __objc_msgSend_uncached</span><br><span class="line">	.macro CacheLookup</span><br><span class="line">	CacheHit <span class="comment">// 命中缓存</span></span><br><span class="line">	MissLabelDynamic <span class="comment">// 其实就是__objc_msgSend_uncached</span></span><br><span class="line">	STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">	MethodTableLookup</span><br><span class="line">	.macro MethodTableLookup</span><br><span class="line">	bl _lookupImpOrForward</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> objc-runtime-<span class="keyword">new</span>.mm 文件</span><br><span class="line">	<span class="function">lookupImpOrForward</span></span><br><span class="line"><span class="function">	<span class="title">getMethodNoSuper_nolock</span><span class="params">(curClass, sel)</span></span></span><br><span class="line"><span class="function">	curClass </span>= curClass-&gt;<span class="built_in">getSuperclass</span>()</span><br><span class="line">	<span class="built_in">cache_getImp</span>(curClass, sel) <span class="comment">// 从父类缓存里面查找</span></span><br><span class="line">	log_and_fill_cache <span class="comment">// 缓存方法到消息接收者这个类</span></span><br></pre></td></tr></table></figure>
<p>消息发送的流程图如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220604/2.png" alt="2"></p>
<blockquote>
<p><strong>我们来验证一下是否真的缓存了调用的方法：</strong></p>
<p>未调用personRun时，我们查一下在Person类的cache里面是否能找到personRun方法缓存：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">mj_objc_class *personClass = (__bridge  mj_objc_class *)[Person <span class="keyword">class</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %p&quot;</span>,<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(personRun)), personClass-&gt;cache.imp(<span class="keyword">@selector</span>(personRun)));</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-10</span> <span class="number">13</span>:<span class="number">11</span>:<span class="number">30.367394</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">88049</span>:<span class="number">12459843</span>] personRun <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p><strong>结果分析</strong>：在cache并没有找到personRun的IMP。</p>
<p>调用personRun之后，我们查一下Person类的cache里面是否能找到personRun方法缓存：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">[person personRun];</span><br><span class="line">mj_objc_class *personClass = (__bridge  mj_objc_class *)[Person <span class="keyword">class</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %p&quot;</span>,<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(personRun)), personClass-&gt;cache.imp(<span class="keyword">@selector</span>(personRun)));</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-10</span> <span class="number">13</span>:<span class="number">13</span>:<span class="number">30.294687</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">88074</span>:<span class="number">12461806</span>] personRun <span class="number">0x78cc0</span></span><br></pre></td></tr></table></figure>
<p><strong>结果分析</strong>：调用personRun之后，会把personRun缓存到方法缓存里面</p>
</blockquote>
<h2 id="动态方法解析阶段">动态方法解析阶段</h2>
<p>当第一阶段【消息发送阶段】没有找到方法实现就会进入第二阶段【动态方法解析阶段】。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态方法解析阶段源码跟读顺序</span></span><br><span class="line"><span class="number">1.</span> objc-runtime-<span class="keyword">new</span>.mm 文件</span><br><span class="line">  resolveMethod_locked</span><br><span class="line">  resolveInstanceMethod 或 resolveClassMethod</span><br><span class="line">  lookupImpOrNilTryCache</span><br><span class="line">  _lookupImpTryCache</span><br><span class="line">  lookupImpOrForward</span><br></pre></td></tr></table></figure>
<p>动态方法解析的流程图如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220604/3.png" alt="3"></p>
<h3 id="动态方法解析流程">动态方法解析流程</h3>
<p>根据<code>+ (BOOL)resolveInstanceMethod:(SEL)sel （实例方法调用这个）</code> 或<code>+ (BOOL)resolveClassMethod:(SEL)sel(类方法调用这个)</code>来做动态方法解析，然后重新走一遍消息发送的流程（从消息接受者的方法缓存里面开始继续往下执行）。</p>
<h3 id="动态方法解析代码">动态方法解析代码</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)otherRun &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(personRun)) &#123;</span><br><span class="line">        Method otherMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(otherRun));</span><br><span class="line">        IMP imp = class_getMethodImplementation(<span class="keyword">self</span>, <span class="keyword">@selector</span>(otherRun));</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, method_getImplementation(otherMethod), method_getTypeEncoding(otherMethod));</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息转发阶段">消息转发阶段</h2>
<p>如果前面的两个阶段都没有实现，就会继续进入【消息转发】的流程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息转发阶段的源码跟读顺序</span></span><br><span class="line"><span class="number">1.</span> objc-msg-arm64 汇编文件</span><br><span class="line">  forward_imp = _objc_msgForward_impcache</span><br><span class="line">  STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line">  b __objc_msgForward</span><br><span class="line">  ENTRY __objc_msgForward</span><br><span class="line">  ENTRY __objc_msgForward_stret</span><br><span class="line">  __objc_forward_stret_handler</span><br><span class="line"><span class="number">2.</span> objc-runtime-<span class="keyword">new</span>.mm 文件</span><br><span class="line">  <span class="type">void</span> *_objc_forward_stret_handler = (<span class="type">void</span> *)objc_defaultForwardStretHandler;</span><br><span class="line"><span class="number">3.</span> CoreFoundation 框架</span><br><span class="line">  __forwarding__ <span class="comment">// 不开源</span></span><br></pre></td></tr></table></figure>
<p>消息转发的流程图如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220604/4.png" alt="4"></p>
<h3 id="消息转发流程">消息转发流程</h3>
<p>消息转发流程也分为了两步:</p>
<p>第一步：<code>forwardingTargetForSelector：</code>方法是指把响应这个方法的对象转发给其他的对象，那么消息接受者就发生了变化，会重新调用一遍<code>objc_MsgSend(消息接受者，SEL)</code>流程。<br>
第二步：<code>forwardingTargetForSelector:</code> 方法返回为<code>nil</code>，继续检查<code>methodSignatureForSelector：</code>是否返回了一个方法签名，然后去执行<code>forwardInvocation:</code>方法。</p>
<h3 id="消息转发流程相关代码实现">消息转发流程相关代码实现</h3>
<h4 id="1-实例方法流程">1. 实例方法流程</h4>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步</span></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(personRun)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[Student alloc] init]; <span class="comment">// 这里返回的是你想把这个消息转发给哪个对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(personRun)) &#123;</span><br><span class="line">        <span class="comment">// ⚠️：这里的方法签名的types不能随便写 因为这里的方法签名决定了下一步的NSInvocation的返回值、参数类型等</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;i@:i&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">     [anInvocation invokeWithTarget:[Student new]];</span><br><span class="line">  <span class="comment">// 在这个方法里可以做任何我们想做的事情</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)doesNotRecognizeSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-类方法流程">2. 类方法流程</h4>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步</span></span><br><span class="line">+ (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(personTest)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [Student <span class="keyword">class</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(personTest)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [Student methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:[Student <span class="keyword">class</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)doesNotRecognizeSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于NSInvocation类">关于<code>NSInvocation</code>类</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSInvocation</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSInvocation</span> *)invocationWithMethodSignature:(<span class="built_in">NSMethodSignature</span> *)sig;</span><br><span class="line"><span class="comment">// 方法签名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="built_in">NSMethodSignature</span> *methodSignature;</span><br><span class="line"></span><br><span class="line"><span class="comment">// retain所有参数 防止参数被dealloc</span></span><br><span class="line">- (<span class="type">void</span>)retainArguments;</span><br><span class="line"><span class="comment">// 参数是否都被retained</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="type">BOOL</span> argumentsRetained;</span><br><span class="line"><span class="comment">// 消息接收者</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">assign</span>) <span class="type">id</span> target;</span><br><span class="line"><span class="comment">// 方法名</span></span><br><span class="line"><span class="keyword">@property</span> SEL selector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取返回值</span></span><br><span class="line">- (<span class="type">void</span>)getReturnValue:(<span class="type">void</span> *)retLoc;</span><br><span class="line"><span class="comment">// 设置返回值</span></span><br><span class="line">- (<span class="type">void</span>)setReturnValue:(<span class="type">void</span> *)retLoc;</span><br><span class="line"><span class="comment">// 获取idx的参数</span></span><br><span class="line">- (<span class="type">void</span>)getArgument:(<span class="type">void</span> *)argumentLocation atIndex:(<span class="built_in">NSInteger</span>)idx;</span><br><span class="line"><span class="comment">// 设置idx的参数</span></span><br><span class="line">- (<span class="type">void</span>)setArgument:(<span class="type">void</span> *)argumentLocation atIndex:(<span class="built_in">NSInteger</span>)idx;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">- (<span class="type">void</span>)invoke;</span><br><span class="line">- (<span class="type">void</span>)invokeWithTarget:(<span class="type">id</span>)target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>大家有兴趣的话可以去试试NSInvacation的使用。</p>
<h2 id="最后-9">最后</h2>
<p>如果按照上面的三大流程都走完之后依然没有找到相应的方法实现，那这个调用最后就会调用<code>doesNotRecognizeSelecto:</code>抛出异常。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】离屏渲染</title>
    <url>/posts/62e3ee95/</url>
    <content><![CDATA[<h2 id="屏幕显示完整流程">屏幕显示完整流程</h2>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220808/2022080801.jpg" alt="2022080801"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220808/2022080802.jpg" alt="2022080802"></p>
<p>整体渲染流程可以分为三个阶段：</p>
<p><label style="color:red">1、CPU阶段</label></p>
<p>CPU的计算主要是通过CoreAnimation来处理，通过OpenGL ES/Metal将数据传递给GPU。</p>
<p><label style="color:red">2、GPU阶段</label></p>
<p>GPU渲染主要是将接收到的渲染数据进行一系列渲染之后将帧数据存储在帧缓存（Frame Buffer）里面，供视频控制器调用。</p>
<p><label style="color:red">3、屏幕显示</label></p>
<p>视频控制器从帧缓存中获取到帧数据显示在屏幕上。</p>
<h2 id="屏幕显示图像原理">屏幕显示图像原理</h2>
<h3 id="CRT显示器原理">CRT显示器原理</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220808/2022080803.jpg" alt="2022080803"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220808/2022080804.jpg" alt="2022080804"></p>
<p>CRT显示器原理主要是通过【电子束】激发屏幕内表面的荧光粉来显示图像，由于荧光粉点亮后很快就会熄灭，所以【电子枪】需要不断的【从上到下】进行扫描，扫描完成后显示器就呈现一帧画面，电子枪回到【初始位置】开始下一次的扫描。</p>
<div class="note green no-icon flat"><p><strong>水平同步信号</strong>：当电子枪换行扫描时会发出一个水平同步信号。</p>
<p><strong>垂直同步信号</strong>：当一帧完成绘制后，电子枪恢复到原来的位置准备扫描下一帧时显示器会发出一个垂直同步信号。</p>
</div>
<p>GPU渲染完成后将渲染结果存入帧缓存区，视频控制器根据【垂直同步信号】逐帧读取帧缓冲区的数据，经过数据转换之后由显示器进行显示。</p>
<h3 id="帧缓存（Frame-Buffer）">帧缓存（Frame Buffer）</h3>
<p><label style="color:red">1、屏幕刷新频率</label></p>
<p>Refresh Rate，单位hz，指的是设备刷新屏幕的频率，这个频率一般是60hz，所以每隔16.67ms屏幕会刷新一次。</p>
<p><label style="color:red">2、帧率</label></p>
<p>Frame Rate，单位fps，指的是GPU生成帧的速率。</p>
<p><label style="color:red">3、帧缓存</label></p>
<p>也叫显存，它是屏幕所显示画面的一个直接映像，也叫做位映射图（bitmap）或光栅，帧缓存的每一存储单元对应屏幕上一个像素，整个帧缓存对应一帧图像。</p>
<div class="note green no-icon flat"><p>理想情况下，屏幕刷新频率和帧率完全一致，也就是说当屏幕显示完一帧的时候刚好下一帧画面也生成直接显示在屏幕上，但实际上这两个频率并不完全一致，为了解决这个问题，引入的【帧缓存】的概念。</p>
</div>
<h3 id="图像撕裂">图像撕裂</h3>
<p><label style="color:red"><strong>图像撕裂现象：</strong></label></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220808/2022080805.jpg" alt="2022080805"></p>
<p><label style="color:red"><strong>原因分析：</strong></label></p>
<p>当【帧率】大于【屏幕刷新频率】时，当视频控制器刚读完一帧的上半部分时，GPU已经把下一帧准备好并提交到帧缓存，这样视频控制器就会读到下一帧的下半部分在屏幕显示。</p>
<p><label style="color:red"><strong>解决方案：</strong></label></p>
<p>苹果使用的是【双缓存】和【垂直同步信号】。</p>
<div class="note green no-icon flat"><p><strong>垂直同步信号</strong>保证GPU的渲染只有等到显示器发出【垂直同步信号】之后才会进行下一帧的渲染。</p>
<p><strong>双缓存</strong>保证显示器会交叉读取两个缓存区的内容，相当于是拿空间换时间的一种策略。</p>
<p>好处在于：</p>
<ol>
<li>
<p>不浪费CPU、GPU资源，保证提前渲染好的位图有一个缓存区来保存，这样GPU可以就可以进行下一帧的处理。</p>
</li>
<li>
<p>减少掉帧的出现。</p>
</li>
</ol>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220808/2022080806.jpg" alt="2022080806"></p>
</div>
<h3 id="卡顿">卡顿</h3>
<p>当显示器的【垂直同步信号】发出的时候，GPU没有完成相应的渲染就会出现【卡顿】的现象，这也是为了解决画面撕裂的问题带来的副作用，如下图所示：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220808/2022080807.jpg" alt="2022080807"></p>
<div class="note green no-icon flat"><p><strong>补充</strong>：</p>
<ol>
<li>掉帧指的是重复渲染同一帧数据而不是指某一帧丢掉了不渲染。</li>
<li>为了减少【掉帧】的情况，有的会引入【三缓存】+【垂直同步信号】，比如安卓设备。</li>
</ol>
</div>
<h2 id="离屏渲染">离屏渲染</h2>
<h3 id="什么是离屏渲染？">什么是离屏渲染？</h3>
<p>当GPU无法直接把渲染结果存放到帧缓存中，而是先是暂时把中间的一个临时状态存放在另外的区域。之后再存放到帧缓存，这个过程叫离屏渲染。</p>
<p>即是说：GPU需要再当前屏幕缓存区以外开辟一个新的缓冲区进行操作。</p>
<div class="note green no-icon flat"><p><strong>原因</strong>：</p>
<p>GPU渲染采用的是【画家算法】，只能一层一层的输出，所以当一层不能直接生成图片的话就需要额外开辟新的缓冲区来存放这些临时图层直到最后生成了一张完整的图片之后再写入帧缓存里面。</p>
<p>如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220808/2022080808.jpg" alt="2022080808"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220808/2022080809.jpg" alt="2022080809"></p>
</div>
<h3 id="当前屏幕渲染和离屏渲染">当前屏幕渲染和离屏渲染</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220808/2022080810.jpg" alt="2022080810"></p>
<h3 id="离屏渲染的性能损耗">离屏渲染的性能损耗</h3>
<p>离屏渲染在当前屏幕缓冲区外新开辟一个缓冲区进行渲染操作，造成其性能损耗的主要原因在于：创建离屏渲染和上下文切换。</p>
<p>切换上下文主要是当发生离屏渲染时，渲染上下文需从当前屏幕缓冲区切换到屏幕外缓冲区然后再完成渲染。</p>
<p>如果一屏元素都发生离屏渲染，这个从当前屏幕缓冲区切换到屏幕外的缓冲区就会发生多次，自然就会有一定的性能损耗。</p>
<h3 id="常见的离屏渲染场景">常见的离屏渲染场景</h3>
<h4 id="设置圆角">设置圆角</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220808/2022080811.jpg" alt="2022080811"></p>
<p><label style="color:red"><strong>结论</strong>：</label></p>
<p>满足以下条件的就会发生离屏渲染：</p>
<ol>
<li>clipsToBounds开启，圆角 &gt; 0，contents上有内容</li>
<li>同时修改了contents+backgroundColor 或 contents+border（iOS9之后）</li>
</ol>
<p><label style="color:red"><strong>优化</strong>：</label></p>
<ol>
<li>直接让UI提供带圆角的图片</li>
<li>利用UIBezierPath和CAShapeLayer</li>
<li>利用UIBezierPath和CoreGraphics</li>
</ol>
<h4 id="设置遮罩">设置遮罩</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220808/2022080812-20220808141811098.jpg" alt="2022080812"></p>
<p><label style="color:red"><strong>设置遮罩的流程如下</strong>：</label></p>
<ol>
<li>渲染layer的mask纹理</li>
<li>渲染layer的content纹理</li>
<li>合并操作：合并mask 和 content纹理</li>
</ol>
<p><label style="color:red"><strong>结论</strong>：</label></p>
<p>满足以下条件的都会触发离屏渲染：</p>
<ol>
<li>设置了mask + 任意contents（比如设置UILabel文字、背景颜色、图片等）</li>
</ol>
<h4 id="设置阴影（shadow）">设置阴影（shadow）</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220808/2022080813.jpg" alt="2022080813"></p>
<p><label style="color:red"><strong>结论</strong>：</label></p>
<p>阴影的本质和layer类似，都是在layer下一层多添加一层，根据前面提到的【画家算法】无法一次性生成，所以会发生离屏渲染。</p>
<p><label style="color:red"><strong>优化</strong>：</label></p>
<p>1.利用UIBezierPath给视图添加一个阴影路径，相当于提前告诉GPU这个阴影的几何形状，这样阴影就可以独立渲染。</p>
<h4 id="光栅化（shouldRasterize）">光栅化（shouldRasterize）</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220808/2022080814.jpg" alt="2022080814"></p>
<p><label style="color:red"><strong>光栅化</strong>：</label></p>
<p>光栅化是一种缓存机制，开启后会缓存这个图片的bitmap，如果对应的layer和sublayers没有发生变化，就可以直接使用缓存而不用GPU再进行渲染，从而提高性能。</p>
<p><strong>注意：</strong></p>
<p>光栅化只能缓存100ms，而且只能存储屏幕大小2.5倍的数据，缓存空间十分有限。</p>
<h4 id="组不透明（allowsGroupOpacity）">组不透明（allowsGroupOpacity）</h4>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/20220808/2022080815.jpg" alt="2022080815"></p>
<p><label style="color:red"><strong>allowsGroupOpacity</strong>：</label></p>
<p>alpha并不是分别应用到每一层上，而是整个layer图层树完成之后，再统一加上alpha，然后和底下其他像素进行融合。</p>
<p><strong>注意：</strong></p>
<p>iOS7之后allowsGroupOpacity默认为YES，这样做的原因是为了保持子视图和父视图保持同样的透明度</p>
<p><label style="color:red"><strong>allowsGroupOpacity触发离屏渲染的条件</strong>：</label></p>
<ol>
<li>当视图上有其他子视图</li>
<li>视图View的alpha值在0 ～ 1之间</li>
<li>视图view.layer.allowsGroupOpacity = YES</li>
</ol>
<h2 id="总结-4">总结</h2>
<p>离屏渲染的处理仅仅是我们日常所关注的性能中的其中一个点，在处理的时候也要根据具体场景具体分析，要注意并不是所有的离屏渲染都是必须要去避免的，开辟额外的帧缓存虽然有一定的性能损耗，但是保存渲染结果并进行最终的视图显示也是为了保持视图的流畅性。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>离屏渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】窥探Class的结构</title>
    <url>/posts/b55a18a8/</url>
    <content><![CDATA[<h2 id="写在前面-28">写在前面</h2>
<p>本文主要探究<code>Class</code>的内部结构，博主这里使用的objc4的源码版本是<code>objc4-838</code>，建议大家在看的时候可以下载最新源码。</p>
<h2 id="Class的结构-2">Class的结构</h2>
<p>在前面关于<a href="https://codersunny.com/posts/9efafc5a/">isa和superclass</a>文章中，我们提到了类对象和元类对象的类型都是<code>Class</code>，内存里面保存的是：</p>
<p>. isa指针</p>
<p>. superclass指针</p>
<p>. 属性信息</p>
<p>. 对象方法信息</p>
<p>. 协议信息</p>
<p>. 成员变量信息</p>
<p>今天我们就来剖析一下<code>Class</code>的内部结构，验证一下是不是存放的这些信息，废话不多说了，我们现在就开始吧。</p>
<p><code>Class</code>是个<code>objc_class</code>类型的结构体，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>在<code>objc4</code>源码<code>objc-runtime-new.h</code>文件中，对<code>objc_class</code>定义如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1123/1.png" alt="1"></p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1123/2.png" alt="2"></p>
<p>因为<code>objc_class</code>结构体中数据太多，我这里提炼出来对我们分析结构有用的数据，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">  Class isa; <span class="comment">// isa</span></span><br><span class="line">  Class superclass; <span class="comment">// superclass</span></span><br><span class="line">  cache_t cache; <span class="comment">// 方法缓存</span></span><br><span class="line">  class_data_bits_t bits; <span class="comment">// 具体的类信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>class_data_bits_t</code>结构如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_data_bits_t &#123;</span><br><span class="line">  class_rw_t *data() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>class_rw_t</code>结构中，<code>rw</code>一般表示readwrite（可读可写），<code>t</code>一般表示table,结构信息如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">  uint32_t flags;</span><br><span class="line">  uint16_t witness;</span><br><span class="line">  Class firstSubclass;</span><br><span class="line">  Class nextSiblingClass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  所有的类会链接成一个树状结构 利用firstSubclass 和 nextSiblingClass来实现的。</span></span><br></pre></td></tr></table></figure>
<p><code>class_rw_ext_t</code>结构信息如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_ext_t &#123;</span><br><span class="line">  class_ro_t_authed_ptr&lt;<span class="keyword">const</span> class_ro_t&gt; ro;</span><br><span class="line">  method_array_t methods; <span class="comment">// 方法列表</span></span><br><span class="line">  property_array_t properties; <span class="comment">// 属性列表</span></span><br><span class="line">  protocol_array_t protocols; <span class="comment">// 协议列表</span></span><br><span class="line">  <span class="type">char</span> *demangledName;</span><br><span class="line">  uint32_t version;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note red no-icon flat"><p><strong>提醒</strong>：</p>
<p>在WWDC2020中，苹果修改了一些底层的类，其中一个就是我们上面介绍的<code>class_rw_ext_t</code>，至于这个类主要作用是什么大家有兴趣的可以去详细了解一下，博主这里就不展开来讲这个了，大概的意思就是：它利用了懒加载的机制，在类的<code>methods</code>、<code>properties</code>等发生变化的时候，才会初始化<code>class_rw_ext_t</code>来存储这些列表，这样就可以减少90%以前Runtime中的类在<code>rw</code>中直接复制<code>ro</code>中数据浪费的内存。</p>
</div>
<p><code>class_ro_t</code>结构中，<code>ro</code>一般表示readonly（只读），<code>t</code>一般表示table，结构信息如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">  uint32_t flags;</span><br><span class="line">  uint32_t instanceStart;</span><br><span class="line">  uint32_t instanceSize; <span class="comment">// instance对象占用的内存空间大小</span></span><br><span class="line">  </span><br><span class="line">  explicit_atomic&lt;<span class="keyword">const</span> <span class="type">char</span> *&gt; name; <span class="comment">// 类名</span></span><br><span class="line">  <span class="comment">// 方法列表（不包括分类的方法列表）</span></span><br><span class="line">  WrappedPtr&lt;method_list_t, method_list_t::Ptrauth&gt; baseMethods;</span><br><span class="line">  protocol_list_t * baseProtocols; <span class="comment">// 协议信息列表</span></span><br><span class="line">  <span class="keyword">const</span> ivar_list_t * ivars; <span class="comment">// 成员变量列表</span></span><br><span class="line">  property_list_t *baseProperties; <span class="comment">// 属性信息列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用一张图来表示Class结构：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1123/3.png" alt="3"></p>
<p>从上面的结构分析我们可以看到：class对象或meta-class对象里面确实保存了<strong>方法列表、属性列表、协议列表、成员变量列表</strong>等信息。</p>
<h2 id="写在最后-19">写在最后</h2>
<p>关于<code>Class</code>结构信息我们就分析到这里了，如果有什么不对的地方望指教。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS重学】线程保活</title>
    <url>/posts/f68de671/</url>
    <content><![CDATA[<h2 id="写在前面-29">写在前面</h2>
<p>本文主要讲一下线程保活是什么、线程保活的意义、如何实现线程保活。</p>
<h2 id="线程保活">线程保活</h2>
<h3 id="线程生命周期">线程生命周期</h3>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/02/14/1.png" alt="1"></p>
<ul>
<li>【新建】：创建一个线程对象。</li>
<li>【就绪】：线程调用<code>start</code>方法，将线程加入可调度线程池中，等着CPU的调度。</li>
<li>【运行】：CPU调度当前线程执行。</li>
<li>【阻塞】：当满足某个预设的条件时（比如休眠或者同步锁）会阻塞线程执行，重新将线程设置为【就绪】状态。</li>
<li>【死亡】：线程任务执行完毕或强制退出，线程生命周期结束。</li>
</ul>
<h3 id="什么是线程保活">什么是线程保活</h3>
<p>线程保活：一般情况下，当线程执行玩一次任务之后需要进行资源回收也就意味着生命周期结束，线程保活就是保证线程的生命周期不结束。</p>
<h3 id="线程保活的应用场景">线程保活的应用场景</h3>
<p>当一个任务随时都有可能去执行它，那么这个任务应该放在子线程去执行，并且让子线程一直存活，避免频繁创建线程而造成的性能损耗。<br>
大家如果看过AFNetworking的源码就会看到框架里面是有用到线程保活的。</p>
<h3 id="如何实现线程保活">如何实现线程保活</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WWPermenantThread 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WWPermenantThread</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 关闭线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)stop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在保活的线程里面执行的任务</span></span><br><span class="line"><span class="comment">/// @param target 目标对象</span></span><br><span class="line"><span class="comment">/// @param action selector</span></span><br><span class="line"><span class="comment">/// @param object object</span></span><br><span class="line">- (<span class="type">void</span>)excuteTaskWithTarget:(<span class="type">id</span>)target action:(SEL)action object:(<span class="type">id</span>)object;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在保活的线程里执行任务</span></span><br><span class="line"><span class="comment">/// @param task 执行的任务</span></span><br><span class="line">- (<span class="type">void</span>)excuteTask:(<span class="type">void</span>(^)(<span class="type">void</span>))task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WWPermenantThread</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> *innerThread;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> isStopped;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WWPermenantThread</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">    [<span class="keyword">self</span> stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">    <span class="keyword">self</span>.isStopped = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.innerThread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">      <span class="comment">// 添加Port到RunLoop</span></span><br><span class="line">      [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">      <span class="keyword">while</span> (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</span><br><span class="line">        <span class="comment">// 开启RunLoop</span></span><br><span class="line">          [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.innerThread start];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="keyword">self</span>.innerThread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)stop &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__stop) onThread:<span class="keyword">self</span>.innerThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)__stop &#123;</span><br><span class="line">  <span class="keyword">self</span>.isStopped = <span class="literal">YES</span>;</span><br><span class="line">  <span class="comment">// 退出当前RunLoop</span></span><br><span class="line">  <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">  <span class="keyword">self</span>.innerThread = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)excuteTaskWithTarget:(<span class="type">id</span>)target action:(SEL)action object:(<span class="type">id</span>)object &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="keyword">self</span> performSelector:action onThread:<span class="keyword">self</span>.innerThread withObject:object waitUntilDone:<span class="literal">NO</span> ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)excuteTask:(<span class="type">void</span> (^)(<span class="type">void</span>))task &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread || !task) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__excuteTask:) onThread:<span class="keyword">self</span>.innerThread withObject:task waitUntilDone:<span class="literal">NO</span> ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)__excuteTask:(<span class="type">void</span>(^)(<span class="type">void</span>))task &#123;</span><br><span class="line">  task();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="如何使用线程保活">如何使用线程保活</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">  <span class="comment">// 创建一个线程对象</span></span><br><span class="line">  <span class="keyword">self</span>.thread = [[WWPermenantThread alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">  [<span class="keyword">self</span>.thread excuteTask:^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 - %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2023</span><span class="number">-02</span><span class="number">-15</span> <span class="number">10</span>:<span class="number">18</span>:<span class="number">56.211402</span>+<span class="number">0800</span> 线程保活Demo1[<span class="number">10526</span>:<span class="number">21512893</span>] 执行任务 - &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002e99680</span>&gt;&#123;number = <span class="number">9</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2023</span><span class="number">-02</span><span class="number">-15</span> <span class="number">10</span>:<span class="number">18</span>:<span class="number">56.830085</span>+<span class="number">0800</span> 线程保活Demo1[<span class="number">10526</span>:<span class="number">21512893</span>] 执行任务 - &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002e99680</span>&gt;&#123;number = <span class="number">9</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2023</span><span class="number">-02</span><span class="number">-15</span> <span class="number">10</span>:<span class="number">18</span>:<span class="number">57.279150</span>+<span class="number">0800</span> 线程保活Demo1[<span class="number">10526</span>:<span class="number">21512893</span>] 执行任务 - &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002e99680</span>&gt;&#123;number = <span class="number">9</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2023</span><span class="number">-02</span><span class="number">-15</span> <span class="number">10</span>:<span class="number">18</span>:<span class="number">58.212741</span>+<span class="number">0800</span> 线程保活Demo1[<span class="number">10526</span>:<span class="number">21512893</span>] 执行任务 - &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002e99680</span>&gt;&#123;number = <span class="number">9</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2023</span><span class="number">-02</span><span class="number">-15</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">32.672529</span>+<span class="number">0800</span> 线程保活Demo1[<span class="number">10526</span>:<span class="number">21512038</span>] -[OneViewController dealloc]</span><br><span class="line"><span class="number">2023</span><span class="number">-02</span><span class="number">-15</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">32.672800</span>+<span class="number">0800</span> 线程保活Demo1[<span class="number">10526</span>:<span class="number">21512038</span>] -[WWPermenantThread dealloc]</span><br></pre></td></tr></table></figure>
<h2 id="写在最后-20">写在最后</h2>
<p>关于如何实现线程保活的笔记就记录到这里了，如有错误请多多指教。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【 iOS重学】详细分析isa和superclass</title>
    <url>/posts/9efafc5a/</url>
    <content><![CDATA[<h2 id="写在前面-30">写在前面</h2>
<p>本文将从源码上来详细剖析OC对象的分类、isa、superclass，带大家重新认识iOS。</p>
<p>苹果源码下载：</p>
<p>1.<a href="https://opensource.apple.com/releases/">https://opensource.apple.com/releases/</a>  搜索objc4找到最新资源进行下载</p>
<p>2.<a href="https://opensource.apple.com/source/objc4/">https://opensource.apple.com/source/objc4/</a></p>
<p>3.<a href="https://opensource.apple.com/tarballs/objc4/">https://opensource.apple.com/tarballs/objc4/</a>  （这个是其他博文提到的下载路径 但是在博主这里会提示404了）</p>
<h2 id="OC对象的分类">OC对象的分类</h2>
<p>OC对象可以分为三种：instance对象（实例对象）、class对象（类对象）、meta-class对象（元类对象），我们现在来一一分析这三种对象。</p>
<h3 id="实例对象">实例对象</h3>
<p>instance对象是调用<code>alloc</code>的对象，每次调用<code>alloc</code>都会产生新的instance对象。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *object1 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="built_in">NSObject</span> *object2 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;object1:%p,object2:%p&quot;</span>,object1, object2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：object1:0x6000029982d0,object2:0x600002998220</span></span><br></pre></td></tr></table></figure>
<p>如上：<code>object1</code>和<code>object2</code>就是instance对象，分别占据不同的内存，它们的内存地址也不一样。</p>
<p><code>NSObject</code>的源码结构如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note green no-icon flat"><p>instance对象在内存中存储的信息包含：</p>
<p>1.isa指针</p>
<p>2.其他成员变量</p>
</div>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> weight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">Person *person1 = [[Person alloc] init];</span><br><span class="line">person1.age = <span class="number">18</span>;</span><br><span class="line">person1.weight = <span class="number">45.</span>f;</span><br><span class="line"></span><br><span class="line">Person *person2 = [[Person alloc] init];</span><br><span class="line">person2.age = <span class="number">20</span>;</span><br><span class="line">person2.weight = <span class="number">50.</span>f;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;person1:%p, person2:%p&quot;</span>,person1, person2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：person1:0x600000374520, person2:0x6000003745e0</span></span><br></pre></td></tr></table></figure>
<p>上面<code>person1</code>和<code>person2</code>的内存存储信息如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1111/1.png" alt="1"></p>
<h3 id="类对象">类对象</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">Class objectClass1 = object_getClass(object);</span><br><span class="line">Class objectClass2 = [object <span class="keyword">class</span>];</span><br><span class="line">Class objectClass3 = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;objectClass1：%p, objectClass2：%p, objectClass3:%p&quot;</span>,objectClass1, objectClass2, objectClass3);</span><br><span class="line">          </span><br><span class="line"><span class="comment">// 打印结果：objectClass1：0x7fff865a7710, objectClass2：0x7fff865a7710, objectClass3:0x7fff865a7710</span></span><br></pre></td></tr></table></figure>
<p>如上：<code>objectClass1</code>、<code>objectClass2</code>、<code>objectClass3</code>是同一个对象，它们的内存地址相同，这种叫做class对象。</p>
<p><strong>每个类在内存里面有且仅有一个class对象。</strong></p>
<div class="note green no-icon flat"><p>class对象在内存中存储的信息包含：</p>
<p>1.isa指针</p>
<p>2.superclass指针</p>
<p>3.类的<strong>属性信息</strong>（@property）</p>
<p>4.类的<strong>对象方法信息</strong>（instance method）</p>
<p>5.类的<strong>协议信息</strong>（protocol）</p>
<p>6.类的<strong>成员变量信息</strong>（ivar）</p>
<p>…</p>
<p><strong>注意</strong>：这里的<strong>成员变量信息</strong>要区别于instance对象里面的<strong>成员变量</strong>，class对象里面存的是只需要存储一份的东西，比如名称等，instance对象里面存的是具体的值，因为不同的实例对象成员变量的值是不一样的，这里大家要注意去区分。</p>
</div>
<p>class对象内存中存储的信息包含：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1111/2.png" alt="2"></p>
<h3 id="元类对象">元类对象</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class metaClass = object_getClass([<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;metaClass：%p&quot;</span>,metaClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：metaClass：0x7fff865a76c0</span></span><br></pre></td></tr></table></figure>
<p>如上：<code>metaClass</code>就是meta-class对象。</p>
<p>class对象和meta-class对象都是<code>Class</code>类，所以meta-class对象里面存储的信息我们可以理解为跟class对象存储的是同样的，但是它们的<strong>用途</strong>不一样。</p>
<p><strong>每个类在内存里面有且仅有一个meta-class对象。</strong></p>
<div class="note green no-icon flat"><p>这里大家可能会有一个疑问：为什么<code>object_getClass</code>传instance对象和class对象得到的是不同的对象？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class gdb_object_getClass(<span class="type">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 1.如果是instance对象 返回的是class对象</span></span><br><span class="line">    <span class="comment">// 2.如果是class对象 返回的是meta-class对象</span></span><br><span class="line">    <span class="comment">// 3.如果是meta-class对象 返回的是基类的meta-class对象</span></span><br><span class="line">    <span class="keyword">return</span> gdb_class_getClass(obj-&gt;getIsa());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到：是因为<code>isa</code>指针，这个我们在后面会再详细解释。</p>
</div>
<h3 id="object-getClass和objc-getClass">object_getClass和objc_getClass</h3>
<p><code>object_getClass</code>和<code>objc_getClass</code>都是<code>runtime</code>下的两个函数，区别如下：</p>
<div class="note green no-icon flat"><p><code>object_getClass</code>传的是<strong>对象</strong>，<code>objc_getClass</code>传的是<strong>字符串</strong>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class personCalss1 = object_getClass(person); </span><br><span class="line"></span><br><span class="line">Class personCalss2 = objc_getClass(<span class="string">&quot;Person&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;class:%p %p&quot;</span>,personCalss1, personCalss2);        </span><br></pre></td></tr></table></figure>
</div>
<h3 id="class和-class">+class和-class</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="isa和superclass">isa和superclass</h2>
<h3 id="isa和superclass的总结">isa和superclass的总结</h3>
<p>这里借用网友的一张图片来做总结：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1111/3.png" alt="3"></p>
<h3 id="isa指针">isa指针</h3>
<p>在前面我们说到instance对象的方法是存放在class对象的内存里面，那么它们之间是如何保持这种关联的，就是通过<code>isa</code>指针来保持关联的。</p>
<div class="note green no-icon flat"><p>1.instance对象的<code>isa</code>指向class对象。</p>
<p>2.class对象的<code>isa</code>指向meta-class对象。</p>
<p>3.meta-class对象的<code>isa</code>指向<strong>基类</strong>的meta-class对象。</p>
</div>
<p>如何证明instance对象的<code>isa</code>指向class对象?</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ww_objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;; <span class="comment">// 这个结构体是自己实现的 因为OC的类对象的isa没有暴露出来使用</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">  Person *person = [[Person alloc] init];</span><br><span class="line">  <span class="keyword">struct</span> ww_objc_class *wwPerson =  (__bridge <span class="keyword">struct</span> ww_objc_class *)(person);</span><br><span class="line">  Class personClass = [person <span class="keyword">class</span>];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;---%p, %p&quot;</span>,wwPerson-&gt;isa, personClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：p/x (long)person-&gt;isa（直接在控制器查看isa值）</span></span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-13</span> <span class="number">17</span>:<span class="number">35</span>:<span class="number">42.687432</span>+<span class="number">0800</span> OC对象的本质[<span class="number">50885</span>:<span class="number">15128534</span>] --<span class="number">-0x10a69a540</span>, <span class="number">0x10a69a540</span></span><br></pre></td></tr></table></figure>
 <div class="note red no-icon flat"><p><strong>结论</strong>：Person类对象的<code>isa</code>值 = Person类对象的地址值（这是一个APP项目）</p>
<p><strong>注意</strong>：如果创建一个命令行项目来对比两个地址值，会发现是不相等的需要进行一次位运算才会相等。</p>
<p>命令<code>uname -a</code>可以查看当前环境是64bit还是32bit。</p>
</div>
<h3 id="superclass指针">superclass指针</h3>
<div class="note pink no-icon flat"><p>1.instance对象没有<code>superclass</code>指针。</p>
<p>2.class对象的<code>superclass</code>指向<strong>父类</strong> 的class对象。</p>
<p>3.meta-class对象的<code>superclass</code>指向<strong>父类</strong>的meta-class对象。</p>
<p>4.如果没有<strong>父类</strong>， <code>superclass</code>指向nil。</p>
<p>5.基类meta-class对象的<code>superclass</code>指向基类的<strong>class对象</strong>。</p>
</div>
<p>如何验证class对象的<code>superclass</code>指向父类的class对象？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ww_objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">  Person *person = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">  Class PersonClass = [person <span class="keyword">class</span>];</span><br><span class="line">  <span class="keyword">struct</span> ww_objc_class *wwPersonClass =  (__bridge <span class="keyword">struct</span> ww_objc_class *)(PersonClass);</span><br><span class="line"></span><br><span class="line">  Class <span class="built_in">NSObjectClass</span> = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;---%p, %p&quot;</span>,wwPersonClass-&gt;superclass, <span class="built_in">NSObjectClass</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-13</span> <span class="number">17</span>:<span class="number">42</span>:<span class="number">05.345430</span>+<span class="number">0800</span> OC对象的本质[<span class="number">50983</span>:<span class="number">15133846</span>] --<span class="number">-0x7fff865a7710</span>, <span class="number">0x7fff865a7710</span></span><br></pre></td></tr></table></figure>
 <div class="note red no-icon flat"><p><strong>结论</strong>：Person类对象的<code>superclass</code>值 = NSObject类对象的地址值</p>
</div>
<h3 id="场景一">场景一</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> weight;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;---%s ---%@&quot;</span>,__func__, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">  Student *student = [[Student alloc] init];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;---Student:%@&quot;</span>,student);</span><br><span class="line">  [student run];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-13</span> <span class="number">16</span>:<span class="number">46</span>:<span class="number">19.413744</span>+<span class="number">0800</span> OC对象的本质[<span class="number">50121</span>:<span class="number">15084736</span>] ---Student:&lt;Student: <span class="number">0x600002127fc0</span>&gt;</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-13</span> <span class="number">16</span>:<span class="number">46</span>:<span class="number">19.413912</span>+<span class="number">0800</span> OC对象的本质[<span class="number">50121</span>:<span class="number">15084736</span>] ----[Person run] ---&lt;Student: <span class="number">0x600002127fc0</span>&gt;</span><br></pre></td></tr></table></figure>
<p><code>student</code>调用<code>run</code>方法的调用流程如下：</p>
<ol>
<li>通过<code>student</code>的<code>isa</code>指针找到<code>Student</code>对象。</li>
<li>查找<code>Student</code>对象里面是否有<code>run</code>方法。</li>
<li>通过<code>Student</code>对象的<code>superclass</code>指针找到<code>Person</code>对象。</li>
<li>查找<code>Person</code>对象的<code>run</code>方法。</li>
</ol>
<h3 id="场景二">场景二</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.为NSObject写一个分类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">fly</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)fly;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">fly</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)fly &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;-[NSObject fly] ---%p&quot;</span>,<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)fly;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;Person:%p&quot;</span>,[Person <span class="keyword">class</span>]);</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;NSObject:%p&quot;</span>,[<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br><span class="line">  [Person fly];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-13</span> <span class="number">17</span>:<span class="number">17</span>:<span class="number">07.265249</span>+<span class="number">0800</span> OC对象的本质[<span class="number">50673</span>:<span class="number">15113962</span>] Person:<span class="number">0x10197f568</span></span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-13</span> <span class="number">17</span>:<span class="number">17</span>:<span class="number">07.265404</span>+<span class="number">0800</span> OC对象的本质[<span class="number">50673</span>:<span class="number">15113962</span>] <span class="built_in">NSObject</span>:<span class="number">0x7fff865a7710</span></span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-13</span> <span class="number">17</span>:<span class="number">17</span>:<span class="number">07.265539</span>+<span class="number">0800</span> OC对象的本质[<span class="number">50673</span>:<span class="number">15113962</span>] -[<span class="built_in">NSObject</span> fly] --<span class="number">-0x10197f568</span></span><br></pre></td></tr></table></figure>
<p>如上：<code>Person</code>调用<code>fly</code>这个方法，但是<code>Person</code>里面并没有实现<code>fly</code>这个方法，在<code>NSObject</code>的分类方法里面有一个<code>fly</code>的实例方法。</p>
<p>调用<code>[Person fly]</code>并没有发生崩溃，原因如下：</p>
<ol>
<li>通过<code>Person</code>class对象的<code>isa</code>指针找到<code>Person</code>的meta-class对象。</li>
<li>查看<code>Person</code>的meta-class对象的内存里面是否有<code>+fly</code>方法。(NO)</li>
<li>通过<code>Person</code>meta-class对象的<code>superclass</code>指针找到父类<code>NSObject</code>的meta-class对象。</li>
<li>查看<code>NSObject</code>的meta-class对象的内存里面是否有<code>+fly</code>方法。(NO)</li>
<li>通过<code>NSObject</code>meta-class对象的<code>superclass</code>指针找到<code>NSObject</code>class对象。</li>
<li>在<code>NSObject</code>class对象中找到<code>-fly</code>方法得以调用。</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>【工具使用】Reveal工具的使用介绍</title>
    <url>/posts/745be31f/</url>
    <content><![CDATA[<h2 id="写在前面-31">写在前面</h2>
<p>有时候我们可能想要分析其他APP的一些整体View结构，就像在Xcode分析我们自己的APP一样能够清楚看到个层级结构，Reveal这个APP主要就是这个功能：用来分析APP的层级结构。</p>
<h2 id="Reveal">Reveal</h2>
<p>Reveal APP 官网：<a href="https://revealapp.com/">https://revealapp.com/</a></p>
<p>Reveal APP下载地址：<a href="https://revealapp.com/download/">https://revealapp.com/download/</a></p>
<p>这个是官网正版，可以免费试用14天。</p>
<h2 id="Reveal的基本使用">Reveal的基本使用</h2>
<ul>
<li>
<p>打开Reveal，菜单栏Help - Show Reveal Framework in Finder</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/1.png" alt="1"></p>
</li>
</ul>
<h3 id="真机下的配置">真机下的配置</h3>
<ul>
<li>
<p>找到RevealServer.framework - ios-arm64 - RevealServer.framework</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/2.png" alt="2"></p>
</li>
<li>
<p>打开iFunBox - 将RevealServer.framework复制到iFunBox中 Library/Frameworks中</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/3.png" alt="3"></p>
</li>
<li>
<p>在手机Cydia中搜索Reveal2Loader进行安装</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/4.png" alt="4"></p>
</li>
<li>
<p>手机设置 - Reveal - Enabled Applications - 选择允许Reveal访问的APP</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/5.png" alt="5"></p>
</li>
<li>
<p>在手机终端执行 - killall SpringBoard</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/6.png" alt="6"></p>
</li>
</ul>
<h3 id="模拟器下的配置">模拟器下的配置</h3>
<ul>
<li>
<p>找到RevealServer.framework - ios-arm64_x86_64-simulator - RevealServer.framework</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/7.png" alt="7"></p>
</li>
<li>
<p>在Xcode配置中导入RevealServer.framework</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/8.png" alt="8"></p>
</li>
</ul>
<h3 id="Reveal的使用">Reveal的使用</h3>
<p>通过上面的介绍配置完成之后，我们就可以正式使用Reveal了。</p>
<p>打开手机上的某个APP - 打开Reveal - 会在Reveal看到我们刚打开的APP 如下：</p>
<p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/9.png" alt="9"></p>
<p>上面一个是通过网络连接、一个是通过USB连接，我们选择更快的USB连接即可使用Reveal。</p>
<h2 id="写在最后-21">写在最后</h2>
<p>关于Reveal使用前的配置就简单介绍到这里啦，如有错误请多多指教。</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
</search>

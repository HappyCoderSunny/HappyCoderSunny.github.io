<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sunny&#39;s Blog</title>
  
  
  <link href="https://codersunny.com/atom.xml" rel="self"/>
  
  <link href="https://codersunny.com/"/>
  <updated>2023-03-06T12:00:39.327Z</updated>
  <id>https://codersunny.com/</id>
  
  <author>
    <name>Sunny</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【iOS重学】线程保活</title>
    <link href="https://codersunny.com/posts/f68de671/"/>
    <id>https://codersunny.com/posts/f68de671/</id>
    <published>2023-02-14T11:52:56.000Z</published>
    <updated>2023-03-06T12:00:39.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-28">写在前面</h2><p>本文主要讲一下线程保活是什么、线程保活的意义、如何实现线程保活。</p><h2 id="线程保活">线程保活</h2><h3 id="线程生命周期">线程生命周期</h3><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/02/14/1.png" alt="1"></p><ul><li>【新建】：创建一个线程对象。</li><li>【就绪】：线程调用<code>start</code>方法，将线程加入可调度线程池中，等着CPU的调度。</li><li>【运行】：CPU调度当前线程执行。</li><li>【阻塞】：当满足某个预设的条件时（比如休眠或者同步锁）会阻塞线程执行，重新将线程设置为【就绪】状态。</li><li>【死亡】：线程任务执行完毕或强制退出，线程生命周期结束。</li></ul><h3 id="什么是线程保活">什么是线程保活</h3><p>线程保活：一般情况下，当线程执行玩一次任务之后需要进行资源回收也就意味着生命周期结束，线程保活就是保证线程的生命周期不结束。</p><h3 id="线程保活的应用场景">线程保活的应用场景</h3><p>当一个任务随时都有可能去执行它，那么这个任务应该放在子线程去执行，并且让子线程一直存活，避免频繁创建线程而造成的性能损耗。<br>大家如果看过AFNetworking的源码就会看到框架里面是有用到线程保活的。</p><h3 id="如何实现线程保活">如何实现线程保活</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WWPermenantThread 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WWPermenantThread</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 关闭线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)stop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在保活的线程里面执行的任务</span></span><br><span class="line"><span class="comment">/// @param target 目标对象</span></span><br><span class="line"><span class="comment">/// @param action selector</span></span><br><span class="line"><span class="comment">/// @param object object</span></span><br><span class="line">- (<span class="type">void</span>)excuteTaskWithTarget:(<span class="type">id</span>)target action:(SEL)action object:(<span class="type">id</span>)object;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在保活的线程里执行任务</span></span><br><span class="line"><span class="comment">/// @param task 执行的任务</span></span><br><span class="line">- (<span class="type">void</span>)excuteTask:(<span class="type">void</span>(^)(<span class="type">void</span>))task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WWPermenantThread</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> *innerThread;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> isStopped;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WWPermenantThread</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">    [<span class="keyword">self</span> stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">    <span class="keyword">self</span>.isStopped = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.innerThread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">      <span class="comment">// 添加Port到RunLoop</span></span><br><span class="line">      [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">      <span class="keyword">while</span> (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</span><br><span class="line">        <span class="comment">// 开启RunLoop</span></span><br><span class="line">          [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.innerThread start];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="keyword">self</span>.innerThread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)stop &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__stop) onThread:<span class="keyword">self</span>.innerThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)__stop &#123;</span><br><span class="line">  <span class="keyword">self</span>.isStopped = <span class="literal">YES</span>;</span><br><span class="line">  <span class="comment">// 退出当前RunLoop</span></span><br><span class="line">  <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">  <span class="keyword">self</span>.innerThread = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)excuteTaskWithTarget:(<span class="type">id</span>)target action:(SEL)action object:(<span class="type">id</span>)object &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="keyword">self</span> performSelector:action onThread:<span class="keyword">self</span>.innerThread withObject:object waitUntilDone:<span class="literal">NO</span> ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)excuteTask:(<span class="type">void</span> (^)(<span class="type">void</span>))task &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread || !task) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__excuteTask:) onThread:<span class="keyword">self</span>.innerThread withObject:task waitUntilDone:<span class="literal">NO</span> ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)__excuteTask:(<span class="type">void</span>(^)(<span class="type">void</span>))task &#123;</span><br><span class="line">  task();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="如何使用线程保活">如何使用线程保活</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">  <span class="comment">// 创建一个线程对象</span></span><br><span class="line">  <span class="keyword">self</span>.thread = [[WWPermenantThread alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">  [<span class="keyword">self</span>.thread excuteTask:^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务 - %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2023</span><span class="number">-02</span><span class="number">-15</span> <span class="number">10</span>:<span class="number">18</span>:<span class="number">56.211402</span>+<span class="number">0800</span> 线程保活Demo1[<span class="number">10526</span>:<span class="number">21512893</span>] 执行任务 - &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002e99680</span>&gt;&#123;number = <span class="number">9</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2023</span><span class="number">-02</span><span class="number">-15</span> <span class="number">10</span>:<span class="number">18</span>:<span class="number">56.830085</span>+<span class="number">0800</span> 线程保活Demo1[<span class="number">10526</span>:<span class="number">21512893</span>] 执行任务 - &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002e99680</span>&gt;&#123;number = <span class="number">9</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2023</span><span class="number">-02</span><span class="number">-15</span> <span class="number">10</span>:<span class="number">18</span>:<span class="number">57.279150</span>+<span class="number">0800</span> 线程保活Demo1[<span class="number">10526</span>:<span class="number">21512893</span>] 执行任务 - &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002e99680</span>&gt;&#123;number = <span class="number">9</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2023</span><span class="number">-02</span><span class="number">-15</span> <span class="number">10</span>:<span class="number">18</span>:<span class="number">58.212741</span>+<span class="number">0800</span> 线程保活Demo1[<span class="number">10526</span>:<span class="number">21512893</span>] 执行任务 - &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002e99680</span>&gt;&#123;number = <span class="number">9</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2023</span><span class="number">-02</span><span class="number">-15</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">32.672529</span>+<span class="number">0800</span> 线程保活Demo1[<span class="number">10526</span>:<span class="number">21512038</span>] -[OneViewController dealloc]</span><br><span class="line"><span class="number">2023</span><span class="number">-02</span><span class="number">-15</span> <span class="number">10</span>:<span class="number">19</span>:<span class="number">32.672800</span>+<span class="number">0800</span> 线程保活Demo1[<span class="number">10526</span>:<span class="number">21512038</span>] -[WWPermenantThread dealloc]</span><br></pre></td></tr></table></figure><h2 id="写在最后-19">写在最后</h2><p>关于如何实现线程保活的笔记就记录到这里了，如有错误请多多指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-28&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;本文主要讲一下线程保活是什么、线程保活的意义、如何实现线程保活。&lt;/p&gt;
&lt;h2 id=&quot;线程保活&quot;&gt;线程保活&lt;/h2&gt;
&lt;h3 id=&quot;线程生命周期&quot;&gt;线程生命周期&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://</summary>
      
    
    
    
    <category term="iOS" scheme="https://codersunny.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://codersunny.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【iOS重学】关于RunLoop的简单介绍</title>
    <link href="https://codersunny.com/posts/a5190dfd/"/>
    <id>https://codersunny.com/posts/a5190dfd/</id>
    <published>2023-02-13T02:28:09.000Z</published>
    <updated>2023-03-06T11:47:14.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-20">写在前面</h2><p>本文主要是记录关于RunLoop的一些简单介绍。</p><h2 id="RunLoop">RunLoop</h2><h3 id="基本认识">基本认识</h3><p>RunLoop：翻译过来叫运行时循环，指的是在程序运行过程中循环的做一些事情。</p><p>主要应用在：</p><ul><li>定时器（Timer）、PerformSelector</li><li>GCD</li><li>事件响应、手势识别、界面刷新</li><li>网络请求</li><li>AutoReleasePool</li></ul><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/02/13/1.png" alt="1"></p><p>上面是我们一个iOS程序的入口<code>main</code>函数，在<code>UIApplicationMain</code>函数中会去创建主线程的RunLoop对象，它用来保证程序不退出从而保证程序的持续执行。<br>我们可以把RunLoop运行时循环理解成一个<code>do - while</code>循环，伪代码如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">  <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="type">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 1.在休眠中等待消息</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 2.如果有消息 处理消息</span></span><br><span class="line">      </span><br><span class="line">    &#125;<span class="keyword">while</span>(retVal = <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RunLoop的基本作用：</p><ul><li>保证程序的持续运行</li><li>处理App中的各种事件（比如触摸事件、定时器等）</li><li>节省CPU资源，提高程序的性能：在有消息的时候处理消息 没有消息的时候休眠。</li></ul><h3 id="RunLoop对象">RunLoop对象</h3><p>iOS中有两套API来访问和使用RunLoop：</p><ul><li>Foundation框架：<code>NSRunLoop</code></li><li>Core Foundation框架：<code>CFRunLoopRef</code>（开源代码：<a href="https://opensource.apple.com/tarballs/CF/">https://opensource.apple.com/tarballs/CF/</a>）</li></ul><h3 id="RunLoop与线程的关系">RunLoop与线程的关系</h3><ul><li>每条线程都有唯一的与之相对应的RunLoop对象</li><li>RunLoop保存在一个全局的字典里面，线程为<code>key</code>，RunLoop为<code>value</code></li><li>线程刚创建的时候并没有RunLoop对象，而是在第一次获取RunLoop对象时去创建</li><li>RunLoop会在线程结束时销毁</li><li>主线程的RunLoop已经自动获取（创建），子线程的RunLoop默认是没有开启的</li></ul><h3 id="获取RunLoop对象">获取RunLoop对象</h3><p>Foundation框架：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSRunLoop</span> currentRunLoop]; <span class="comment">// 获取当前线程的RunLoop对象</span></span><br><span class="line">[<span class="built_in">NSRunLoop</span> mainRunLoop]; <span class="comment">// 获取主线程的RunLoop对象</span></span><br></pre></td></tr></table></figure><p>Core Foundation框架：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopGetCurrent</span>(); <span class="comment">// 获取当前线程的RunLoop对象</span></span><br><span class="line"><span class="built_in">CFRunLoopGetMain</span>();<span class="comment">// 获取主线程的RunLoop对象</span></span><br></pre></td></tr></table></figure><h3 id="RunLoop相关的类">RunLoop相关的类</h3><p>Core Foundation框架中关于RunLoop的五个类：</p><ul><li><code>CFRunLoopRef</code></li><li><code>CFRunLoopModeRef</code></li><li><code>CFRunLoopSourceRef</code></li><li><code>CFRunLoopTimerRef</code></li><li><code>CFRunLoopObserverRef</code></li></ul><div class="note green no-icon flat"><p><code>RunLoop</code>对象结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoop</span> &#123;</span><br><span class="line"><span class="type">pthread_t</span> _pthread;</span><br><span class="line">CFMutableSetRef _commonModes;</span><br><span class="line">CFMutableSetRef _commonModeItems;</span><br><span class="line">CFRunLoopModeRef _currentMode;</span><br><span class="line">CFMutableSetRef _modes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>RunLoopMode</code>结构如下：</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">CFStringRef _name<span class="comment">;</span></span><br><span class="line">CFMutableSetRef _sources0<span class="comment">;</span></span><br><span class="line">CFMutableSetRef _sources1<span class="comment">;</span></span><br><span class="line">CFMutableArrayRef _observers<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></div><p>各个类之间的关系如下图：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/02/13/2.png" alt="2"></p><h3 id="RunLoop的运行模式">RunLoop的运行模式</h3><p><code>CFRunLoopModeRef</code>表示是RunLoop的运行模式，一个RunLoop可以有若干个Mode，每个Mode里面又包含Source0、Source1、Timer、Observer。<br>RunLoop在启动时只能选择其中的一个Mode作为CurrentMode。<br>如果需要切换Mode需要退出当前RunLoop重新选择一个Mode进入。<br>不同模式下的Source0/Source1/Timer/Observer能分隔开来，互不影响。<br>如果一个Mode中没有任何Source0/Source1/Timer/Observer，这个RunLoop会立马退出。</p><div class="note green no-icon flat"><p>常见的Mode有两种：</p><p><code>NSDefaultRunLoopMode(kCFRunLoopDefaultMode)</code>：App的默认Mode，通常主线程在这个Mode下运行。<br><code>UITrackingRunLoopMode</code>：界面跟踪Mode，ScrollView的滑动，保证界面滑动时不受其他的影响。</p></div><h3 id="RunLoop的几种状态">RunLoop的几种状态</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入RunLoop</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中被唤醒</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出RunLoop</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如下可以监听RunLoop的所有状态：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CFRunLoopObserverRef observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, <span class="number">0</span>, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;kCFRunLoopEntry...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;kCFRunLoopBeforeTimers...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;kCFRunLoopBeforeSources...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;kCFRunLoopBeforeWaiting...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;kCFRunLoopAfterWaiting...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;kCFRunLoopExit...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line"><span class="built_in">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure><h3 id="RunLoop的运行逻辑">RunLoop的运行逻辑</h3><p>1、 Source0</p><ul><li>触摸事件处理</li><li>performSelector:onThread:</li></ul><p>2、Source1</p><ul><li>基于Port的线程之间的通信</li><li>系统事件的捕捉</li></ul><p>3、Timers</p><ul><li>NSTimer</li><li>performSelector：withObject：afterDelay：</li></ul><p>4、Observers</p><ul><li>用于监听RunLoop的状态</li><li>UI刷新（BeforeWaiting）</li><li>AutoReleasePool（BeforeWaiting）</li></ul><p>RunLoop的运行逻辑如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/02/13/3.png" alt="3"></p><h3 id="RunLoop在实际开发中的应用">RunLoop在实际开发中的应用</h3><ul><li>控制线程的生命周期（线程保活）</li><li>解决NSTimer在滑动时停止工作的问题</li><li>监控应用卡顿</li><li>性能优化</li></ul><h3 id="RunLoop的源码查看">RunLoop的源码查看</h3><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/02/13/4.png" alt="4"></p><p>从上面看到：RunLoop的源码入口在<code>CFRunLoopRunSpecific</code>。</p><div class="note green no-icon flat"><p><strong>注意</strong>：</p><p>1、使用Foundation框架打印出来的主线程RunLoop和Core Foundation框架打印出来的主线程RunLoop地址值不一样，原因在于Foundation框架的RunLoop是对Core Foundation框架RunLoop的一层封装。<br>2、系统事件是通过Source1来捕捉，之后分发到Source0去处理的。<br>3、RunLoop在休眠之前会去释放自动释放池和刷新UI等。<br>4、线程阻塞和RunLoop休眠不一样：线程阻塞还是在执行代码 当前线程根本没有真的休眠 RunLoop休眠真的是休眠 没有执行代码 CPU不会为此分配资源 就会省电。</p></div><h2 id="写在最后-14">写在最后</h2><p>关于RunLoop的一些基本介绍、各种模式以及它整个完整的运行逻辑就介绍到这里了，如有错误请多多指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-20&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;本文主要是记录关于RunLoop的一些简单介绍。&lt;/p&gt;
&lt;h2 id=&quot;RunLoop&quot;&gt;RunLoop&lt;/h2&gt;
&lt;h3 id=&quot;基本认识&quot;&gt;基本认识&lt;/h3&gt;
&lt;p&gt;RunLoop：翻译过来叫运行时循环，指的是在程</summary>
      
    
    
    
    <category term="iOS" scheme="https://codersunny.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://codersunny.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【iOS重学】Runtime中常用的一些API汇总</title>
    <link href="https://codersunny.com/posts/b38791c9/"/>
    <id>https://codersunny.com/posts/b38791c9/</id>
    <published>2023-01-31T07:46:11.000Z</published>
    <updated>2023-03-05T09:52:30.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-15">写在前面</h2><p>本文主要是总结一下在我们日常项目中会用到的一些关于<code>Runtime</code>的相关API，便于以后查阅。</p><h2 id="isMemberOfClass-和-isKindOfClass-区别">isMemberOfClass 和 isKindOfClass 区别</h2><p>在正式总结<code>Runtime</code>下相关API之前，先看看<code>isMemberOfClass</code> 和 <code>isKindOfClass</code>的区别：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)isMemberOfClass:(Class)cls;</span><br><span class="line">+ (<span class="type">BOOL</span>)isMemberOfClass:(Class)cls;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)isKindOfClass:(Class)cls;</span><br><span class="line">+ (<span class="type">BOOL</span>)isKindOfClass:(Class)cls;</span><br></pre></td></tr></table></figure><p>我们来看一下这几个方法的底层实现：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>-&gt;ISA() == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="keyword">self</span>-&gt;ISA(); tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例1：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Student *student = [[Student alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1 - %d&quot;</span>,[student isMemberOfClass:[Student <span class="keyword">class</span>]]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;2 - %d&quot;</span>,[student isKindOfClass:[Student <span class="keyword">class</span>]]);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;3 - %d&quot;</span>,[student isMemberOfClass:[Person <span class="keyword">class</span>]]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;4 - %d&quot;</span>,[student isKindOfClass:[Person <span class="keyword">class</span>]]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">21</span>:<span class="number">04.801267</span>+<span class="number">0800</span> SuperDemo[<span class="number">32839</span>:<span class="number">16964367</span>] <span class="number">1</span> - <span class="number">1</span></span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">21</span>:<span class="number">04.801310</span>+<span class="number">0800</span> SuperDemo[<span class="number">32839</span>:<span class="number">16964367</span>] <span class="number">2</span> - <span class="number">1</span></span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">21</span>:<span class="number">04.801347</span>+<span class="number">0800</span> SuperDemo[<span class="number">32839</span>:<span class="number">16964367</span>] <span class="number">3</span> - <span class="number">0</span></span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">21</span>:<span class="number">04.801382</span>+<span class="number">0800</span> SuperDemo[<span class="number">32839</span>:<span class="number">16964367</span>] <span class="number">4</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>例2:</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Student *student = [[Student alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1 - %d&quot;</span>,[Student isMemberOfClass:object_getClass([Student <span class="keyword">class</span>])]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;2 - %d&quot;</span>,[Student isKindOfClass:object_getClass([Student <span class="keyword">class</span>])]);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;3 - %d&quot;</span>,[Student isMemberOfClass:object_getClass([Person <span class="keyword">class</span>])]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;4 - %d&quot;</span>,[Student isKindOfClass:object_getClass([Person <span class="keyword">class</span>])]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">18.561752</span>+<span class="number">0800</span> SuperDemo[<span class="number">33188</span>:<span class="number">16979322</span>] <span class="number">1</span> - <span class="number">1</span></span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">18.562298</span>+<span class="number">0800</span> SuperDemo[<span class="number">33188</span>:<span class="number">16979322</span>] <span class="number">2</span> - <span class="number">1</span></span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">18.562390</span>+<span class="number">0800</span> SuperDemo[<span class="number">33188</span>:<span class="number">16979322</span>] <span class="number">3</span> - <span class="number">0</span></span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-31</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">18.562430</span>+<span class="number">0800</span> SuperDemo[<span class="number">33188</span>:<span class="number">16979322</span>] <span class="number">4</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure><div class="note green no-icon flat"><p><strong>注意</strong>：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[Student isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br></pre></td></tr></table></figure><p>结果返回的是：YES 因为NSObject的isa指向的是自己。</p></div><h2 id="Runtime下的一些常用API">Runtime下的一些常用API</h2><h3 id="类">类</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态创建一个类（参数：父类，类名，额外的内存空间）</span></span><br><span class="line">Class objc_allocateClassPair(Class  _Nullable __<span class="keyword">unsafe_unretained</span> superclass, <span class="keyword">const</span> <span class="type">char</span> * _Nonnull name, size_t extraBytes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个类（要在类注册之前添加成员变量）</span></span><br><span class="line"><span class="type">void</span>  objc_registerClassPair(Class  _Nonnull __<span class="keyword">unsafe_unretained</span> cls)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 销毁一个类</span></span><br><span class="line"><span class="type">void</span> objc_disposeClassPair(Class  _Nonnull __<span class="keyword">unsafe_unretained</span> cls)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 获取isa指向的Class</span></span><br><span class="line">Class object_getClass(<span class="type">id</span>  _Nullable obj)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 设置isa指向的Class</span></span><br><span class="line">Class object_setClass(<span class="type">id</span>  _Nullable obj, Class  _Nonnull __<span class="keyword">unsafe_unretained</span> cls)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个对象是否为Class</span></span><br><span class="line">object_isClass(<span class="type">id</span>  _Nullable obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个类是否为元类</span></span><br><span class="line">class_isMetaClass(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父类</span></span><br><span class="line">class_getSuperclass(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls)</span><br></pre></td></tr></table></figure><h3 id="成员变量">成员变量</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取一个实例变量</span></span><br><span class="line">Ivar class_getInstanceVariable(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, <span class="keyword">const</span> <span class="type">char</span> * _Nonnull name)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 拷贝实例变量列表（最后需要调用free释放）</span></span><br><span class="line">Ivar *class_copyIvarList(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, <span class="type">unsigned</span> <span class="type">int</span> * _Nullable outCount)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 设置和获取成员变量的值</span></span><br><span class="line"><span class="type">void</span> object_setIvar(<span class="type">id</span>  _Nullable obj, Ivar  _Nonnull ivar, <span class="type">id</span>  _Nullable value)</span><br><span class="line"><span class="type">id</span> object_getIvar(<span class="type">id</span>  _Nullable obj, Ivar  _Nonnull ivar)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态添加成员变量（已经注册的类是不能添加成员变量的）</span></span><br><span class="line"><span class="type">BOOL</span>  class_addIvar(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, <span class="keyword">const</span> <span class="type">char</span> * _Nonnull name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="type">char</span> * _Nullable types)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量的相关信息</span></span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> *ivar_getName(Ivar  _Nonnull v)</span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> *ivar_getTypeEncoding(Ivar  _Nonnull v)</span><br></pre></td></tr></table></figure><h3 id="方法">方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取一个实例方法、类方法</span></span><br><span class="line">Method class_getInstanceMethod(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, SEL  _Nonnull name)</span><br><span class="line">Method class_getClassMethod(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, SEL  _Nonnull name)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 方法实现相关操作</span></span><br><span class="line">IMP class_getMethodImplementation(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, SEL  _Nonnull name)</span><br><span class="line">IMP method_setImplementation(Method  _Nonnull m, IMP  _Nonnull imp)</span><br><span class="line"><span class="type">void</span> method_exchangeImplementations(Method  _Nonnull m1, Method  _Nonnull m2)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 拷贝方法列表（最后需要通过free来释放）</span></span><br><span class="line">Method *class_copyMethodList(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, <span class="type">unsigned</span> <span class="type">int</span> * _Nullable outCount)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态添加方法</span></span><br><span class="line"><span class="type">BOOL</span> class_addMethod(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, SEL  _Nonnull name, IMP  _Nonnull imp, <span class="keyword">const</span> <span class="type">char</span> * _Nullable types)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态替换方法</span></span><br><span class="line">IMP class_replaceMethod(Class  _Nullable __<span class="keyword">unsafe_unretained</span> cls, SEL  _Nonnull name, IMP  _Nonnull imp, <span class="keyword">const</span> <span class="type">char</span> * _Nullable types)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法的相关信息（带copy的需要调用free去释放）</span></span><br><span class="line">SEL method_getName(Method  _Nonnull m)</span><br><span class="line">IMP method_getImplementation(Method  _Nonnull m)</span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> *method_getTypeEncoding(Method  _Nonnull m)</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> method_getNumberOfArguments(Method  _Nonnull m)</span><br><span class="line"><span class="type">char</span> *method_copyReturnType(Method  _Nonnull m)</span><br><span class="line"><span class="type">char</span> *method_copyArgumentType(Method  _Nonnull m, <span class="type">unsigned</span> <span class="type">int</span> index)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择器相关</span></span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> *sel_getName(SEL  _Nonnull sel)</span><br><span class="line">SEL sel_registerName(<span class="keyword">const</span> <span class="type">char</span> * _Nonnull str)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用block作为方法实现</span></span><br><span class="line">IMP imp_implementationWithBlock(<span class="type">id</span>  _Nonnull block)</span><br><span class="line"><span class="type">id</span> imp_getBlock(IMP  _Nonnull anImp)</span><br><span class="line"><span class="type">BOOL</span> imp_removeBlock(IMP  _Nonnull anImp)</span><br></pre></td></tr></table></figure><h2 id="如何拦截按钮的点击事件">如何拦截按钮的点击事件</h2><p>hook：可以理解为就是方法交换。</p><p>按钮的点击事件 会调用到UIControl的<code>- (void)sendAction:(SEL)action to:(nullable id)target forEvent:(nullable UIEvent *)event</code>这个方法。</p><p>拦截按钮的点击我们只需要拦截<code>sendAction</code>即可。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    Method method1 = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(sendAction:to:forEvent:));</span><br><span class="line">    Method method2 = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(ww_sendAction:to:forEvent:));</span><br><span class="line">    method_exchangeImplementations(method1, method2); <span class="comment">// 调用这个方法之后会去清空之前的缓存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)ww_sendAction:(SEL)action to:(<span class="type">id</span>)target forEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:<span class="built_in">UIButton</span>.class]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;我成功hook了按钮...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> ww_sendAction:action to:target forEvent:event]; <span class="comment">// 调用原来的sendAction</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Runtime总结">Runtime总结</h2><p>Runtime在实际开发中可能用到的场景：</p><ul><li><p>利用关联对象给分类添加属性</p></li><li><p>遍历某个类的所有成员变量（可以访问私有的成员变量 比如修改UITextField的占位label/ 字典转模型/ 归档解档）</p></li><li><p>交换方法实现（主要是交换系统的方法 利用方法交换做方法找不到导致的崩溃）</p><p>…</p></li></ul><h2 id="写在最后-11">写在最后</h2><p>关于Runtime中常用的一些常用的API就总结到这里，如有错误请多多指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-15&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;本文主要是总结一下在我们日常项目中会用到的一些关于&lt;code&gt;Runtime&lt;/code&gt;的相关API，便于以后查阅。&lt;/p&gt;
&lt;h2 id=&quot;isMemberOfClass-和-isKindOfClass-区别&quot;&gt;is</summary>
      
    
    
    
    <category term="iOS" scheme="https://codersunny.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://codersunny.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【iOS重学】一篇文章讲清楚super</title>
    <link href="https://codersunny.com/posts/d1a1e187/"/>
    <id>https://codersunny.com/posts/d1a1e187/</id>
    <published>2023-01-30T08:42:21.000Z</published>
    <updated>2023-03-05T09:52:30.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-18">写在前面</h2><p>经常在网上看到<code>[super xxx]</code>这种输出什么内容等类似的面试题，本文就主要来详细剖析一下这种<code>[super xxx]</code>中<code>super</code>调用的底层原理。</p><h2 id="场景">场景</h2><p>博主这里用一个常看到的面试题来引出本文的主题：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        [<span class="variable language_">super</span> <span class="keyword">class</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1 - %@&quot;</span>,[<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;2 - %@&quot;</span>,[<span class="variable language_">super</span> <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;3 - %@&quot;</span>,[<span class="keyword">self</span> superclass]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;4 - %@&quot;</span>,[<span class="variable language_">super</span> superclass]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-30</span> <span class="number">16</span>:<span class="number">10</span>:<span class="number">51.753257</span>+<span class="number">0800</span> SuperDemo[<span class="number">27224</span>:<span class="number">16387952</span>] <span class="number">1</span> - Student</span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-30</span> <span class="number">16</span>:<span class="number">10</span>:<span class="number">51.754489</span>+<span class="number">0800</span> SuperDemo[<span class="number">27224</span>:<span class="number">16387952</span>] <span class="number">2</span> - Student</span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-30</span> <span class="number">16</span>:<span class="number">10</span>:<span class="number">51.754682</span>+<span class="number">0800</span> SuperDemo[<span class="number">27224</span>:<span class="number">16387952</span>] <span class="number">3</span> - Person</span><br><span class="line"><span class="number">2023</span><span class="number">-01</span><span class="number">-30</span> <span class="number">16</span>:<span class="number">10</span>:<span class="number">51.754821</span>+<span class="number">0800</span> SuperDemo[<span class="number">27224</span>:<span class="number">16387952</span>] <span class="number">4</span> - Person</span><br></pre></td></tr></table></figure><p>结果分析：</p><div class="note green no-icon flat"><p><code>[super class]</code> 和 <code>[self superclass]</code>打印结果分别为<code>Student</code> 和 <code>Person</code>毫无疑问。</p><p>可能大家比较好奇为什么<code>[super class]</code> 和 <code>[super superclass]</code> 的打印结果依然是<code>Student</code> 和 <code>Person</code>。</p></div><p>我们这里以<code>[super class]</code>为例来看其底层结构：</p><p>用命令<code> xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-10.0.0 Student.m</code>将Student.m文件转化为c++文件，<code>[super class]</code>底层如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">((<span class="built_in">Class</span> (*)(__rw_objc_super *, SEL))(<span class="type">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)<span class="built_in">class_getSuperclass</span>(<span class="built_in">objc_getClass</span>(<span class="string">&quot;Student&quot;</span>))&#125;, <span class="built_in">sel_registerName</span>(<span class="string">&quot;class&quot;</span>));</span><br></pre></td></tr></table></figure><p>简化之后为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">objc_msgSendSuper</span>(__rw_objc_super&#123;</span><br><span class="line">self,</span><br><span class="line"><span class="built_in">class_getSuperclass</span>(<span class="built_in">objc_getClass</span>(<span class="string">&quot;Student&quot;</span>))</span><br><span class="line">&#125;,<span class="built_in">sel_registerName</span>(<span class="string">&quot;class&quot;</span>));</span><br></pre></td></tr></table></figure><p>为了让大家更方便理解，最终结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__rw_objc_super</span> arg = &#123;</span><br><span class="line">self,</span><br><span class="line"><span class="built_in">class_getSuperclass</span>(<span class="built_in">objc_getClass</span>(<span class="string">&quot;Student&quot;</span>))</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">objc_msgSendSuper</span>(arg,<span class="built_in">sel_registerName</span>(<span class="string">&quot;class&quot;</span>));</span><br></pre></td></tr></table></figure><p>在源码中我们搜索一下<code>objc_super</code>结构体：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/30/1.png" alt="1"></p><p>从上面的分析，我们可以看到：<code>[super class]</code>中消息接收者还是<code>self</code>也就是说还是<code>Student</code>，同理<code>[super superclas]</code>打印结果还是<code>Person</code>。</p><h2 id="写在最后-13">写在最后</h2><p>关于<code>super</code>调用本质的原理我们在这片文章就分析清楚了，如有错误请多多指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-18&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;经常在网上看到&lt;code&gt;[super xxx]&lt;/code&gt;这种输出什么内容等类似的面试题，本文就主要来详细剖析一下这种&lt;code&gt;[super xxx]&lt;/code&gt;中&lt;code&gt;super&lt;/code&gt;调用的底层原</summary>
      
    
    
    
    <category term="iOS" scheme="https://codersunny.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://codersunny.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【PS学习】图层相关基本操作</title>
    <link href="https://codersunny.com/posts/c0e79a01/"/>
    <id>https://codersunny.com/posts/c0e79a01/</id>
    <published>2023-01-10T06:27:21.000Z</published>
    <updated>2023-03-05T09:52:30.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-5">写在前面</h2><p>相关文章：</p><p>1、<a href="!https://codersunny.com/posts/70b04f6f/">【PS学习】初识PS界面</a></p><p>2、<a href="!https://codersunny.com/posts/52ee9edd/">【PS学习】文件基本操作</a></p><p>3、<a href="!https://codersunny.com/posts/b55c64d0/">【PS学习】色彩基础</a></p><p>本文主要记录一下图层的一些基本操作，PS版本为【PS2020】。</p><h2 id="初识图层">初识图层</h2><h3 id="图层的显示与隐藏">图层的显示与隐藏</h3><p>【菜单栏】窗口 - 图层（快捷键<strong>F7</strong>）</p><p>如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/1.png" alt="1"></p><h3 id="改变图层缩略图大小">改变图层缩略图大小</h3><p>选择图层 - 右击 - 改变缩略图大小</p><p>如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/2.png" alt="2"></p><div class="note green no-icon flat"><p>新建的图层默认是透明的，如何想要给当前图层设置颜色，在选择颜色之后填充即可改变图层的颜色。</p><p><strong>如何填充？</strong></p><p>快捷键：Shift + F5</p><p>如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/3.png" alt="3"></p></div><h3 id="如何选择多个图层进行编辑">如何选择多个图层进行编辑</h3><p>Shift + 需要选择的图层（连续性）</p><p>command + 需要选择的图层（非连续性）</p><h3 id="如何复制一个图层">如何复制一个图层</h3><p>图层 - 右击 - 复制图层</p><p>option + 需要复制的图层 - 拖动</p><h3 id="修改图层的名称和颜色">修改图层的名称和颜色</h3><p>图层面板 - 选择图层 - 右键选择颜色（可以用来突出图层）</p><p>如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/7.png" alt="7"></p><h3 id="复制图层">复制图层</h3><ol><li>选择图层 - 右键 - 复制图层</li><li>command + J</li></ol><h3 id="锁定图层">锁定图层</h3><p>锁定透明像素：锁定之后 画笔工具无法在透明区域进行绘制。</p><p>锁定图像像素：锁定之后 无法在该图层上使用画笔工具。</p><p>锁定位置：锁定之后 图像的位置就不能移动。</p><p>锁定全部：包括锁定透明像素、图像像素、位置等。</p><p>如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/8.png" alt="8"></p><h3 id="查找图层">查找图层</h3><p>根据不同类型去过滤图层 方便快速找到我们需要的图层。</p><p>如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/9.png" alt="9"></p><h3 id="对齐图层">对齐图层</h3><ol><li>图层面板选择需要对齐的图层 - 【工具栏】移动工具（V） - 【工具选项栏】选择对齐方式</li><li>【菜单栏】图层 - 对齐 - 选择对齐方式</li></ol><p>如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/10.png" alt="10"></p><h3 id="分布图层">分布图层</h3><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/11.png" alt="11"></p><h3 id="图层的复制-粘贴功能">图层的复制/粘贴功能</h3><ol><li>command + C 复制 / command + D 粘贴</li><li>拖拽需要复制的图层到另一个图层上</li><li>【图层面板】- 选择图层 - 右键复制图层</li></ol><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/18.png" alt="18"></p><h3 id="原位粘贴">原位粘贴</h3><p>command + V - 【菜单栏】编辑 - 选择性粘贴 - 原位粘贴</p><h2 id="背景图层">背景图层</h2><h3 id="背景图层和普通图层的区别">背景图层和普通图层的区别</h3><ol><li>背景图层是锁定的，图层右边有一个【锁头】的标志。</li><li>背景图层不能改变叠加顺序。</li><li>背景图层不能改变不透明度等。</li></ol><p>如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/4.png" alt="4"></p><h3 id="背景图层转化为普通图层">背景图层转化为普通图层</h3><p>点击背景图层右边的【锁头】标志。</p><h2 id="选择-取消选择图层">选择/取消选择图层</h2><p>工具栏 - 选择移动工具（V）- 选择图层进行移动。</p><div class="note green no-icon flat"><p>当两个图层重叠时需要移动下面的图层，需要将【工具选项栏】的【自动选择】取消，在图层面板选择需要移动的图层进行移动。</p><p>如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/5.png" alt="5"></p></div><h2 id="链接图层">链接图层</h2><p>链接图层：两个图层形成一个图层组，操作其中一个图层，另一个图层也会跟着移动。</p><p>链接：选中需要链接的图层 点击【链接图层】。</p><p>取消链接：选中链接的图层 再次点击【链接图层】。</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/6.png" alt="6"></p><h2 id="图层组">图层组</h2><p>如何创建图层组？</p><ol><li>选中需要的图层 - 点击【图层面板】创建新组</li><li>选中需要的图层 - command + G</li></ol><div class="note green no-icon flat"><p>注意：图层组是可以叠加的。</p></div><h2 id="图层样式">图层样式</h2><ol><li>双击图层空白处 - 图层样式</li><li>选择图层 - 【图层面板】添加图层样式 - 混合选项</li></ol><p>如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/12.png" alt="12"></p><div class="note red no-icon flat"><p><strong>如何复制添加的一些图层样式的效果到其他图层？</strong></p><p>option + 图层样式效果 + 拖到到需要的图层下</p><p>如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/13.png" alt="13"></p></div><h3 id="缩放图层样式大小">缩放图层样式大小</h3><p>【菜单栏】图层 - 图层样式 - 缩放效果</p><p>如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/14.png" alt="14"></p><h3 id="将图层样式创建为图层">将图层样式创建为图层</h3><p>【菜单栏】图层 - 图层样式 - 创建图层（有几种样式就会转化为几种图层）</p><p>如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/15.png" alt="15"></p><p>将图层样式转化为图层之后 我们可以单独对某个图层进行调节 比如色相/饱和度（快捷键：command + U）</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/16.png" alt="16"></p><h3 id="图层样式的叠加">图层样式的叠加</h3><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/2023/01/10/17.png" alt="17"></p><div class="note green no-icon flat"><p>如果图层样式面板显示的不是所有的效果 可以选择左下角的fx - 显示所有效果</p><p>option + 复位：取消本次所有图层样式的所有设置。</p></div><h2 id="写在最后">写在最后</h2><p>关于图层的一些基本操作的笔记记录到这里就结束了，如有错误请多多指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-5&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;相关文章：&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;!https://codersunny.com/posts/70b04f6f/&quot;&gt;【PS学习】初识PS界面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;!https://co</summary>
      
    
    
    
    <category term="PS" scheme="https://codersunny.com/categories/PS/"/>
    
    
    <category term="PS" scheme="https://codersunny.com/tags/PS/"/>
    
  </entry>
  
  <entry>
    <title>【工具使用】Reveal工具的使用介绍</title>
    <link href="https://codersunny.com/posts/745be31f/"/>
    <id>https://codersunny.com/posts/745be31f/</id>
    <published>2022-12-26T12:02:46.000Z</published>
    <updated>2023-03-05T09:52:30.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-30">写在前面</h2><p>有时候我们可能想要分析其他APP的一些整体View结构，就像在Xcode分析我们自己的APP一样能够清楚看到个层级结构，Reveal这个APP主要就是这个功能：用来分析APP的层级结构。</p><h2 id="Reveal">Reveal</h2><p>Reveal APP 官网：<a href="https://revealapp.com/">https://revealapp.com/</a></p><p>Reveal APP下载地址：<a href="https://revealapp.com/download/">https://revealapp.com/download/</a></p><p>这个是官网正版，可以免费试用14天。</p><h2 id="Reveal的基本使用">Reveal的基本使用</h2><ul><li><p>打开Reveal，菜单栏Help - Show Reveal Framework in Finder</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/1.png" alt="1"></p></li></ul><h3 id="真机下的配置">真机下的配置</h3><ul><li><p>找到RevealServer.framework - ios-arm64 - RevealServer.framework</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/2.png" alt="2"></p></li><li><p>打开iFunBox - 将RevealServer.framework复制到iFunBox中 Library/Frameworks中</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/3.png" alt="3"></p></li><li><p>在手机Cydia中搜索Reveal2Loader进行安装</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/4.png" alt="4"></p></li><li><p>手机设置 - Reveal - Enabled Applications - 选择允许Reveal访问的APP</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/5.png" alt="5"></p></li><li><p>在手机终端执行 - killall SpringBoard</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/6.png" alt="6"></p></li></ul><h3 id="模拟器下的配置">模拟器下的配置</h3><ul><li><p>找到RevealServer.framework - ios-arm64_x86_64-simulator - RevealServer.framework</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/7.png" alt="7"></p></li><li><p>在Xcode配置中导入RevealServer.framework</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/8.png" alt="8"></p></li></ul><h3 id="Reveal的使用">Reveal的使用</h3><p>通过上面的介绍配置完成之后，我们就可以正式使用Reveal了。</p><p>打开手机上的某个APP - 打开Reveal - 会在Reveal看到我们刚打开的APP 如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1226/9.png" alt="9"></p><p>上面一个是通过网络连接、一个是通过USB连接，我们选择更快的USB连接即可使用Reveal。</p><h2 id="写在最后-20">写在最后</h2><p>关于Reveal使用前的配置就简单介绍到这里啦，如有错误请多多指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-30&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;有时候我们可能想要分析其他APP的一些整体View结构，就像在Xcode分析我们自己的APP一样能够清楚看到个层级结构，Reveal这个APP主要就是这个功能：用来分析APP的层级结构。&lt;/p&gt;
&lt;h2 id=&quot;Reve</summary>
      
    
    
    
    <category term="工具使用" scheme="https://codersunny.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="逆向" scheme="https://codersunny.com/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="工具使用" scheme="https://codersunny.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>【iOS重学】方法缓存cache_t的分析</title>
    <link href="https://codersunny.com/posts/39324100/"/>
    <id>https://codersunny.com/posts/39324100/</id>
    <published>2022-12-21T07:55:12.000Z</published>
    <updated>2023-03-05T09:52:30.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-25">写在前面</h2><p>本文我们主要来分析一下方法缓存<code>cache_t</code>的数据结构是什么样的，苹果是怎么实现方法缓存的。</p><h2 id="Class的结构">Class的结构</h2><p>在<a href="!https://codersunny.com/posts/b55a18a8/">【iOS重学】窥探Class的结构</a>文中，我们主要分析了<code>Class</code>的结构，结构主要如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">  Class isa; <span class="comment">// isa</span></span><br><span class="line">  Class superclass; <span class="comment">// superclass</span></span><br><span class="line">  cache_t cache; <span class="comment">// 方法缓存</span></span><br><span class="line">  class_data_bits_t bits; <span class="comment">// 具体的类信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>isa</code>、<code>superclass</code>、<code>bits</code>我们都已经讲过了，相关的文章可以参考<a href="!https://codersunny.com/posts/9efafc5a/">【iOS重学】详细分析isa和superclass</a>和<a href="!https://codersunny.com/posts/8948fead/">【iOS重学】class_rw_ext_t结构详解</a>，现在我们就来主要分析一下方法缓存<code>cache_t</code>。</p><h2 id="方法缓存cache-t">方法缓存cache_t</h2><p>我们都知道查找一个方法的流程大概是：根据<code>isa</code>指针找到类对象，在类对象上找是否有对应的方法，如果没有找到就根据<code>superclass</code>指针找到其父类查看是否有方法实现，以此往上找：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1221/2.png" alt="2"></p><p>但是如果每次都这么寻找，效率肯定会很低，所以苹果就有自己的一套方法缓存机制，调用过的方法我们会缓存起来方便下次调用提高效率。</p><h3 id="cache-t结构">cache_t结构</h3><p>方法缓存<code>cache_t</code>结构如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1221/1.png" alt="1"></p><p>主要结构我们可以看成如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cache_t</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cache_t</span> &#123;</span><br><span class="line">explicit_atomic&lt;<span class="type">mask_t</span>&gt; _maybeMask; <span class="comment">// 散列表的长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __LP64__</span></span><br><span class="line">  <span class="type">uint16_t</span>                _flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">uint16_t</span>                _occupied; <span class="comment">// 已缓存的方法数量</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">bucket_t</span> *<span class="built_in">buckets</span>() <span class="type">const</span>; <span class="comment">// 散列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucket_t</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bucket_t</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __arm64__</span></span><br><span class="line">    explicit_atomic&lt;<span class="type">uintptr_t</span>&gt; _imp;</span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line">    explicit_atomic&lt;<span class="type">uintptr_t</span>&gt; _imp;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="苹果如何实现方法缓存">苹果如何实现方法缓存</h3><p>苹果是利用【散列表】来存储曾经调用过的方法，这样可以提高方法的查找速度。</p><p>散列表的结构如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1221/3.png" alt="3"></p><p>方法缓存的基本步骤为：</p><ul><li>通过<code>SEL &amp; _maybeMask</code>得到方法在散列表里面对应的索引值<code>index</code>。</li><li>调用方法的时候通过<code>index</code>放在散列表的具体位置。</li></ul><h3 id="具体场景">具体场景</h3><p>我们这里列举一个具体的例子并结合方法缓存的底层代码来详细说明整个过程。</p><p>首先我们根据底层源码来仿照写一个方法缓存的结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ww_bucket_t</span> &#123;<span class="comment">// 相当于bucket_t</span></span><br><span class="line">    SEL _sel;</span><br><span class="line">    IMP _imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ww_cache_t</span> &#123;<span class="comment">// 相当于cache_t</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ww_bucket_t</span>  *buckets;</span><br><span class="line">    <span class="type">uint32_t</span>            _maybeMask;</span><br><span class="line">    <span class="type">uint16_t</span>            _flags;</span><br><span class="line">    <span class="type">uint16_t</span>            _occupied;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ww_class_data_bits_t</span> &#123;<span class="comment">// 相当于class_data_bits_t</span></span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ww_objc_class</span>&#123;<span class="comment">// 相当于objc_class</span></span><br><span class="line">    Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">ww_cache_t</span> cache;</span><br><span class="line">    <span class="type">ww_class_data_bits_t</span> bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体的场景代码如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">Class personClass = [Person <span class="keyword">class</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ww_objc_class *ww_class = (__bridge <span class="keyword">struct</span> ww_objc_class *)(personClass);</span><br><span class="line">uint32_t index1 = ((<span class="type">long</span> <span class="type">long</span>)<span class="keyword">@selector</span>(init) &amp; ww_class-&gt;cache._maybeMask);</span><br><span class="line"><span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; ww_class-&gt;cache._maybeMask; i++) &#123;</span><br><span class="line">    <span class="keyword">struct</span> ww_bucket_t bucket = ww_class-&gt;cache.buckets[i];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;索引值：%u - SEL：%@ - IMP：%p&quot;</span>,i, <span class="built_in">NSStringFromSelector</span>(bucket._sel),bucket._imp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;已缓存的方法个数：%hu - 散列表实际长度：%u &quot;</span>,ww_class-&gt;cache._occupied,ww_class-&gt;cache._maybeMask);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">[person personTest];</span><br><span class="line">uint32_t index2 = ((<span class="type">long</span> <span class="type">long</span>)<span class="keyword">@selector</span>(personTest) &amp; ww_class-&gt;cache._maybeMask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; ww_class-&gt;cache._maybeMask; i++) &#123;</span><br><span class="line">    <span class="keyword">struct</span> ww_bucket_t bucket = ww_class-&gt;cache.buckets[i];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;索引值：%u - SEL：%@ - IMP：%p&quot;</span>,i, <span class="built_in">NSStringFromSelector</span>(bucket._sel),bucket._imp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;已缓存的方法个数：%hu - 散列表实际长度：%u &quot;</span>,ww_class-&gt;cache._occupied,ww_class-&gt;cache._maybeMask);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;--------------------------&quot;</span>);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.814393</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 索引值：<span class="number">0</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815222</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 索引值：<span class="number">1</span> - SEL：init - IMP：<span class="number">0x7fe150</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815306</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 索引值：<span class="number">2</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815359</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 已缓存的方法个数：<span class="number">1</span> - 散列表实际长度：<span class="number">3</span> </span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815406</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] ----------------------</span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815450</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] -[Person personTest]</span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815493</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 索引值：<span class="number">0</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815646</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 索引值：<span class="number">1</span> - SEL：init - IMP：<span class="number">0x7fe150</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815704</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 索引值：<span class="number">2</span> - SEL：personTest - IMP：<span class="number">0xbbb0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815753</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] 已缓存的方法个数：<span class="number">2</span> - 散列表实际长度：<span class="number">3</span> </span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">17.815794</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79639</span>:<span class="number">8983291</span>] --------------------------</span><br></pre></td></tr></table></figure><p>对照源码来分析一下这个打印结果：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cache_t::insert</span><span class="params">(SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...... <span class="comment">// 此处省略了一些无关代码</span></span><br><span class="line">  <span class="type">mask_t</span> newOccupied = <span class="built_in">occupied</span>() + <span class="number">1</span>; <span class="comment">// 记录新的缓存方法数量</span></span><br><span class="line">  <span class="type">unsigned</span> oldCapacity = <span class="built_in">capacity</span>(), capacity = oldCapacity;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">isConstantEmptyCache</span>())) &#123; <span class="comment">// 第一次进来缓存为空的</span></span><br><span class="line">      <span class="keyword">if</span> (!capacity) capacity = INIT_CACHE_SIZE; <span class="comment">// 计算申请空间的大小</span></span><br><span class="line">      <span class="built_in">reallocate</span>(oldCapacity, capacity, <span class="comment">/* freeOld */</span><span class="literal">false</span>); <span class="comment">// 申请空间</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">fastpath</span>(newOccupied + CACHE_END_MARKER &lt;= <span class="built_in">cache_fill_ratio</span>(capacity))) &#123; <span class="comment">// 已经开辟的空间还没有缓存满 可以继续缓存</span></span><br><span class="line">      <span class="comment">// Cache is less than 3/4 or 7/8 full. Use it as-is.</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CACHE_ALLOW_FULL_UTILIZATION</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (capacity &lt;= FULL_UTILIZATION_CACHE_SIZE &amp;&amp; newOccupied + CACHE_END_MARKER &lt;= capacity) &#123;</span><br><span class="line">      <span class="comment">// Allow 100% cache utilization for small buckets. Use it as-is.</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 已经开辟的空间已经缓存满了 进行双倍扩容</span></span><br><span class="line">      capacity = capacity ? capacity * <span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line">      <span class="keyword">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">          capacity = MAX_CACHE_SIZE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">reallocate</span>(oldCapacity, capacity, <span class="literal">true</span>); <span class="comment">// 开辟新的缓存空间</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bucket_t</span> *b = <span class="built_in">buckets</span>();<span class="comment">// 取出方法缓存列表buckets</span></span><br><span class="line">  <span class="type">mask_t</span> m = capacity - <span class="number">1</span>; <span class="comment">// 计算散列表实际的长度maybemask</span></span><br><span class="line">  <span class="type">mask_t</span> begin = <span class="built_in">cache_hash</span>(sel, m); <span class="comment">// 使用散列表计算插入的位置</span></span><br><span class="line">  <span class="type">mask_t</span> i = begin; <span class="comment">// i表示插入的位置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">fastpath</span>(b[i].<span class="built_in">sel</span>() == <span class="number">0</span>)) &#123; <span class="comment">// 如果插入的位置是空的 表示可以插入 在当前索引值处插入该方法</span></span><br><span class="line">          <span class="built_in">incrementOccupied</span>();</span><br><span class="line">          b[i].<span class="built_in">set</span>&lt;Atomic, Encoded&gt;(b, sel, imp, <span class="built_in">cls</span>());</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (b[i].<span class="built_in">sel</span>() == sel) &#123; <span class="comment">// 判断其他线程是否缓存过该方法</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="built_in">fastpath</span>((i = <span class="built_in">cache_next</span>(i, m)) != begin)); <span class="comment">// 如果i位置没有插入成功 通过cache_next找下一个可以插入的位置</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">bad_cache</span>(receiver, (SEL)sel);<span class="comment">// 如果do/while循环走完了都没有找到可以插入的位置就缓存失败</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子分析：</p><ul><li><p>当调用方法<code>init</code>的时候，会调用到上面的源码<code>cache_t::insert</code>方法，此时新的已缓存的方法数<code>newOccupied == 1</code> ，容量<code>capacity == 0</code>。</p></li><li><p>因为是第一次进来所以之前没有缓存会调用到<code>slowpath(isConstantEmptyCache()</code>里面。</p></li><li><p>去计算散列表容量<code>capacity</code>的大小：<code>capacity = INIT_CACHE_SIZE</code>。</p><div class="note green no-icon flat"><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1221/4.png" alt="4"></p><p><code>INIT_CACHE_SIZE</code>是1向左移动<code>INIT_CACHE_SIZE_LOG2</code>位，那就是4，所以<code>capacity</code>的值为4。</p></div></li><li><p>调用<code>reallocate</code>方法去申请空间。</p></li><li><p>根据我们上面讲到的散列表的索引值计算方式<code>cache_hash(sel, m)</code>去获取<code>init</code>方法在散列表里面的索引值<code>begin</code>。</p></li><li><p>如果散列表当前位置是空的可以插入就把<code>init</code>方法插入到当前位置。</p></li></ul><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1221/5.png" alt="5"></p><p>调用<code>init</code>时，我们根据方法缓存散列表索引值的计算方式看到<code>init</code>方法的索引值为：1，然后看打印结果:</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1221/6.png" alt="6"></p><p>索引值为1的位置确实缓存的是我们刚调用的<code>init</code>方法。</p><p>同理当调用<code>personTest</code>时，我们根据方法缓存散列表计算索引值的计算方式看到<code>personTest</code>方法的索引值为：2，然后对照打印结果索引值为2的位置确实缓存的是<code>personTest</code>方法。</p><p>现在我们继续调用<code>personTest1</code>方法，如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[person personTest1];</span><br><span class="line">uint32_t index3 = ((<span class="type">long</span> <span class="type">long</span>)<span class="keyword">@selector</span>(personTest1) &amp; ww_class-&gt;cache._maybeMask);</span><br><span class="line"><span class="comment">//        [person personTest2];</span></span><br><span class="line"><span class="comment">//        [person personTest3];</span></span><br><span class="line"><span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; ww_class-&gt;cache._maybeMask; i++) &#123;</span><br><span class="line">    <span class="keyword">struct</span> ww_bucket_t bucket = ww_class-&gt;cache.buckets[i];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;索引值：%u - SEL：%@ - IMP：%p&quot;</span>,i, <span class="built_in">NSStringFromSelector</span>(bucket._sel),bucket._imp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;已缓存的方法个数：%hu - 散列表实际长度：%u &quot;</span>,ww_class-&gt;cache._occupied,ww_class-&gt;cache._maybeMask);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.509028</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] -[Person personTest1]</span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515237</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 索引值：<span class="number">0</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515293</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 索引值：<span class="number">1</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515343</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 索引值：<span class="number">2</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515390</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 索引值：<span class="number">3</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515440</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 索引值：<span class="number">4</span> - SEL：personTest1 - IMP：<span class="number">0xba60</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515486</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 索引值：<span class="number">5</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515531</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 索引值：<span class="number">6</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">00.515577</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">79672</span>:<span class="number">8987189</span>] 已缓存的方法个数：<span class="number">1</span> - 散列表实际长度：<span class="number">7</span> </span><br></pre></td></tr></table></figure><p>我们发现：已缓存的方法个数为1，散列表实际长度变成了7，我们发现之前缓存的方法被清空了并且扩容了，我们来对照源码来看一下它是不是该去扩容并且清空之前的缓存了。</p><p>在这里我们需要重点看一下已经开辟的空间是否缓存满的判断：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fastpath</span>(newOccupied + CACHE_END_MARKER &lt;= <span class="built_in">cache_fill_ratio</span>(capacity))</span><br></pre></td></tr></table></figure><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1221/7.png" alt="7"></p><p>当我们调用了<code>init</code>时候，<code>capacity</code>的值为4。</p><ul><li><p>当调用<code>personTest1</code>方法时候，我们要去根据<code>newOccupied + CACHE_END_MARKER &lt;= cache_fill_ratio(capacity)</code>来判断之前开辟的缓存空间是否还足够，<code>newOccupied == 3</code>，<code>CACHE_END_MARKER == 1</code>，显然缓存空间不够，所以我们需要进行扩容，那么<code>capacity == 8</code>。</p></li><li><p>调用<code>reallocate</code>去重新分配新的缓存空间，并且清空之前的缓存。</p><div class="note green no-icon flat"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cache_t::reallocate</span><span class="params">(<span class="type">mask_t</span> oldCapacity, <span class="type">mask_t</span> newCapacity, <span class="type">bool</span> freeOld)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bucket_t</span> *oldBuckets = <span class="built_in">buckets</span>();</span><br><span class="line">    <span class="type">bucket_t</span> *newBuckets = <span class="built_in">allocateBuckets</span>(newCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT</span>(newCapacity &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ASSERT</span>((<span class="type">uintptr_t</span>)(<span class="type">mask_t</span>)(newCapacity<span class="number">-1</span>) == newCapacity<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setBucketsAndMask</span>(newBuckets, newCapacity - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (freeOld) &#123;</span><br><span class="line">        <span class="built_in">collect_free</span>(oldBuckets, oldCapacity); <span class="comment">// 释放之前的缓存空间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>调用<code>personTest1</code>时，根据方法缓存散列表计算索引值的计算方式看到<code>personTest1</code>方法的索引值为：4,对照打印结果看到索引值为4的位置确实存放了<code>personTest1</code>方法：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.334284</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 索引值：<span class="number">0</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.335782</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 索引值：<span class="number">1</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.335872</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 索引值：<span class="number">2</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.335940</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 索引值：<span class="number">3</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.336055</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 索引值：<span class="number">4</span> - SEL：personTest1 - IMP：<span class="number">0xb510</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.336156</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 索引值：<span class="number">5</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.336222</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 索引值：<span class="number">6</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">22.336292</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80094</span>:<span class="number">9027062</span>] 已缓存的方法个数：<span class="number">1</span> - 散列表实际长度：<span class="number">7</span> </span><br></pre></td></tr></table></figure></li><li><p>再调用<code>personTest2</code>、<code>personTest3</code>时，我们计算索引值分别为0、4，但是索引值为4的位置已经有内容了，所以我们会根据<code>cache_next</code>去找到合适的索引值：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CACHE_END_MARKER</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">mask_t</span> <span class="title">cache_next</span><span class="params">(<span class="type">mask_t</span> i, <span class="type">mask_t</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i+<span class="number">1</span>) &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __arm64__</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">mask_t</span> <span class="title">cache_next</span><span class="params">(<span class="type">mask_t</span> i, <span class="type">mask_t</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i ? i<span class="number">-1</span> : mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<code>(4+1) &amp; mask</code>得到<code>personTest3</code>的索引值为5，对照打印结果：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.305299</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 索引值：<span class="number">0</span> - SEL：personTest2 - IMP：<span class="number">0xb540</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.305390</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 索引值：<span class="number">1</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.317936</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 索引值：<span class="number">2</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.318011</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 索引值：<span class="number">3</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.318081</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 索引值：<span class="number">4</span> - SEL：personTest1 - IMP：<span class="number">0xb5b0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.318147</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 索引值：<span class="number">5</span> - SEL：personTest3 - IMP：<span class="number">0xb510</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.318214</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 索引值：<span class="number">6</span> - SEL：(null) - IMP：<span class="number">0x0</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-22</span> <span class="number">15</span>:<span class="number">24</span>:<span class="number">41.318280</span>+<span class="number">0800</span> RuntimeDemo[<span class="number">80143</span>:<span class="number">9031426</span>] 已缓存的方法个数：<span class="number">3</span> - 散列表实际长度：<span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="cache-t总结">cache_t总结</h3><p>方法缓存散列表其实就是利用空间来换时间，提高了方法查找的效率。</p><h2 id="写在最后-17">写在最后</h2><p>关于方法缓存的底层实现我们就写到这里了，希望对大家有所帮助，如有错误请多多指教。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-25&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;本文我们主要来分析一下方法缓存&lt;code&gt;cache_t&lt;/code&gt;的数据结构是什么样的，苹果是怎么实现方法缓存的。&lt;/p&gt;
&lt;h2 id=&quot;Class的结构&quot;&gt;Class的结构&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;!</summary>
      
    
    
    
    <category term="iOS" scheme="https://codersunny.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://codersunny.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【iOS逆向】Cycript的基本使用</title>
    <link href="https://codersunny.com/posts/7495500c/"/>
    <id>https://codersunny.com/posts/7495500c/</id>
    <published>2022-12-10T10:20:54.000Z</published>
    <updated>2023-03-05T09:52:30.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-8">写在前面</h2><p>本文主要是介绍一下逆向中Cycript的基本用法。</p><h2 id="简单介绍">简单介绍</h2><p>Cycript是OC、C++、JS、Java等多种语法的一个混合物，它是用来探索、修改、调试当前正在运行的APP，这个在我们以后逆向的过程中会经常使用到，关于Cycript的更多介绍大家可以参考<a href="!http://www.cycript.org/">Cycript官网</a>。</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/1.png" alt="1"></p><h2 id="安装Cycript">安装Cycript</h2><p>在Cydia里面搜索Cycript进行下载，如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/2.png" alt="2"></p><h2 id="Cycript的基本使用">Cycript的基本使用</h2><h3 id="Cycript的开启和关闭">Cycript的开启和关闭</h3><p>1、开启</p><ul><li>保持Mac和iPhone的安全连接</li><li>使用命令<code>cycript -p 进程ID</code>或<code>cycript -p 进程名称</code></li></ul><div class="note green no-icon flat"><p>如果不太了解Mac和iPhone怎么保持连接的，可以参考博主的另一篇文章：<a href="!https://codersunny.com/posts/7df93f3b/">【iOS逆向】如何让Mac和iPhone建立安全连接</a>。</p></div><p>如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/3.png" alt="3"></p><p>这样我们就处于一个Cycript的语法环境。</p><p>2、关闭</p><p>快捷键：<code>control + D</code></p><p>3、清屏</p><p>快捷键：<code>command + R</code></p><h3 id="查看进程的ID和名称">查看进程的ID和名称</h3><p>在以后逆向中，我们需要使用<code>cycript -p 进程ID</code>或<code>cycript -p 进程名称</code>来探究某个APP，那么这个进程ID和进程名称我们应该从哪里获取呢。</p><p>1、在Cydia中搜索<code>adv_cmds</code>并安装</p><p>2、使用<code>ps</code>相关命令查看</p><div class="note pink no-icon flat"><p>列出所有进程：<code>ps -A</code></p><p>根据关键词显示某些进程：<code>ps -A|grep 关键词</code></p></div><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/4.png" alt="4"></p><p>我们这里以【喜马拉雅】APP为例：7091就是进程ID，ting就是进程名称，由于进程ID可能随时会发生变化，建议以后使用进程名称。</p><div class="note pink no-icon flat"><p><strong>注意</strong>：要想或者某个APP的进程名称、ID，必须要打开这个APP。</p></div><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/5.png" alt="5"></p><p>这样我们就可以监听这个进程了。</p><h3 id="Cycript中常用的语法">Cycript中常用的语法</h3><ul><li>获取当前进程的Application</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">UIApplication</span> sharedApplication] 或 <span class="built_in">UIApp</span></span><br></pre></td></tr></table></figure><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/6.png" alt="6"></p><ul><li>定义变量</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var 变量名 = 变量值</span><br></pre></td></tr></table></figure><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/7.png" alt="7"></p><p>这样在当前内存环境下，只要我们输入<code>app</code>就可以获取window。</p><ul><li>获取当前APP的RootViewController</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIApp</span>.keyWindow.rootViewController</span><br></pre></td></tr></table></figure><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/8.png" alt="8"></p><ul><li>根据内存地址获取对象</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">#内存地址</span><br></pre></td></tr></table></figure><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/9.png" alt="9"></p><ul><li>查看对象的所有成员变量</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">*对象</span><br><span class="line">或</span><br><span class="line">*#对象的内存地址</span><br></pre></td></tr></table></figure><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/10.png" alt="10"></p><ul><li>递归打印view的所有子控件</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIApp</span>.keyWindow.recursiveDescription().toString()</span><br></pre></td></tr></table></figure><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/11.png" alt="11"></p><ul><li>筛选中某种类型的对象</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">choose(<span class="built_in">UIViewController</span>)</span><br></pre></td></tr></table></figure><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/12.png" alt="12"></p><div class="note green no-icon flat"><p>这里打印的是当前在内存里面的VC，没有被创建的VC是不会被打印出来的。</p></div><h3 id="封装Cycript文件">封装Cycript文件</h3><p>一般我们会把一些常用的cycript语法封装在.cy文件中，使用起来会方便很多，具体步骤如下：</p><ul><li>封装好.cy文件</li><li>复制.cy文件到iFunBox的目录<code>usr/lib/cycript0.9</code>里面</li><li>关掉当前进程 重新进入：cycript -p 进程名称</li><li>导入该文件：@import cy文件</li></ul><h3 id="MJCycript文件">MJCycript文件</h3><p>大佬已经把一些常用的、实用的相关函数给封装好了，大家可以去下载<a href="https://github.com/CoderMJLee/mjcript">Github</a>。</p><p>按照我们上面讲的方式导入就可以使用：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/13.png" alt="13"></p><p>现在我们来看一下例子：如何创建一个View并把它添加到APP上。</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1210/14.png" alt="14"></p><h2 id="写在最后-2">写在最后</h2><p>关于Cycript的简单介绍我们就分享到这里了，如有错误请多多指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-8&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;本文主要是介绍一下逆向中Cycript的基本用法。&lt;/p&gt;
&lt;h2 id=&quot;简单介绍&quot;&gt;简单介绍&lt;/h2&gt;
&lt;p&gt;Cycript是OC、C++、JS、Java等多种语法的一个混合物，它是用来探索、修改、调试当前正在运行的A</summary>
      
    
    
    
    <category term="逆向" scheme="https://codersunny.com/categories/%E9%80%86%E5%90%91/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="逆向" scheme="https://codersunny.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>【iOS逆向】最全的SSH通信过程</title>
    <link href="https://codersunny.com/posts/beccfc53/"/>
    <id>https://codersunny.com/posts/beccfc53/</id>
    <published>2022-12-09T08:36:32.000Z</published>
    <updated>2023-03-05T09:52:30.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-11">写在前面</h2><p>在<a href="https://codersunny.com/posts/7df93f3b/">【iOS逆向】如何让Mac和iPhone建立安全连接</a>文章中我们主要讲了Mac和iPhone如何建立安全连接，让我们在Mac上可以通过命令来控制iPhone，但是其实我们使用相关登录命令到登录到iPhone中间是有一个过程的，我们本篇文章就是来分析一下这个过程是什么样的，这个过程包括：</p><ul><li>建立安全连接</li><li>客户端认证</li></ul><h2 id="建立安全连接">建立安全连接</h2><p>在建立安全连接的过程中，服务器会提供自己的身份证明：公钥信息。</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1209/1.png" alt="1"></p><p>如果客户端并没有保存过服务器的公钥信息，会出现如下提示：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1209/2.png" alt="2"></p><p>这其实是在问我们是否需要保存这个公钥信息，我们选择【yes】之后保存，在客户端的ssh文件中查看相应的内容：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1209/3.png" alt="3"></p><p>如果是首次进行该操作，会提示我们输入密码进行登录。</p><h2 id="客户端认证">客户端认证</h2><p>SSH提供了两种认证的方式：</p><p>1、密码登录的认证方式</p><p>2、基于【密钥】的认证方式</p><div class="note pink no-icon flat"><p>SSH会优先使用密钥的认证方式，如果认证失败才会采用密码登录的方式进行认证。</p></div><p>我们这里重点来说一下基于密钥的认证方式是怎么样的。</p><h3 id="客户端生成公钥和私钥信息">客户端生成公钥和私钥信息</h3><p>1、通过下面的方式查看客户端是否生成过公钥和密钥：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1209/4.png" alt="4"></p><p>如果没有生成，通过命令<code>ssh-keygen</code>来生成公钥和私钥信息，如果已经生成，直接到第二步。</p><p>2、使用命令<code>ssh-copy-id root@服务器ip地址</code>将公钥信息追加到授权文件尾部，如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1209/5.png" alt="5"></p><p>我们来验证一下客户端和服务端存储的信息是否一致？</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1209/6.png" alt="6"></p><p>完成上述操作后，下次登录到iPhone就不再需要密码了。</p><div class="note orange no-icon flat"><p>如果按照上面方式配置了还是需要密码登录，需要使用下面操作修改一下权限（在iPhone的root账户下）：</p><p><code>chmod 755 ~</code></p><p><code>chmod 755 ~/.ssh</code></p><p><code>chmod 644 ~/.ssh/authorized_keys</code></p></div><h2 id="删除客户端保存的服务器的公钥信息">删除客户端保存的服务器的公钥信息</h2><p>有时候提供服务器的身份信息会发生变化，我们可能需要删掉客户端保存的公钥信息：</p><p>第一种方式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~./ssh</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line">vim known_hosts(找到对应的信息进行删除)</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure><p>第二种方式：<code>ssh-keygen -R 服务器ip地址</code></p><h2 id="写在最后-5">写在最后</h2><p>关于SSH如何建立安全连接和客户端认证的文章就写到这里了，如有错误请多多指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-11&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://codersunny.com/posts/7df93f3b/&quot;&gt;【iOS逆向】如何让Mac和iPhone建立安全连接&lt;/a&gt;文章中我们主要讲了Mac和iPhone如何建立安全连接，让我</summary>
      
    
    
    
    <category term="逆向" scheme="https://codersunny.com/categories/%E9%80%86%E5%90%91/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="逆向" scheme="https://codersunny.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>【iOS重学】Block底层原理（二）</title>
    <link href="https://codersunny.com/posts/57c4c4a9/"/>
    <id>https://codersunny.com/posts/57c4c4a9/</id>
    <published>2022-12-08T05:46:59.000Z</published>
    <updated>2023-03-05T09:52:30.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-13">写在前面</h2><p>在上一篇文章<a href="https://codersunny.com/posts/67d22871/">【iOS重学】Block底层原理（一）</a>中我们主要讲了Block的基本使用、底层原理、对变量的捕获机制以及Block的几种类型，本文是第二篇，主要内容包含：</p><ul><li><code>__block</code>修饰符的基本使用</li><li><code>__block</code>修饰的变量在Block内部的底层结构</li><li><code>__block</code>的内存管理</li><li>循环引用</li></ul><h2 id="Block的基本使用-2">__Block的基本使用</h2><p>如果想在Block内部修改auto变量的值，我们一般是无法直接修改的，会报如下错误：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/1.png" alt="1"></p><p><code>__block</code>修饰符就是用来解决Block内部无法修改auto变量值的问题。</p><div class="note green no-icon flat"><p><code>__block</code>不能用来修饰全局变量、static变量。</p></div><h2 id="block修饰的变量底层结构探究">__block修饰的变量底层结构探究</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>(^Block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line">Block();</span><br></pre></td></tr></table></figure><p>如上，使用<code>__block</code>修饰的变量在Block内部之后的底层结构是什么样的呢？跟之前对比有什么不一样。</p><p>不使用<code>__block</code>修饰符，Block底层结构如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/2.png" alt="2"></p><p>使用<code>__block</code>修饰符，Block底层结构如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/3.png" alt="3"></p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/4.png" alt="4"></p><p>我们发现底层结构确实发生了变化：被<code>__block</code>修饰的变量会被包装成一个<code>__Block_byref_age_0</code>的对象，这个对象的结构里面有个<code>int age</code>，具体如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_age_0</span> &#123;</span><br><span class="line">  <span class="type">void</span> *__isa;</span><br><span class="line">  __Block_byref_age_0 *__forwarding; <span class="comment">// 是指向自己的一个指针</span></span><br><span class="line">  <span class="type">int</span> __flags;</span><br><span class="line">  <span class="type">int</span> __size;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note orange no-icon flat"><p><strong>问题</strong>：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *tempArr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="type">void</span>(^Block)(<span class="type">void</span>) =  ^()&#123;</span><br><span class="line">  [tempArr addObject:<span class="string">@&quot;1&quot;</span>];</span><br><span class="line">&#125;;</span><br><span class="line">Block();</span><br></pre></td></tr></table></figure><p>以上代码结果是否会报错？</p><p>不会，<code>[tempArr addObject:@&quot;1&quot;]</code>只是在使用<code>tempArr</code>指针并没有修改<code>tempArr</code>。</p></div><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;1---%p&quot;</span>,&amp;age);</span><br><span class="line"><span class="type">void</span>(^Block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,age);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2---%p&quot;</span>,&amp;age);</span><br><span class="line">&#125;;</span><br><span class="line">Block();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;3---%p&quot;</span>,&amp;age);</span><br></pre></td></tr></table></figure><p>我们打印<code>age</code>的地址看一下:</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">52.006645</span>+<span class="number">0800</span> BlockDemo[<span class="number">8781</span>:<span class="number">6613854</span>] <span class="number">1</span>--<span class="number">-0x7ff7bfeff2d8</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">52.007272</span>+<span class="number">0800</span> BlockDemo[<span class="number">8781</span>:<span class="number">6613854</span>] age is <span class="number">10</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">52.007357</span>+<span class="number">0800</span> BlockDemo[<span class="number">8781</span>:<span class="number">6613854</span>] <span class="number">2</span>--<span class="number">-0x100b478a8</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">52.007395</span>+<span class="number">0800</span> BlockDemo[<span class="number">8781</span>:<span class="number">6613854</span>] <span class="number">3</span>--<span class="number">-0x100b478a8</span></span><br></pre></td></tr></table></figure><p>从打印结果我们看到1和2、3的age的地址值不一样，我们可以根据上面的底层结构探索来解释一下为什么？</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_age_0</span> &#123;</span><br><span class="line"> <span class="type">void</span> *__isa;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">__Block_byref_age_0</span> *__forwarding;</span><br><span class="line"> <span class="type">int</span> __flags;</span><br><span class="line"> <span class="type">int</span> __size;</span><br><span class="line"> <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__block_impl</span> &#123;</span><br><span class="line">  <span class="type">void</span> *isa;</span><br><span class="line">  <span class="type">int</span> Flags;</span><br><span class="line">  <span class="type">int</span> Reserved;</span><br><span class="line">  <span class="type">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__Block_byref_age_0</span> *age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__block <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;1---%p&quot;</span>,&amp;age);</span><br><span class="line"><span class="built_in">void</span>(^Block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;age is %d&quot;</span>,age);</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;2---%p&quot;</span>,&amp;age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> *implBlock = (__bridge <span class="keyword">struct</span> __main_block_impl_0  *)Block;</span><br></pre></td></tr></table></figure><p>我们把Block转为<code>__main_block_impl_0</code>的结构体来分析一下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/5.png" alt="5"></p><p>Block内部的<code>__Block_byref_age_0</code>结构体地址值是：<code>0x100e1c7e0</code>，而我们打印age的地址值是：<code>0x100e1c7f8</code>，两个不一样，说明打印的age的地址值不是<code>__Block_byref_age_0</code>结构体age的值，接着往下分析：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 地址值：0x100e1c7e0</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_age_0</span> &#123;</span><br><span class="line"> <span class="type">void</span> *__isa; <span class="comment">// 8byte __isa地址值：0x100e1c7e0</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">__Block_byref_age_0</span> *__forwarding; <span class="comment">// 8byte __forwarding地址值：0x100e1c7e8</span></span><br><span class="line"> <span class="type">int</span> __flags;<span class="comment">// 4byte __flags地址值：0x100e1c7d2</span></span><br><span class="line"> <span class="type">int</span> __size; <span class="comment">// 4byte __size地址值：0x100e1c7d6</span></span><br><span class="line"> <span class="type">int</span> age;<span class="comment">// 4byte age地址值：0x100e1c7d8</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上面的分析我们看到：我们打印的age的地址值其实是<code>__Block_byref_age_0</code>结构体中age的地址值。</p><h2 id="block的内存管理">__block的内存管理</h2><p>在上面我们分析的是基本数据类型用<code>__block</code>来修饰，我们接下来看一下更复杂的情况：<code>__block</code>用来修饰对象类型。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="type">void</span>(^Block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;object is %@&quot;</span>,object);</span><br><span class="line">&#125;;</span><br><span class="line">Block();</span><br></pre></td></tr></table></figure><p>底层结构如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/6.png" alt="6"></p><p>这里有两点值得我们注意一下：</p><p>1的位置多了两个函数<code>copy</code>和<code>dispose</code>，这点我们在上一篇文章讲到过因为Block捕获的变量是对象类型，所以会有这两个函数，这里我们就不赘述了，除此之外我们发现<code>__Block_byref_object_0</code>这个结构体里面也多了两个函数：<code>__Block_byref_id_object_copy</code>和<code>__Block_byref_id_object_dispose</code>，里面具体实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __Block_byref_id_object_copy_131(<span class="type">void</span> *dst, <span class="type">void</span> *src) &#123;</span><br><span class="line"> _Block_object_assign((<span class="type">char</span>*)dst + <span class="number">40</span>, *(<span class="type">void</span> * *) ((<span class="type">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __Block_byref_id_object_dispose_131(<span class="type">void</span> *src) &#123;</span><br><span class="line"> _Block_object_dispose(*(<span class="type">void</span> * *) ((<span class="type">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部也是调用的<code>_Block_object_assign</code>和<code>_Block_object_dispose</code>，和我们之前讲的是一样的。</p><p>并且我们看到<code>__Block_byref_object_0</code>结构体里面会对<code>object</code>这个对象有一个强引用。</p><p>下面我们来总结一下：</p><p>1、当Block在栈上时，并不会对<code>__block</code>修饰的变量产生强引用。</p><p>2、当Block被copy到堆上时，会调用Block内部的<code>copy</code>函数，<code>copy</code>函数内部会调用<code>__Block_object_assign</code>函数，<code>__Block_object_assign</code>函数会对<code>__block</code>修饰的变量形成强引用。</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/7.png" alt="7"></p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/8.png" alt="8"></p><p>3、当Block从堆中移除时，会调用Block内部的<code>dispose</code>函数，<code>dispose</code>函数内部会调用<code>__Block_object_dispose</code>函数，<code>__Block_object_dispose</code>会对<code>__block</code>修饰的变量进行一次release操作。</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/9.png" alt="9"></p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/10.png" alt="10"></p><h2 id="Block的循环引用">Block的循环引用</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="type">void</span>(^PersonBlock)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *person = [[Person alloc] init];</span><br><span class="line">        person.age = <span class="number">10</span>;</span><br><span class="line">        person.PersonBlock = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;person&#x27;s age is %d&quot;</span>,person.age);</span><br><span class="line">        &#125;;</span><br><span class="line">        person.PersonBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;--------&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-08</span> <span class="number">16</span>:<span class="number">07</span>:<span class="number">45.878556</span>+<span class="number">0800</span> BlockDemo[<span class="number">9541</span>:<span class="number">6681377</span>] person<span class="string">&#x27;s age is 10</span></span><br><span class="line"><span class="string">2022-12-08 16:07:45.879146+0800 BlockDemo[9541:6681377] --------</span></span><br></pre></td></tr></table></figure><p>发现<code>person</code>对象并没有被释放还存在内存里面，这就是我们常说的循环引用（内存泄漏）。</p><p>下图表示了上面对象之间的持有关系：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/11.png" alt="11"></p><p>如何解决循环引用？</p><p>其实就是把2和3其中一个变成弱引用即可，那么到底2和3谁变成弱引用更合适呢，3是<code>Person</code>对象有一个<code>PersonBlock</code>这个属性，我们希望当这个<code>Person</code>对象还在的时候随时能访问到<code>PersonBlock</code>，所以3应该是个强引用，我们把2换成弱引用即可。</p><ul><li>使用<code>__weak</code>，<code>__unsafe_unretain</code></li><li>使用<code>_block</code>，但是必须调用block</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(person) weakPerson = person;</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line">person.PersonBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;person&#x27;s age is %d&quot;</span>,weakPerson.age);</span><br><span class="line">&#125;;</span><br><span class="line">person.PersonBlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="keyword">typeof</span>(person) weakPerson = person;</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line">person.PersonBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;person&#x27;s age is %d&quot;</span>,weakPerson.age);</span><br><span class="line">&#125;;</span><br><span class="line">person.PersonBlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三</span></span><br><span class="line">__block Person *person = [[Person alloc] init];</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line">person.PersonBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;person&#x27;s age is %d&quot;</span>,person.age);</span><br><span class="line">    person = <span class="literal">nil</span>;</span><br><span class="line">&#125;;</span><br><span class="line">person.PersonBlock();</span><br></pre></td></tr></table></figure><p>我们来分析一下<code>__block</code>修饰的变量的内存问题：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block Person *person = [[Person alloc] init];</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line">person.PersonBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;person&#x27;s age is %d&quot;</span>,person.age);</span><br><span class="line">&#125;;</span><br><span class="line">person.PersonBlock();</span><br></pre></td></tr></table></figure><p>用一张图来表示他们之间的引用关系：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/12.png" alt="12"></p><p>如何解决循环引用？</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">__block __<span class="keyword">weak</span> <span class="keyword">typeof</span>(person) weakPerson = person;</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line">person.PersonBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;person&#x27;s age is %d&quot;</span>,weakPerson.age);</span><br><span class="line">&#125;;</span><br><span class="line">person.PersonBlock();</span><br></pre></td></tr></table></figure><p>底层结构如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1208/13.png" alt="13"></p><p>这样我们就可以解决Block带来的一些循环引用的问题啦。</p><h2 id="写在最后-7">写在最后</h2><p>关于Block的底层原理在这里就全部结束了，如有错误请多多指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-13&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;在上一篇文章&lt;a href=&quot;https://codersunny.com/posts/67d22871/&quot;&gt;【iOS重学】Block底层原理（一）&lt;/a&gt;中我们主要讲了Block的基本使用、底层原理、对变量的捕获机制以</summary>
      
    
    
    
    <category term="iOS" scheme="https://codersunny.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://codersunny.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【iOS重学】Block底层原理（一）</title>
    <link href="https://codersunny.com/posts/67d22871/"/>
    <id>https://codersunny.com/posts/67d22871/</id>
    <published>2022-12-06T11:09:24.000Z</published>
    <updated>2023-03-05T09:52:30.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-12">写在前面</h2><p>关于<code>Block</code>的底层原理相关东西，需要了解的东西比较多，所以博主这里打算用两篇文章来详细分析一下OC里面的<code>Block</code>，这是第一篇，内容主要包含：</p><ul><li>Block的基本使用</li><li>Block的底层数据结构</li><li>Block对变量的捕获</li><li>Block的类型</li></ul><p>好了，废话少说，现在跟着博主开始从头了解Block吧。</p><h2 id="Block的基本使用">Block的基本使用</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Block</span></span><br><span class="line"><span class="type">void</span>(^WWBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;This is a block...&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 调用Block</span></span><br><span class="line">WWBlock();</span><br></pre></td></tr></table></figure><p>以上是最简单的一个Block，调用<code>Block()</code>会打印：<code>This is a block...</code>。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)fetchDataWithSuccess:(<span class="type">void</span>(^)(<span class="built_in">NSString</span> *message))successBlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)fetchDataWithSuccess:(<span class="type">void</span>(^)(<span class="built_in">NSString</span> *message))successBlock &#123;</span><br><span class="line">    <span class="keyword">if</span> (successBlock) &#123;</span><br><span class="line">        successBlock(<span class="string">@&quot;这是一个成功的回调...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">[person fetchDataWithSuccess:^(<span class="built_in">NSString</span> *message) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;---- %@&quot;</span>, message);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-06</span> <span class="number">19</span>:<span class="number">30</span>:<span class="number">08.775142</span>+<span class="number">0800</span> BlockDemo[<span class="number">53402</span>:<span class="number">5642770</span>] ---- 这是一个成功的回调...</span><br></pre></td></tr></table></figure><p>相信这种类似的Block大家在日常项目中会看到很多很多，我们这里就不再一一列举了。</p><h2 id="Block的底层数据结构">Block的底层数据结构</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Block</span></span><br><span class="line"><span class="type">void</span>(^WWBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;This is a block...&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 调用Block</span></span><br><span class="line">WWBlock();</span><br></pre></td></tr></table></figure><p>我们来看一下上面最简单的Block的底层C++结构是什么样的，使用命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code>转为C++代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="comment">// 定义Block</span></span><br><span class="line">        <span class="built_in">void</span>(*WWBlock)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">                            </span><br><span class="line">        <span class="comment">// 调用Block               </span></span><br><span class="line">        ((<span class="built_in">void</span> (*)(__block_impl *))((__block_impl *)WWBlock)-&gt;FuncPtr)((__block_impl *)WWBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把相应的强制转换给去掉能够帮助我们更清晰的理解Block的结构，去掉一些强制转换之后如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Block</span></span><br><span class="line"><span class="built_in">void</span>(*WWBlock)(<span class="type">void</span>) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"><span class="comment">// 调用Block      </span></span><br><span class="line">WWBlock-&gt;<span class="built_in">FuncPtr</span>(WWBlock);</span><br></pre></td></tr></table></figure><p>可以看到跟Block相关的有：<code>__main_block_impl_0</code>、<code>__main_block_func_0</code>、<code>__main_block_dec_0_DATA</code>这几个类，在生成的C++文件里面找到相关的结构如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/1.png" alt="1"></p><p>从上面的图里面我们可以看到，Block的结构里面也有一个<code>isa</code>指针，所以Block的本质其实也是一个【<strong>OC对象</strong>】，是一个封装了函数调用及其调用环境的OC对象。</p><p>对应关系如下图所示：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/2.png" alt="2"></p><p>在调用的时候<code>WWBlock-&gt;FuncPtr(WWBlock)</code>，相当于是拿到<code>WWBlock</code>结构里面的函数指针<code>FuncPtr</code>去调用对应的方法，这个函数指针里面其实存放的就是Block代码块的地址。</p><h2 id="Block对变量的捕获">Block对变量的捕获</h2><p>为什么Block会对变量进行捕获？</p><p>因为在Block里面可能需要访问Block外部变量的值，所以需要捕获（capture）变量保证我们能正确访问到变量。</p><p>我们现在分别来分析【auto变量】、【static变量】、【全局变量】三种不同的变量，Block对其捕获是不是也不一样呢？</p><h3 id="auto变量">auto变量</h3><p>auto变量：离开当前作用域就会销毁的变量。</p><h4 id="1、非对象类型的auto变量">1、非对象类型的auto变量</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Block</span></span><br><span class="line"><span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>(^WWBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;对auoto变量的捕获 - %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line">age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用Block</span></span><br><span class="line">WWBlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-06</span> <span class="number">20</span>:<span class="number">18</span>:<span class="number">28.957166</span>+<span class="number">0800</span> BlockDemo[<span class="number">54326</span>:<span class="number">5689813</span>] 对auoto变量的捕获 - <span class="number">10</span></span><br></pre></td></tr></table></figure><p>底层C++代码如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/3.png" alt="3"></p><p>跟前面我们没有捕获变量相比，会把<code>age</code>传递到Block里面：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/4.png" alt="4"></p><p>从底层结构我们也看到了：Block会对auto变量进行捕获，访问的方式是【值传递】。</p><h4 id="2、对象类型的auto变量">2、对象类型的auto变量</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">void</span>(^WWBlock)(<span class="type">void</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            Person *person = [[Person alloc] init];</span><br><span class="line">            person.age = <span class="number">10</span>;</span><br><span class="line">            WWBlock = ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;person&#x27;s age is %d&quot;</span>,person.age);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;-----&quot;</span>);</span><br><span class="line">        WWBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">31.593895</span>+<span class="number">0800</span> BlockDemo[<span class="number">2248</span>:<span class="number">6132111</span>] -----</span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">31.594542</span>+<span class="number">0800</span> BlockDemo[<span class="number">2248</span>:<span class="number">6132111</span>] person<span class="string">&#x27;s age is 10</span></span><br><span class="line"><span class="string">2022-12-07 15:45:31.594693+0800 BlockDemo[2248:6132111] -[Person dealloc]</span></span><br></pre></td></tr></table></figure><p>底层结构代码如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/11.png" alt="11"></p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/12.png" alt="12"></p><p>对照上面的底层数据结构发现：多了两个函数<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code>。</p><p>当Block被拷贝到堆上时，会调用Block内部的copy函数<code>__main_block_copy_0</code>，函数里面调用<code>_Block_object_assign</code>，在<code>_Block_object_assign</code>里面根据auto变量的修饰符做出相应的操作：强引用或弱引用。</p><p>当Block从对上移除时，会调用Block内部的dispose函数<code>__main_block_dispose_0</code>，函数里面调用<code>_Block_object_dispose</code>，<code>_Block_object_dispose</code>去对引用的auto变量进行一次release操作。</p><div class="note pink no-icon flat"><p>在使用clang转换OC为C++代码时，如果有<code>__weak</code>可能会出现下面报错：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/13.png" alt="13"></p><p>让其支持ARC、指定运行时系统版本即可，比如：</p><p>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-14.0.0 main.m</p></div><h3 id="static变量">static变量</h3><p>static变量：离开当前作用域不会销毁的变量。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Block</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>(^WWBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;对static变量的捕获 - %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line">age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用Block</span></span><br><span class="line">WWBlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-06</span> <span class="number">20</span>:<span class="number">27</span>:<span class="number">55.716204</span>+<span class="number">0800</span> BlockDemo[<span class="number">54594</span>:<span class="number">5700817</span>] 对<span class="keyword">static</span>变量的捕获 - <span class="number">20</span></span><br></pre></td></tr></table></figure><p>底层C++代码如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/5.png" alt="5"></p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/6.png" alt="6"></p><p>从底层结构我们也看到了：Block会对static变量进行捕获，访问的方式是【指针传递】。</p><h3 id="全局变量">全局变量</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">      <span class="comment">// 定义一个Block</span></span><br><span class="line">      age = <span class="number">10</span>;</span><br><span class="line">      <span class="type">void</span>(^WWBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,age);</span><br><span class="line">      &#125;;</span><br><span class="line">      age = <span class="number">20</span>;</span><br><span class="line">      <span class="comment">// 调用Block</span></span><br><span class="line">      WWBlock();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-07</span> <span class="number">13</span>:<span class="number">39</span>:<span class="number">45.012065</span>+<span class="number">0800</span> BlockDemo[<span class="number">197</span>:<span class="number">6032120</span>] age is <span class="number">20</span></span><br></pre></td></tr></table></figure><p>底层C++代码如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/7.png" alt="7"></p><p>从底层结构我们发现：Block不会对全局变量进行捕获，直接访问全局变量即可。</p><div class="note green no-icon flat"><p><strong>思考</strong>：</p><p>1、为什么Block不会捕获全局变量，但是局部变量需要捕获？</p><p>全局变量在任何时候任何地方都是可以访问到的，因此不需要捕获可以直接访问。</p><p>局部变量因为作用域的问题需要被捕获，保证Block内部能够正确访问到该变量。</p><p>2、Block会对捕获self吗？</p><p>会，说明self是个局部变量。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)test &#123;</span><br><span class="line">    <span class="keyword">self</span>.age = <span class="number">10</span>;</span><br><span class="line">    <span class="type">void</span>(^WWBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>, <span class="keyword">self</span>.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    WWBlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层C++代码如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/9.png" alt="9"></p><p><code>self</code>和<code>_cmd</code>其实是两个隐式参数，所以我们能在里面正常访问<code>self</code>、<code>_cmd</code>。</p></div><h3 id="Block捕获变量总结">Block捕获变量总结</h3><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/8.png" alt="8"></p><h2 id="Block的类型">Block的类型</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>(^block1)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;This is block...&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>(^block2)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %@ %@&quot;</span>,[block1 <span class="keyword">class</span>],[block2 <span class="keyword">class</span>],[^&#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>, age);&#125; <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %@ %@&quot;</span>,[[block1 <span class="keyword">class</span>] superclass], [[block2 <span class="keyword">class</span>] superclass], [[^&#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>, age);&#125; <span class="keyword">class</span>] superclass]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">29.626370</span>+<span class="number">0800</span> BlockDemo[<span class="number">2188</span>:<span class="number">6126897</span>] __NSGlobalBlock__ __NSMallocBlock__ __NSStackBlock__</span><br><span class="line"><span class="number">2022</span><span class="number">-12</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">29.627050</span>+<span class="number">0800</span> BlockDemo[<span class="number">2188</span>:<span class="number">6126897</span>] <span class="built_in">NSBlock</span> <span class="built_in">NSBlock</span> <span class="built_in">NSBlock</span></span><br></pre></td></tr></table></figure><p>Block有三种类型：<code>__NSGlobalBlock__</code>、<code>__NSMallocBlock__</code>、<code>__NSStackBlock__</code>，都继承自<code>NSBlock</code>。</p><div class="note blue no-icon flat"><p><strong>注意</strong>：编译完的Block类型和运行时的Block类型会有一些区别。</p></div><h3 id="应用程序的内存分配">应用程序的内存分配</h3><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1206/10.png" alt="10"></p><p>程序区域（代码段）：存放的就是我们写的一些代码。</p><p>数据区域：一般是存放一些全局变量。</p><p>堆：动态分配内存，自己管理内存。</p><p>栈：系统自动分配内存，不需要自己管理内存。</p><h3 id="Block类型总结">Block类型总结</h3><div class="note blue no-icon flat"><p>1、只要没有访问auto变量的Block都是<code>__NSGlobalBlock__</code>类型的。</p><p>2、访问了auto变量的Block是<code>__NSStackBlock__</code>类型的，因为我们是在ARC环境下，会自动进行copy操作，所以是<code>__NSMallocBlock__</code>类型的。</p><p>3、<code>__NSGlobalBlock__</code>类型的Block调用了copy还是<code>__NSGlobalBlock__</code>类型。</p></div><h3 id="Block的copy操作">Block的copy操作</h3><p>在ARC环境下，编译器会根据情况自动将栈上的Block复制到堆上，比如以下情况：</p><ul><li>block作为函数返回值</li><li>将block赋值给<code>__strong</code>指针时</li><li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li><li>block作为GCD API的方法参数时</li></ul><div class="note orange no-icon flat"><p><strong>注意</strong>：MRC下Block使用copy关键字修饰，ARC下Block使用strong或copy都可以，建议使用copy，与MRC下保持一致。</p></div><h2 id="写在最后-6">写在最后</h2><p>关于Block底层原理的第一篇我们就分享到这里，如有错误请多多指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-12&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;关于&lt;code&gt;Block&lt;/code&gt;的底层原理相关东西，需要了解的东西比较多，所以博主这里打算用两篇文章来详细分析一下OC里面的&lt;code&gt;Block&lt;/code&gt;，这是第一篇，内容主要包含：&lt;/p&gt;
&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="iOS" scheme="https://codersunny.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://codersunny.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【iOS逆向】如何让Mac和iPhone建立安全连接</title>
    <link href="https://codersunny.com/posts/7df93f3b/"/>
    <id>https://codersunny.com/posts/7df93f3b/</id>
    <published>2022-12-01T06:23:13.000Z</published>
    <updated>2023-03-05T09:52:30.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-10">写在前面</h2><p>本文主要是记录一下在iOS逆向过程中，Mac是如何和iPhone建立安全连接来实现在Mac上可以通过命令行操作iPhone的。</p><h2 id="SSH-和-OpenSSH">SSH 和 OpenSSH</h2><p>SSH：Secure Shell的缩写，意思为“安全外壳协议”，是一种可以为【远程登录】提供安全保障的协议，使用SSH可以把所有的数据加密，防止中间人攻击等欺骗。</p><p>OpenSSH：是SSH的免费开源实现。</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/1.png" alt="1"></p><div class="note pink no-icon flat"><p><strong>拓展</strong>：</p><p>SSL：Secure Socket Layer的缩写，是为网络通信提供安全及数据完整性的一种安全协议，在传输层对网络连接进行加密。</p><p>OpenSSL：SSL的开源实现。</p><p>绝大部分的https请求等价于http + OpenSSL。</p><p>OpenSSH是用来保证登录安全性的，而这个安全由OpenSSL来具体实现。</p></div><h2 id="Mac如何远程登录到iPhone">Mac如何远程登录到iPhone</h2><h3 id="方式一：通过网络连接">方式一：通过网络连接</h3><p>iOS下有两个常用的账户：root、mobile。</p><p>root账户拥有最高权限，mobile是普通权限账户。</p><p>现在我们来看如何在Mac上远程登录iPhone：</p><div class="note green no-icon flat"><p>1.首先在Cydia中下载插件<code>OpenSSH</code></p><p>2.保证Mac和iPhone在同一个局域网下（连接同一个Wifi）</p><p>3.使用命令<code>ssh 账户名@服务主机地址</code>登录到iPhone，这里账户名：root，服务主机地址：连接的Wifi设置里面查看</p><p><strong>注意</strong>：首次登录的初始化密码为：alpine</p></div><p>效果图如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/2.png" alt="2"></p><p>此时我们通过命令行在iPhone下创建一个<code>test.txt</code>的文本，此时通过<code>iFunBox</code>查看，会发现root账户下多了一个刚创建的文本：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/3.png" alt="3"></p><p>到这里，说明我们已经成功建立Mac和iPhone的连接。</p><div class="note red no-icon flat"><p><strong>提示</strong>：</p><p>如果在登录的过程中出现如下错误：<code>ssh: connect to host xxx port 22: Operation timed out</code>，可以<code>ping 主机地址</code>看看网络是否连接上。</p></div><h3 id="方式二：通过USB连接">方式二：通过USB连接</h3><p>默认情况下，SSH走的协议是TCP协议，Mac是通过网络连接的方式登录到iPhone，所以如果网络环境不好可能会造成传输速度比较慢的情况。</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/4.png" alt="4"></p><p>为了加快传输的速度可以使用USB的方式进行登录，Mac上有个服务程序<code>usbmuxd</code>，<code>usbmuxd</code>是开机启动的，它可以将Mac的数据通过USB传输到iPhone上。</p><p>使用USB的方式连接的具体步骤如下：</p><div class="note pink no-icon flat"><ol><li><p>下载<code>usbmuxd</code>工具包</p></li><li><p>使用如下命令将iPhone的22端口（SSH端口）映射到本地的xxxxx端口（这个端口是任意的，只要不是保留端口就可以）</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">cd usbmuxd<span class="number">-1.0</span><span class="number">.8</span>/python-client <span class="comment">// 下载usbmuxd工具目录下</span></span><br><span class="line">python tcprelay.py -t <span class="number">22</span>:<span class="number">10010</span> <span class="comment">// 10010只要不是保留端口就行 -t是为了能够支持多个SSH连接</span></span><br></pre></td></tr></table></figure><p>端口映射完毕后，以后要想跟iPhone的22端口通信只需要跟Mac本地的10010端口通信即可，<code>usbmuxd</code>会将Mac本地10010端口的TCP协议数据通过USB的方式传到iPhone的22端口。</p></li><li><p>使用如下命令新开一个终端窗口，SSH登录到Mac本地的10010端口</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ssh root@localhost -p <span class="number">10010</span></span><br><span class="line">或</span><br><span class="line">ssh root@MacIP地址 -p <span class="number">10010</span></span><br></pre></td></tr></table></figure></li></ol></div><p>博主这里的操作如下图：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/5.png" alt="5"></p><p>此时，映射关系已经建立完毕。</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/6.png" alt="6"></p><p>登录到Mac本地的10010端口，此时连接已经完成，创建<code>touch usbLoginTest.txt</code>的一个文本测试一下，会发现iPhone上多了我们刚刚创建的文本：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/7.png" alt="7"></p><p>USB登录的整个流程如下图：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202212/1201/8.png" alt="8"></p><h2 id="写在最后-4">写在最后</h2><p>关于【如何让Mac和iPhone建立安全连接的两种方式】的文章就写到这里了，如有错误请多多指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-10&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;本文主要是记录一下在iOS逆向过程中，Mac是如何和iPhone建立安全连接来实现在Mac上可以通过命令行操作iPhone的。&lt;/p&gt;
&lt;h2 id=&quot;SSH-和-OpenSSH&quot;&gt;SSH 和 OpenSSH&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="逆向" scheme="https://codersunny.com/categories/%E9%80%86%E5%90%91/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="逆向" scheme="https://codersunny.com/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="iPhone" scheme="https://codersunny.com/tags/iPhone/"/>
    
  </entry>
  
  <entry>
    <title>【iOS重学】关联对象的底层原理</title>
    <link href="https://codersunny.com/posts/baafbb5e/"/>
    <id>https://codersunny.com/posts/baafbb5e/</id>
    <published>2022-11-30T06:19:30.000Z</published>
    <updated>2023-03-05T09:52:30.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-21">写在前面</h2><p>本文主要探究一下iOS中如何给分类添加属性以及关联对象的底层原理是什么，建议大家看本篇文章的时候参考objc4源码一起看会更好。</p><h2 id="如何给分类添加属性">如何给分类添加属性</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person + Test 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><div class="note red no-icon flat"><p><strong>解释</strong>：</p><p><code>objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</code>参数解释：</p><p>1、<code>object</code>：需要关联的对象</p><p>2、<code>key</code>：关联key</p><p>3、<code>value</code>：关联值</p><p>4、<code>policy</code>：关联策略</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>, <span class="comment">// 对应 assign       </span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">//  对应 strong，nonatomic</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>, <span class="comment">// 对应 copy，nonatomic </span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>, <span class="comment">// 对应 strong，atomic                                     </span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span> <span class="comment">// 对应 copy，atomic</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h2 id="关联对象的底层原理">关联对象的底层原理</h2><div class="note red no-icon flat"><p>博主这里的源码是 objc4 - 838 版本，不同的版本有的方法实现可能会有一些差异但是原理都是基本不变的，建议大家下载最新版本的源码阅读。</p></div><h3 id="设值原理">设值原理</h3><p>设值调用的是<code>objc_setAssociatedObject</code>，里面调用的是<code>_objc_set_associative_reference</code>，设值的核心方法就在<code>_objc_set_associative_reference</code>里面，如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1130/1.png" alt="1"></p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1130/2.png" alt="2"></p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_object_set_associative_reference(<span class="type">id</span> object, <span class="keyword">const</span> <span class="type">void</span> *key, <span class="type">id</span> value, uintptr_t policy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This code used to work when nil was passed for object and key. Some code</span></span><br><span class="line">    <span class="comment">// probably relies on that to not crash. Check and handle it explicitly.</span></span><br><span class="line">    <span class="comment">// rdar://problem/44094390</span></span><br><span class="line">    <span class="keyword">if</span> (!object &amp;&amp; !value) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object-&gt;getIsa()-&gt;forbidsAssociatedObjects())</span><br><span class="line">        _objc_fatal(<span class="string">&quot;objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects&quot;</span>, object, object_getClassName(object));</span><br><span class="line">    <span class="comment">// 把关联对象object包装成一个DisguisedPtr类型的数据结构</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; disguised&#123;(objc_object *)object&#125;;</span><br><span class="line">    <span class="comment">// 把关联策略policy和具体关联的值value包装成一个ObjcAssociation的数据结构</span></span><br><span class="line">    ObjcAssociation association&#123;policy, value&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    <span class="comment">// 根据不同的策略类型做相应的处理</span></span><br><span class="line">    association.acquireValue();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isFirstAssociation = <span class="literal">false</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// AssociationsManager 是关联对象管理类，里面有一个静态变量_mapStorage，要注意的是manager并不是唯一的。</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="comment">// 通过 manager.get()来获取所有的关联表associations 类型是 AssociationsHashMap</span></span><br><span class="line">        AssociationsHashMap &amp;associations(manager.get());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            <span class="comment">// 根据关联的对象disguised去关联表associations中查找对应的ObjectAssociationMap类型的value，如果没有就创建一个插入到associations里面</span></span><br><span class="line">            auto refs_result = associations.try_emplace(disguised, ObjectAssociationMap&#123;&#125;);</span><br><span class="line">            <span class="keyword">if</span> (refs_result.second) &#123;</span><br><span class="line">                <span class="comment">/* it&#x27;s the first association we make */</span></span><br><span class="line">                isFirstAssociation = <span class="literal">true</span>; <span class="comment">// 设置为true</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* establish or replace the association */</span></span><br><span class="line">            auto &amp;refs = refs_result.first-&gt;second;</span><br><span class="line">            auto result = refs.try_emplace(key, std::move(association)); <span class="comment">// 根据传入的key找到对应的bucket，替换掉原来的或者插入新的association，并且设置关联策略。</span></span><br><span class="line">            <span class="keyword">if</span> (!result.second) &#123;</span><br><span class="line">                association.swap(result.first-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果value值为nil 通过传入的关联对象disguised找到相应的AssociationsHashMap</span></span><br><span class="line">            auto refs_it = associations.find(disguised);</span><br><span class="line">            <span class="keyword">if</span> (refs_it != associations.end()) &#123;</span><br><span class="line">                auto &amp;refs = refs_it-&gt;second;</span><br><span class="line">                auto it = refs.find(key); <span class="comment">// 通过传入的key去找到ObjectAssociation</span></span><br><span class="line">                <span class="keyword">if</span> (it != refs.end()) &#123;</span><br><span class="line">                    association.swap(it-&gt;second); <span class="comment">// 进行擦除操作</span></span><br><span class="line">                    refs.erase(it);</span><br><span class="line">                    <span class="keyword">if</span> (refs.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        associations.erase(refs_it);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call setHasAssociatedObjects outside the lock, since this</span></span><br><span class="line">    <span class="comment">// will call the object&#x27;s _noteAssociatedObjects method if it</span></span><br><span class="line">    <span class="comment">// has one, and this may trigger +initialize which might do</span></span><br><span class="line">    <span class="comment">// arbitrary stuff, including setting more associated objects.</span></span><br><span class="line">    <span class="keyword">if</span> (isFirstAssociation)</span><br><span class="line">        <span class="comment">// 如果有关联对象</span></span><br><span class="line">        object-&gt;setHasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="comment">// 对association进行一次release操作</span></span><br><span class="line">    association.releaseHeldValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面我们可以看到设置关联的四个主要对象：</p><p><code>AssociationsManager</code></p><p><code>AssociationsHashMap</code></p><p><code>ObjectAssociationMap</code></p><p><code>ObjcAssociation</code></p><p>其中，<code>AssociationsManager</code>的结构为：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> AssociationsManager &#123;</span><br><span class="line">  using Storage = ExplicitInitDenseMap&lt;DisguisedPtr&lt;objc_object&gt;, ObjectAssociationMap&gt;;</span><br><span class="line">  <span class="keyword">static</span> Storage _mapStorage;</span><br><span class="line">  </span><br><span class="line">   AssociationsHashMap &amp;get() &#123;</span><br><span class="line">      <span class="keyword">return</span> _mapStorage.get();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">void</span> init() &#123;</span><br><span class="line">      _mapStorage.init();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>AssociationsHashMap</code>的结构为：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">DenseMap&lt;DisguisedPtr&lt;objc_object&gt;, ObjectAssociationMap&gt; </span><br></pre></td></tr></table></figure><p><code>ObjectAssociationMap</code>的结构为：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> DenseMap&lt;<span class="keyword">const</span> <span class="type">void</span> *, ObjcAssociation&gt; ObjectAssociationMap;</span><br></pre></td></tr></table></figure><p><code>ObjcAssociation</code>的结构为：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> ObjcAssociation &#123;</span><br><span class="line">  uintptr_t _policy; <span class="comment">// 关联策略</span></span><br><span class="line">  <span class="type">id</span> _value; <span class="comment">// 关联值value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这四个对象之间的关系如下图所示：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1130/3.png" alt="3"></p><p>对照<code>objc_setAssociatedObject(id object, cons void *key, id value, objc_AssociationPolicy policy)</code>方法：</p><ol><li>通过<code>AssociationsManager</code>的<code>manager.get()</code>获得<code>AssociationsHashMap</code>。</li><li><code>AssociationsHashMap</code>中的<code>key</code>是关联对象<code>object</code>，<code>value</code>是<code>ObjectAssociationMap</code>。</li><li><code>ObjectAssociationMap</code>中的<code>key</code>是方法中的<code>key</code>，<code>value</code>是<code>ObjectAssociation</code>。</li><li><code>ObjectAssociation</code>中存放的就是方法中的<code>value</code>和关联策略<code>policy</code>。</li></ol><p>通过上面的分析，设置关联对象的底层原理现在就很清晰了。</p><h3 id="取值原理">取值原理</h3><p>取得调用的是<code>objc_getAssociatedObject</code>，里面调用的是<code>_object_get_associative_reference</code>，取值的核心方法就在<code>_object_get_associative_reference</code>里面，如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1130/4.png" alt="4"></p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1130/5.png" alt="5"></p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span></span><br><span class="line">_object_get_associative_reference(<span class="type">id</span> object, <span class="keyword">const</span> <span class="type">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    ObjcAssociation association&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.get());</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find((objc_object *)object); <span class="comment">// 通过object可以获取ObjectAssociationMap</span></span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            <span class="comment">// 遍历AssociationsHashMap</span></span><br><span class="line">            ObjectAssociationMap &amp;refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs.find(key); <span class="comment">// 通过key可以获得ObjcAssociation</span></span><br><span class="line">            <span class="keyword">if</span> (j != refs.end()) &#123;</span><br><span class="line">                <span class="comment">// 遍历ObjectAssociationMap</span></span><br><span class="line">                association = j-&gt;second;</span><br><span class="line">                association.retainReturnedValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> association.autoreleaseReturnedValue(); <span class="comment">// 返回取到的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2">总结</h3><p>通过上面分析，我们需要知道：</p><ol><li>关联对象并不是存储在被关联对象本身的内存里面，而是存储在一个全局的<code>AssociationsHashMap</code>里面。</li><li>设置关联对象为<code>nil</code>就相当于是移除关联对象。</li><li>移除所有的关联对象：<code>objc_removeAssoociatedObjects</code>。</li><li>关联对象的策略里面没有 <code>weak</code>属性。</li><li>关联对象被移除的时候，相应的关联属性也会被移除。</li></ol><h2 id="写在最后-15">写在最后</h2><p>关于关联对象的底层原理我们就简单分析到这里，如有错误请多多指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-21&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;本文主要探究一下iOS中如何给分类添加属性以及关联对象的底层原理是什么，建议大家看本篇文章的时候参考objc4源码一起看会更好。&lt;/p&gt;
&lt;h2 id=&quot;如何给分类添加属性&quot;&gt;如何给分类添加属性&lt;/h2&gt;
&lt;figure</summary>
      
    
    
    
    <category term="iOS" scheme="https://codersunny.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://codersunny.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Runtime" scheme="https://codersunny.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>【iOS逆向】一键越狱教程</title>
    <link href="https://codersunny.com/posts/1bf7fb0b/"/>
    <id>https://codersunny.com/posts/1bf7fb0b/</id>
    <published>2022-11-29T07:54:55.000Z</published>
    <updated>2023-03-05T09:52:30.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-9">写在前面</h2><p>本文主要是记录一下如何越狱，博主这里指的是不完美越狱，博主这里越狱的手机是：iPhone5s  iOS12.5.6。</p><p>首先，你需要有：iPhone手机、Mac电脑，保证Mac和手机上都有<a href="https://www.i4.cn/">爱思助手</a>。</p><h2 id="越狱的简单介绍">越狱的简单介绍</h2><h3 id="什么是越狱？">什么是越狱？</h3><p>越狱：iOS jailbreak，利用iOS系统的漏洞获取iOS系统的最高权限，解开之前的各种限制。</p><div class="note red no-icon flat"><p><strong>越狱的优点</strong>：</p><p>1、可以打造个性化、与众不同的iPhone</p><p>2、可以修改APP的一些默认行为</p><p>3、可以自由安装非App Store来源的App</p><p>4、灵活管理文件系统，让iPhone可以像U盘那么灵活</p><p>5、给开发者提供了逆向功能的环境</p><p><strong>越狱的缺点</strong>：</p><p>1、越狱的手机不予保修</p><p>2、比较耗电，越狱之后的手机会常驻一些进程，耗电速度约提升10%</p><p>3、不再受iOS系统默认的安全保护，容易被恶意软件攻击，个人隐私有被窃取的风险</p><p>4、如果安装了不稳定的插件，容易让系统不稳定、变慢或者出现“白苹果”现象</p></div><h3 id="完美越狱和不完美越狱">完美越狱和不完美越狱</h3><p>完美越狱：手机在越狱之后可以正常关机和重启。</p><p>不完美越狱：手机不能关机或重启，关机之后可能会出现越狱软件<code>Cydia</code>等无法打开需要重新越狱，严重甚至出现“白苹果”现象。</p><h3 id="Cydia">Cydia</h3><p>Cydia：可以理解为是越狱之后的&quot;App store&quot;，可以在Cydia里面安装一些第三方软件、补丁、插件等。</p><div class="note red no-icon flat"><p><strong>Cydia安装软件的步骤</strong>：</p><p>1、添加软件源（不同的软件软件源可能不一样）（Cydia - 软件源 - 编辑 - 添加 - 输入软件源地址）</p><p>2、进入软件源 - 找到对应的软件开始下载</p></div><p>有的插件安装完成之后会要求重启SpringBoard，SpringBoard可以理解为iOS的桌面。</p><h2 id="如何越狱">如何越狱</h2><p>用数据线连接上手机和电脑，打开【爱思助手】- 工具箱 - 一键越狱：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/1.png" alt="1"></p><p>会显示当前手机系统、型号、是否越狱等信息：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/2.png" alt="2"></p><p>博主这里选择Checkra1n进行越狱，出现如下界面：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/3.png" alt="3"></p><p>点击Start，按照如下操作开始下载越狱软件CheckRa1n：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/4.png" alt="4"></p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/5.png" alt="5"></p><p>安装完Checkra1n之后，手机上会有一个checkra1n的软件，打开它开始安装Cydia软件：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/6.png" alt="6"></p><p>安装完Cydia之后，手机桌面会多一个软件如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/7.png" alt="7"></p><p>此时连接爱思助手，会发现顶部关于手机的信息会发生变化：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/8.png" alt="8"></p><p>会看到上面提示我们去安装AFC2和AppSync两个插件，这两个插件具体有何用处如下：</p><div class="note red no-icon flat"><p>AFC2：可以保证能够访问整个iOS的文件系统。</p><p>AppSync：保证绕过验证随意安装、运行破解的ipa包。</p></div><p>点击安装AFC2会提示我们如何安装，大家按照自己手机的系统来安装，Cydia - 搜索Apple File… - 安装：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/9.png" alt="9"></p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/10.png" alt="10"></p><p>安装完成之后，点击重启SpringBoard即可。</p><p>此时连接Mac和手机，爱思助手顶部信息如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/11.png" alt="11"></p><p>这时我们如果直接点击【安装AppSync】可能会报如下错误：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/12.png" alt="12"></p><p>不用理会，直接在Cydia - 添加软件源：<a href="http://cydia.angelxwind.net">cydia.angelxwind.net</a>，如下图所示：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/13.png" alt="13"></p><p>选择我们刚添加的源 - 插件 - 搜索AppSync - 安装：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/14.png" alt="14"></p><p>安装完成之后同样需要重启SpringBoard，在Cydia - 已安装 里面可以看到我们刚安装的两个插件：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/15.png" alt="15"></p><p>两个都安装成功之后，我们会看到爱思助手顶部信息发生变化，告诉我们该设备已越狱：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1129/16.png" alt="16"></p><h2 id="写在最后-3">写在最后</h2><p>关于如何简单一键越狱的操作，博主就介绍到这里了，如有错误请多多指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-9&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;本文主要是记录一下如何越狱，博主这里指的是不完美越狱，博主这里越狱的手机是：iPhone5s  iOS12.5.6。&lt;/p&gt;
&lt;p&gt;首先，你需要有：iPhone手机、Mac电脑，保证Mac和手机上都有&lt;a href=&quot;ht</summary>
      
    
    
    
    <category term="逆向" scheme="https://codersunny.com/categories/%E9%80%86%E5%90%91/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="逆向" scheme="https://codersunny.com/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="iPhone" scheme="https://codersunny.com/tags/iPhone/"/>
    
  </entry>
  
  <entry>
    <title>【iOS重学】一篇文章讲清楚+load和+initialize</title>
    <link href="https://codersunny.com/posts/8f7262c3/"/>
    <id>https://codersunny.com/posts/8f7262c3/</id>
    <published>2022-11-28T01:35:15.000Z</published>
    <updated>2023-03-05T09:52:30.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-17">写在前面</h2><p>本文主要从底层源码上来分析一下<code>+load</code>和<code>+initialize</code>方法的调用顺序以及它们之间的区别。</p><h2 id="load">+load</h2><p><code>+load</code>方法会在<code>Runtime</code>加载类、分类的时候调用，每个类、分类的<code>+load</code>方法在程序运行过程中只会调用一次。</p><h3 id="load的基本使用">+load的基本使用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Person + Test1 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person + Test2 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student 类 继承自Person</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student + Test1 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student + Test2 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面场景，<code>+load</code>方法的打印顺序为：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">34.392232</span>+<span class="number">0800</span> CategoryDemo[<span class="number">88835</span>:<span class="number">2251283</span>] +[Person load]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">34.392867</span>+<span class="number">0800</span> CategoryDemo[<span class="number">88835</span>:<span class="number">2251283</span>] +[Student load]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">34.392964</span>+<span class="number">0800</span> CategoryDemo[<span class="number">88835</span>:<span class="number">2251283</span>] +[Animal load]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">34.393013</span>+<span class="number">0800</span> CategoryDemo[<span class="number">88835</span>:<span class="number">2251283</span>] +[Student(Test1) load]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">34.393056</span>+<span class="number">0800</span> CategoryDemo[<span class="number">88835</span>:<span class="number">2251283</span>] +[Person(Test1) load]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">34.393107</span>+<span class="number">0800</span> CategoryDemo[<span class="number">88835</span>:<span class="number">2251283</span>] +[Student(Test2) load]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">34.393151</span>+<span class="number">0800</span> CategoryDemo[<span class="number">88835</span>:<span class="number">2251283</span>] +[Person(Test2) load]</span><br></pre></td></tr></table></figure><p>那么，它们之间究竟是什么样的一个加载顺序呢？</p><h3 id="load的底层源码">+load的底层源码</h3><p><code>+load</code>方法的源码查看顺序：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-os文件</span></span><br><span class="line"><span class="number">1.</span> _objc_init</span><br><span class="line"><span class="number">2.</span> load_images</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-runtime-new文件</span></span><br><span class="line"><span class="number">3.</span> prepare_load_methods</span><br><span class="line">  <span class="number">3.1</span> schedule_class_load</span><br><span class="line">  <span class="number">3.2</span> add_category_to_loadable_list</span><br><span class="line"><span class="number">4.</span> call_load_methods</span><br><span class="line">  <span class="number">4.1</span> call_class_loads - (*load_method)(cls, <span class="keyword">@selector</span>(load))</span><br><span class="line">  <span class="number">4.2</span> call_category_loads</span><br></pre></td></tr></table></figure><p>在<a href="https://codersunny.com/posts/dfd029e5/">【iOS重学】Category的底层原理</a>中博主提到<code>Runtime</code>入口就是：<code>objc-os</code>文件中的<code>_objc_init</code>方法，我们就从这里入手分析一下底层源码。</p><p><code>prepare_load_methods</code>方法源码如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1128/1.png" alt="1"></p><div class="note green no-icon flat"><p><strong>解释</strong>：</p><p>1、先按照编译顺序将所有的类<code>add_class_to_loadable_list</code>装载到<code>loadable_classes</code>的数组中。</p><p>2、再按照编译顺序将所有的分类<code>add_class_to_loadable_list</code>装载到<code>loadable_classes</code>的数组中。</p></div><p><code>schedule_class_load</code>方法源码如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1128/2.png" alt="2"></p><div class="note green no-icon flat"><p><strong>解释</strong>：</p><p>在装载类到<code>loadable_classes</code>数组中时，如果存在父类，先将父类装载到<code>loadable_classes</code>中，再将类加载到数组中。</p></div><p><code>call_load_methods</code>方法源码如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1128/3.png" alt="3"></p><div class="note green no-icon flat"><p><strong>解释</strong>：</p><p>在调用<code>+load</code>方法时，先调用类的<code>+load</code>方法再调用分类的<code>+load</code>方法。</p></div><h3 id="load的调用顺序总结">+load的调用顺序总结</h3><div class="note green no-icon flat"><p>1、先调用类的<code>+load</code></p><p>​1.1 按照编译顺序进行调用（先编译 -&gt; 先调用）</p><p>​1.2 调用子类<code>+load</code>之前会先调用父类的<code>+load</code></p><p>2、再调用分类的<code>+load</code></p><p>​2.1 按照编译顺序进行调用（先编译 -&gt; 先调用）</p><p><strong>注意</strong>：<code>+load</code>只会调用一次，比如<code>Student</code>在<code>Person</code>之前编译，会先调用<code>Person</code>的<code>+load</code>方法，表示<code>Person</code>已经被装载进内存了，所以<code>+load</code>不会被调用多次。</p></div><h3 id="load的调用方式">+load的调用方式</h3><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1128/4.png" alt="4"></p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> loadable_class &#123;</span><br><span class="line">    Class cls;  <span class="comment">// may be nil</span></span><br><span class="line">    IMP method; <span class="comment">// 这个method 就是+load的IMP 这个loadable_class就是用来加载类的结构体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上图<code>call_class_loads</code>方法所示，<code>+load</code>方法的调用方式是：直接根据<code>+load</code>方法的函数地址直接去调用。</p><h2 id="initialize">+initialize</h2><p><code>+initialize</code>方法会在类第一次接收到消息的时候调用。</p><h3 id="initialize的基本使用">+initialize的基本使用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Person + Test1 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person + Test2 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student 类 继承自Person</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student + Test1 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span> (<span class="title">Test1</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student + Test2 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span> (<span class="title">Test2</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面场景，<code>+initialize</code>方法的打印顺序为：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">10.526685</span>+<span class="number">0800</span> CategoryDemo[<span class="number">57742</span>:<span class="number">2613672</span>] +[Person(Test2) initialize]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">00</span>:<span class="number">10.527249</span>+<span class="number">0800</span> CategoryDemo[<span class="number">57742</span>:<span class="number">2613672</span>] +[Student(Test2) initialize]</span><br></pre></td></tr></table></figure><h3 id="initialize的底层源码">+initialize的底层源码</h3><p><code>+initialize</code>方法源码的查看顺序：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm文件</span></span><br><span class="line"><span class="number">1.</span> class_getInstanceMethod</span><br><span class="line"><span class="number">2.</span> lookUpImpOrForward</span><br><span class="line"><span class="number">3.</span> realizeAndInitializeIfNeeded_locked</span><br><span class="line"><span class="number">4.</span> initializeAndLeaveLocked</span><br><span class="line"><span class="number">5.</span> initializeAndMaybeRelock</span><br><span class="line"><span class="number">6.</span> initializeNonMetaClass</span><br><span class="line"><span class="number">7.</span> callInitialize</span><br></pre></td></tr></table></figure><p><code>initializeNonMetaClass</code>方法源码如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1128/5.png" alt="5"></p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1128/6.png" alt="6"></p><div class="note green no-icon flat"><p><strong>解释</strong>：</p><p>从上面的源码我们大概可以看到：在调用<code>callInitialize</code>方法之前会去检查是否存在父类和父类是否被初始化，会先去调用父类的<code>+initialize</code>方法。</p></div><h3 id="initialize的调用顺序总结">+initialize的调用顺序总结</h3><div class="note green no-icon flat"><p>先调用父类的<code>+initialize</code>，再调用子类的<code>+initialize</code>。</p><p><strong>注意</strong>：</p><p>1、先初始化父类再初始化子类，每个类只会被初始化一次，但是可能会被调用多次。</p><p>比如下面场景：</p><p>1.<code>Student</code>没有实现<code>+initialize</code>方法，调用<code> [Person alloc]</code> <code> [Student alloc]</code>会调用两次<code>Person</code> 的<code>+initialize</code>方法。</p><p>打印结果如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">01</span>:<span class="number">47.579047</span>+<span class="number">0800</span> CategoryDemo[<span class="number">57804</span>:<span class="number">2615728</span>] +[Person(Test2) initialize]</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">01</span>:<span class="number">47.579702</span>+<span class="number">0800</span> CategoryDemo[<span class="number">57804</span>:<span class="number">2615728</span>] +[Person(Test2) initialize]</span><br></pre></td></tr></table></figure><p>2.<code>Student</code>实现了<code>+initialize</code>方法，<code>Person</code>调用过了<code>+initialize</code>，那么就不会再调用了。</p></div><h3 id="initialize调用方式">+initialize调用方式</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((<span class="type">void</span>(*)(Class, SEL))objc_msgSend)(cls, <span class="keyword">@selector</span>(initialize));</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上图<code>callInitialize</code>方法所示，<code>+initialize</code>方法的调用方式是：<code>obj_msgSend</code>。</p><h2 id="load和-initialize对比">+load和+initialize对比</h2><p>1、调用时机：</p><p><code>+load</code>是在<code>Runtime</code>加载类、分类的时候调用（只会调用一次），在<code>main</code>函数之前。</p><p><code>+initialize</code>是在类第一次接收到消息的时候调用，只会初始化一次（父类的<code>+initialize</code>可能会被调用多次），在<code>main</code>函数之后。</p><p>2、调用方式：</p><p><code>+load</code>是根据函数地址直接调用。</p><p><code>+initialize</code>是通过<code>objc_msgSend</code>调用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-17&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;本文主要从底层源码上来分析一下&lt;code&gt;+load&lt;/code&gt;和&lt;code&gt;+initialize&lt;/code&gt;方法的调用顺序以及它们之间的区别。&lt;/p&gt;
&lt;h2 id=&quot;load&quot;&gt;+load&lt;/h2&gt;
&lt;p&gt;&lt;c</summary>
      
    
    
    
    <category term="iOS" scheme="https://codersunny.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://codersunny.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【iOS重学】Category的底层原理</title>
    <link href="https://codersunny.com/posts/dfd029e5/"/>
    <id>https://codersunny.com/posts/dfd029e5/</id>
    <published>2022-11-24T06:16:34.000Z</published>
    <updated>2023-03-05T09:52:30.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-14">写在前面</h2><p>本文博主将从<code>Category</code>的基本使用和底层原理来窥探一下Runtime下的<code>Category</code> 是如何实现的。博主这里参考的苹果源码版本是：<code>objc4_838</code>版本。</p><h2 id="Category的基本使用">Category的基本使用</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person + Test 分类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>使用命令：<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc Person+Test.m -o Person+test.cpp</code>将<code>Person+Test.m</code>文件转化为c++底层代码，分析该c++文件，我们可以看到分类的底层结构为：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> _category_t &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="type">char</span> *name; <span class="comment">// 类名</span></span><br><span class="line"><span class="keyword">struct</span> _class_t *cls;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _method_list_t *instance_methods; <span class="comment">// 实例方法列表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _method_list_t *class_methods; <span class="comment">// 类方法列表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _protocol_list_t *protocols; <span class="comment">// 协议列表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _prop_list_t *properties; <span class="comment">// 属性列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Person+Test.m</code>底层结构为：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/8.png" alt="8"></p><p>对应上面<code>_category_t</code>结构可以看到：</p><div class="note red no-icon flat"><p>1.本类名为<code>Person</code>。</p><p>2.因为<code>Person+Test.m</code>我们只写了一个test的实例方法，所以我这里也很明显看到这里传了一个方法列表。</p><p><strong>注</strong>：这里的<code>_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Test</code>其实就是一个结构体名称。</p></div><h2 id="Category底层原理窥探">Category底层原理窥探</h2><p>运行时Runtime入口：<code>objc-os.mm</code>文件。</p><p>Category源码阅读顺序：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-os.mm 文件</span></span><br><span class="line"><span class="number">1.</span> _objc_init </span><br><span class="line"><span class="number">3.</span> map_images_nolock</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc_runtime_new.mm 文件</span></span><br><span class="line"><span class="number">2.</span> map_images</span><br><span class="line"><span class="number">4.</span> loadAllCategories();</span><br><span class="line"><span class="number">5.</span> load_categories_nolock();</span><br><span class="line"><span class="number">6.</span> attachCategories();</span><br><span class="line"><span class="number">7.</span> attachLists();</span><br></pre></td></tr></table></figure><p>其中 4 - 7 是我们接下来需要重点分析的。</p><h3 id="Category-t-结构体">Category_t 结构体</h3><p>Runtime下<code>Category_t</code>结构体如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> category_t &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="type">char</span> *name;</span><br><span class="line">  classref_t cls;</span><br><span class="line">  WrappedPtr&lt;method_list_t, method_list_t::Ptrauth&gt; instanceMethods;</span><br><span class="line">  WrappedPtr&lt;method_list_t, method_list_t::Ptrauth&gt; classMethods;</span><br><span class="line">  <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">  <span class="keyword">struct</span> property_list_t *instanceProperties;</span><br><span class="line">  <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">  <span class="keyword">struct</span> property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">  method_list_t *methodsForMeta(<span class="type">bool</span> isMeta) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  property_list_t *propertiesForMeta(<span class="type">bool</span> isMeta, <span class="keyword">struct</span> header_info *hi);</span><br><span class="line"></span><br><span class="line">  protocol_list_t *protocolsForMeta(<span class="type">bool</span> isMeta) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> nullptr;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> protocols;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="map-images-nolock">map_images_nolock</h3><p><code>map_images_nolock</code>可以理解为是运行时的开始，内部实现如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/9.png" alt="9"></p><p>从上图可以看到：这里因为是倒序遍历也就影响了分类方法之间的优先级顺序，所以后编译的分类方法会放在先编译的前面。</p><h3 id="loadAllCategories">loadAllCategories</h3><p>该方法指的是：加载项目中所有分类。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> loadAllCategories() &#123;</span><br><span class="line">  mutex_locker_t lock(runtimeLock);</span><br><span class="line">  <span class="keyword">for</span> (auto *hi = FirstHeader; hi != <span class="literal">NULL</span>; hi = hi-&gt;getNext()) &#123;</span><br><span class="line">    <span class="comment">// 加载每个类所有的分类模块</span></span><br><span class="line">    load_categories_nolock(hi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="load-categories-nolock">load_categories_nolock</h3><p>该方法指的是：加载一个类所有的分类模块。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> load_categories_nolock(header_info *hi) &#123;</span><br><span class="line">  <span class="comment">// 是否有类属性</span></span><br><span class="line">  <span class="type">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">  size_t count;</span><br><span class="line">  auto processCatlist = [&amp;](category_t * <span class="keyword">const</span> *catlist) &#123;</span><br><span class="line">      <span class="comment">// 遍历需要处理的分类列表</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          category_t *cat = catlist[i];</span><br><span class="line">          <span class="comment">// 获取分类的主类</span></span><br><span class="line">          Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">          locstamped_category_t lc&#123;cat, hi&#125;;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">              <span class="comment">// 获取不到本类 可能是弱链接</span></span><br><span class="line">              <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                  _objc_inform(<span class="string">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span></span><br><span class="line">                               <span class="string">&quot;missing weak-linked target class&quot;</span>,</span><br><span class="line">                               cat-&gt;name, cat);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Process this category.</span></span><br><span class="line">          <span class="keyword">if</span> (cls-&gt;isStubClass()) &#123;</span><br><span class="line">              <span class="comment">// 无法确定元类对象是哪个 所以先附着在stubClass身上</span></span><br><span class="line">              <span class="comment">// Stub classes are never realized. Stub classes</span></span><br><span class="line">              <span class="comment">// don&#x27;t know their metaclass until they&#x27;re</span></span><br><span class="line">              <span class="comment">// initialized, so we have to add categories with</span></span><br><span class="line">              <span class="comment">// class methods or properties to the stub itself.</span></span><br><span class="line">              <span class="comment">// methodizeClass() will find them and add them to</span></span><br><span class="line">              <span class="comment">// the metaclass as appropriate.</span></span><br><span class="line">              <span class="keyword">if</span> (cat-&gt;instanceMethods ||</span><br><span class="line">                  cat-&gt;protocols ||</span><br><span class="line">                  cat-&gt;instanceProperties ||</span><br><span class="line">                  cat-&gt;classMethods ||</span><br><span class="line">                  cat-&gt;protocols ||</span><br><span class="line">                  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">              &#123;</span><br><span class="line">                  objc::unattachedCategories.addForClass(lc, cls);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// First, register the category with its target class.</span></span><br><span class="line">              <span class="comment">// Then, rebuild the class&#x27;s method lists (etc) if</span></span><br><span class="line">              <span class="comment">// the class is realized.</span></span><br><span class="line">              <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols</span><br><span class="line">                  ||  cat-&gt;instanceProperties)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span> (cls-&gt;isRealized()) &#123; <span class="comment">// 类对象已经初始化完毕 进行合并</span></span><br><span class="line">                      attachCategories(cls, &amp;lc, <span class="number">1</span>, ATTACH_EXISTING);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      objc::unattachedCategories.addForClass(lc, cls);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols</span><br><span class="line">                  ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123; <span class="comment">// 元类对象已经初始化完毕 进行合并</span></span><br><span class="line">                      attachCategories(cls-&gt;ISA(), &amp;lc, <span class="number">1</span>, ATTACH_EXISTING | ATTACH_METACLASS);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      objc::unattachedCategories.addForClass(lc, cls-&gt;ISA());</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  processCatlist(hi-&gt;catlist(&amp;count));</span><br><span class="line">  processCatlist(hi-&gt;catlist2(&amp;count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="attachCategories">attachCategories</h3><p>该方法指的是：合并分类的方法列表、属性列表、协议列表等到本类里面。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span></span><br><span class="line">attachCategories(Class cls, <span class="keyword">const</span> locstamped_category_t *cats_list, uint32_t cats_count,</span><br><span class="line">                 <span class="type">int</span> flags) &#123;</span><br><span class="line">  <span class="keyword">if</span> (slowpath(PrintReplacedMethods)) &#123;</span><br><span class="line">      printReplacements(cls, cats_list, cats_count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (slowpath(PrintConnecting)) &#123;</span><br><span class="line">      _objc_inform(<span class="string">&quot;CLASS: attaching %d categories to%s class &#x27;%s&#x27;%s&quot;</span>,</span><br><span class="line">                   cats_count, (flags &amp; ATTACH_EXISTING) ? <span class="string">&quot; existing&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                   cls-&gt;nameForLogging(), (flags &amp; ATTACH_METACLASS) ? <span class="string">&quot; (meta)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Only a few classes have more than 64 categories during launch.</span></span><br><span class="line"><span class="comment">   * This uses a little stack, and avoids malloc.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Categories must be added in the proper order, which is back</span></span><br><span class="line"><span class="comment">   * to front. To do that with the chunking, we iterate cats_list</span></span><br><span class="line"><span class="comment">   * from front to back, build up the local buffers backwards,</span></span><br><span class="line"><span class="comment">   * and call attachLists on the chunks. attachLists prepends the</span></span><br><span class="line"><span class="comment">   * lists, so the final result is in the expected order.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  constexpr uint32_t ATTACH_BUFSIZ = <span class="number">64</span>;</span><br><span class="line">  method_list_t   *mlists[ATTACH_BUFSIZ];</span><br><span class="line">  property_list_t *proplists[ATTACH_BUFSIZ];</span><br><span class="line">  protocol_list_t *protolists[ATTACH_BUFSIZ];</span><br><span class="line"></span><br><span class="line">  uint32_t mcount = <span class="number">0</span>;</span><br><span class="line">  uint32_t propcount = <span class="number">0</span>;</span><br><span class="line">  uint32_t protocount = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> fromBundle = <span class="literal">NO</span>;</span><br><span class="line">  <span class="type">bool</span> isMeta = (flags &amp; ATTACH_METACLASS);</span><br><span class="line">  auto rwe = cls-&gt;data()-&gt;extAllocIfNeeded();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历某个类的分类列表</span></span><br><span class="line">  <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; cats_count; i++) &#123;</span><br><span class="line">      auto&amp; entry = cats_list[i];</span><br><span class="line">      <span class="comment">// 取出分类里面的方法列表</span></span><br><span class="line">      method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">      <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">              prepareMethodLists(cls, mlists, mcount, <span class="literal">NO</span>, fromBundle, __func__);</span><br><span class="line">              rwe-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">              mcount = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将分类的方法列表放在创建好的容器里面</span></span><br><span class="line">          mlists[ATTACH_BUFSIZ - ++mcount] = mlist;</span><br><span class="line">          fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出分类里面的属性列表</span></span><br><span class="line">      property_list_t *proplist =</span><br><span class="line">          entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">      <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">          <span class="keyword">if</span> (propcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">              rwe-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">              propcount = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          proplists[ATTACH_BUFSIZ - ++propcount] = proplist;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出分类里面的协议列表</span></span><br><span class="line">      protocol_list_t *protolist = entry.cat-&gt;protocolsForMeta(isMeta);</span><br><span class="line">      <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">          <span class="keyword">if</span> (protocount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">              rwe-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">              protocount = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          protolists[ATTACH_BUFSIZ - ++protocount] = protolist;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mcount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果有剩下的方法列表</span></span><br><span class="line">      prepareMethodLists(cls, mlists + ATTACH_BUFSIZ - mcount, mcount,</span><br><span class="line">                         <span class="literal">NO</span>, fromBundle, __func__);</span><br><span class="line">      <span class="comment">// 将剩下的方法列表附着在本类的方法列表</span></span><br><span class="line">      rwe-&gt;methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);</span><br><span class="line">      <span class="keyword">if</span> (flags &amp; ATTACH_EXISTING) &#123;</span><br><span class="line">          flushCaches(cls, __func__, [](Class c)&#123;</span><br><span class="line">              <span class="comment">// constant caches have been dealt with in prepareMethodLists</span></span><br><span class="line">              <span class="comment">// if the class still is constant here, it&#x27;s fine to keep</span></span><br><span class="line">              <span class="keyword">return</span> !c-&gt;cache.isConstantOptimizedCache();</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rwe-&gt;properties.attachLists(proplists + ATTACH_BUFSIZ - propcount, propcount);</span><br><span class="line"></span><br><span class="line">  rwe-&gt;protocols.attachLists(protolists + ATTACH_BUFSIZ - protocount, protocount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="attachLists">attachLists</h3><p>该方法指的是：把分类方法真正合并在主类的方法列表里面。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> attachLists(List* <span class="keyword">const</span> * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">  <span class="comment">// 如果添加的方法列表count为0 直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">          <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        <span class="comment">// 本类里面有多个方法列表</span></span><br><span class="line">          uint32_t oldCount = array()-&gt;count;</span><br><span class="line">          uint32_t newCount = oldCount + addedCount;</span><br><span class="line">          array_t *newArray = (array_t *)malloc(array_t::byteSize(newCount));</span><br><span class="line">          newArray-&gt;count = newCount;</span><br><span class="line">          array()-&gt;count = newCount;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> i = oldCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">              newArray-&gt;lists[i + addedCount] = array()-&gt;lists[i]; <span class="comment">// 这个其实是在把之前的方法列表挪到新数组后面。</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">              newArray-&gt;lists[i] = addedLists[i]; <span class="comment">// 把分类的方法列表添加到新数组里面。</span></span><br><span class="line">          free(array());</span><br><span class="line">          setArray(newArray);</span><br><span class="line">          validate();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!list  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 本类原本没有方法列表 分类方法列表Count == 1</span></span><br><span class="line">          list = addedLists[<span class="number">0</span>];</span><br><span class="line">          validate();</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 本类原本只有一个方法列表 </span></span><br><span class="line">          Ptr&lt;List&gt; oldList = list;</span><br><span class="line">          uint32_t oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">          uint32_t newCount = oldCount + addedCount;</span><br><span class="line">          setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">          array()-&gt;count = newCount;</span><br><span class="line">          <span class="keyword">if</span> (oldList) array()-&gt;lists[addedCount] = oldList;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">              array()-&gt;lists[i] = addedLists[i];</span><br><span class="line">          validate();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> tryFree() &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">          <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; array()-&gt;count; i++) &#123;</span><br><span class="line">              try_free(array()-&gt;lists[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          try_free(array());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (list) &#123;</span><br><span class="line">          try_free(list);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  template&lt;<span class="keyword">typename</span> Other&gt;</span><br><span class="line">  <span class="type">void</span> duplicateInto(Other &amp;other) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">          array_t *a = array();</span><br><span class="line">          other.setArray((array_t *)memdup(a, a-&gt;byteSize()));</span><br><span class="line">          <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; a-&gt;count; i++) &#123;</span><br><span class="line">              other.array()-&gt;lists[i] = a-&gt;lists[i]-&gt;duplicate();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list) &#123;</span><br><span class="line">          other.list = list-&gt;duplicate();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          other.list = <span class="literal">nil</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>attachLists</code>方法是分类原理实现最核心的方法，我这里用一张图来模拟分类的底层原理如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/10.png" alt="10"></p><h3 id="模拟场景">模拟场景</h3><p>模拟场景：<code>Person</code>类有两个分类：<code>Person+Eat.h</code>和<code>Person+Run.h</code>，如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test；</span><br><span class="line">- (<span class="type">void</span>)test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Person + Eat 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Eat</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)eat;</span><br><span class="line">- (<span class="type">void</span>)test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Person + Run 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Run</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)run;</span><br><span class="line">- (<span class="type">void</span>)test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>按照上图的分析结果，<code>Person</code>类中<code>class_rw_ext_t</code>中<code>methods</code>结构如下：</p><div class="note red no-icon flat"><p><strong>解释</strong>：</p><p>1.把Person的方法列表挪动到数组最后</p><p>2.把Person的分类方法列表添加到前</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/11.png" alt="11"></p></div><div class="note orange no-icon flat"><p><strong>提示</strong>：</p><p>1、如果主类和分类都会有<code>-(void)test</code>方法，会优先调用分类的方法，原因是分类的方法列表在前面，注意这里不是覆盖了原来的方法。</p><p>2、<code>Person</code>两个分类都有<code>-(void)test</code>方法，调用哪个方法是根据<strong>编译顺序</strong>来决定的，后参与编译的优先级更高，比如上例中调用的是<code>Person+Eat</code>中的<code>test</code>方法。</p></div><h2 id="写在最后-8">写在最后</h2><p>啦啦啦，关于<code>Category</code>的底层原理窥探就到这里结束了，如有错误的地方还望各位大佬多多指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-14&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;本文博主将从&lt;code&gt;Category&lt;/code&gt;的基本使用和底层原理来窥探一下Runtime下的&lt;code&gt;Category&lt;/code&gt; 是如何实现的。博主这里参考的苹果源码版本是：&lt;code&gt;objc4_838</summary>
      
    
    
    
    <category term="iOS" scheme="https://codersunny.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://codersunny.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Runtime" scheme="https://codersunny.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>【 iOS重学】class_rw_ext_t结构详解</title>
    <link href="https://codersunny.com/posts/8948fead/"/>
    <id>https://codersunny.com/posts/8948fead/</id>
    <published>2022-11-24T03:04:41.000Z</published>
    <updated>2023-03-05T09:52:30.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-16">写在前面</h2><p>在<a href="https://codersunny.com/posts/b55a18a8/">iOS重学之窥探Class的结构</a>这篇文章中，我们分析Class的结构时提到了一个结构<code>class_rw_ext_t</code>，本文主要就这个结构来展开做个详细的分析，以及苹果为什么要这么做。</p><h2 id="class-rw-ext-t结构">class_rw_ext_t结构</h2><h3 id="简单介绍-2">简单介绍</h3><p>在WWDC2020中苹果介绍对类的修改时出现了一个新的结构：<code>class_rw_ext_t</code>，这个结构主要是Runtime在内存上做的一些优化而出现的，在苹果源码objc4_781版本开始出现<code>class_rw_ext_t</code>，大家也可以对照源码来阅读本文。</p><h3 id="clean-memory-和-dirty-memory">clean memory 和 dirty memory</h3><p>clean memory：加载后不会再发生变化的内存。</p><p>dirty memory：指的是在进程运行时会发生更改的内存。</p><div class="note red no-icon flat"><p><strong>提示</strong>：</p><p>dirty memory会比clean memory更加消耗性能和内存，dirty memory是只要进程在运行，它就必须一直存在，而clean memory可以在内存吃紧的时候移除来节省更多的内存空间，在需要的时候再次从磁盘中进行加载。</p></div><h3 id="class-rw-t-和-class-ro-t">class_rw_t 和 class_ro_t</h3><p>在<code>class_rw_ext_t</code>结构之前，整体Class 结构是：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/1.png" alt="1"></p><p>从上面的结构我们可以看到Class结构被拆分为两部分：<code>class_rw_t</code> 和 <code>class_ro_t</code>，这么拆分的原因就是为了保持更多的clean memory，从而节省内存空间，其中<code>class_rw_t</code>是dirty memory，而<code>class_ro_t</code>就是clean memory。</p><div class="note red no-icon flat"><p><strong>解释</strong>：</p><p>在没有<code>class_rw_ext_t</code>结构之前，当一个类被装载到内存中时就会初始化一个<code>class_rw_t</code>结构，并将<code>class_ro_t</code>结构中<code>Methods</code>、<code>Properties</code>、<code>Protocols</code>数据复制到<code>class_rw_t</code>中，我们上面提到过<code>class_rw_t</code>属于dirty memory，在程序运行的时候这块内存就必须一直存在，但是大概90%的类并不需要对其中的<code>Methods</code>进行修改，所以这部分的内存其实就是属于浪费，于是苹果拆分出来一个新的数据结构：<code>class_rw_ext_t</code>。</p></div><p>在<code>class_rw_ext_t</code>结构之后，整体Class结构是：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/2.png" alt="2"></p><p>从上面的结构图看到：苹果尽可能的减少dirty memory的大小来降低内存开销。他把<code>Methods</code>、<code>Properties</code>、<code>Protocols</code>、<code>Demangled Name</code>拆分到新的结构<code>class_rw_ext_t</code>中，这里的<code>ext</code>可以理解为extension（扩展）。</p><div class="note red no-icon flat"><p><strong>解释</strong>：</p><p>在有了<code>class_rw_ext_t</code>结构之后，当一个类被装载到内存中时就会初始化一个<code>class_rw_t</code>结构，但是并不会把<code>class_ro_t</code>中的相关数据完全复制到其中，这样就减少了<code>class_rw_t</code>的大小，利用懒加载的机制在确实需要额外的类的信息的时候再去初始化<code>class_rw_ext_t</code>结构来存放这些信息。</p></div><h3 id="验证内存变化">验证内存变化</h3><p>使用命令<code>heap xxx | egrep 'class_rw|COUNT'</code>来查看一些进程中<code>class_rw</code>类的内存情况，博主这里以微信和Xcode为例来看看：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/3.png" alt="3"></p><p>从上图看到：</p><p>WeChat中一共有6418个<code>class_rw_t</code>类，但是真的需要额外扩展<code>class_rw_ext_t</code>的只有474个，这个比例大概是7%，我们大概计算一下节省的内存：(6418 - 474) * 48 = 285312(B)。</p><p>Xcode中一共有15674个<code>class_rw_t</code>类，但是真的需要额外扩展<code>class_rw_ext_t</code>的只有2375个,这个比例大概是15%，节省的内存：（15674 - 2375） * 48 = 638352(B)。</p><p>对dirty memory而言，这是真正节省的内存，所以这个优化还是很可观的。</p><h3 id="查找方法的变化">查找方法的变化</h3><p>在<code>class_rw_ext_t</code>结构之前，runtime是直接遍历<code>class_rw_t</code>中的方法列表来查找方法，具体如下图：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/4.png" alt="4"></p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/5.png" alt="5"></p><p>在<code>class_rw_ext_t</code>结构之后，runtime查找方法的方式如下图：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/6.png" alt="6"></p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1124/7.png" alt="7"></p><h2 id="写在最后-12">写在最后</h2><p>关于<code>class_rw_ext_t</code>结构的分析和好处我们就分析到这里了，如果有什么不对的地方望指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-16&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://codersunny.com/posts/b55a18a8/&quot;&gt;iOS重学之窥探Class的结构&lt;/a&gt;这篇文章中，我们分析Class的结构时提到了一个结构&lt;code&gt;class_rw</summary>
      
    
    
    
    <category term="iOS" scheme="https://codersunny.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://codersunny.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Runtime" scheme="https://codersunny.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>【iOS重学】窥探Class的结构</title>
    <link href="https://codersunny.com/posts/b55a18a8/"/>
    <id>https://codersunny.com/posts/b55a18a8/</id>
    <published>2022-11-23T08:04:33.000Z</published>
    <updated>2023-03-05T09:52:30.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面-27">写在前面</h2><p>本文主要探究<code>Class</code>的内部结构，博主这里使用的objc4的源码版本是<code>objc4-838</code>，建议大家在看的时候可以下载最新源码。</p><h2 id="Class的结构-2">Class的结构</h2><p>在前面关于<a href="https://codersunny.com/posts/9efafc5a/">isa和superclass</a>文章中，我们提到了类对象和元类对象的类型都是<code>Class</code>，内存里面保存的是：</p><p>. isa指针</p><p>. superclass指针</p><p>. 属性信息</p><p>. 对象方法信息</p><p>. 协议信息</p><p>. 成员变量信息</p><p>今天我们就来剖析一下<code>Class</code>的内部结构，验证一下是不是存放的这些信息，废话不多说了，我们现在就开始吧。</p><p><code>Class</code>是个<code>objc_class</code>类型的结构体，如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure><p>在<code>objc4</code>源码<code>objc-runtime-new.h</code>文件中，对<code>objc_class</code>定义如下：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1123/1.png" alt="1"></p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1123/2.png" alt="2"></p><p>因为<code>objc_class</code>结构体中数据太多，我这里提炼出来对我们分析结构有用的数据，如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">  Class isa; <span class="comment">// isa</span></span><br><span class="line">  Class superclass; <span class="comment">// superclass</span></span><br><span class="line">  cache_t cache; <span class="comment">// 方法缓存</span></span><br><span class="line">  class_data_bits_t bits; <span class="comment">// 具体的类信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>class_data_bits_t</code>结构如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_data_bits_t &#123;</span><br><span class="line">  class_rw_t *data() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>class_rw_t</code>结构中，<code>rw</code>一般表示readwrite（可读可写），<code>t</code>一般表示table,结构信息如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">  uint32_t flags;</span><br><span class="line">  uint16_t witness;</span><br><span class="line">  Class firstSubclass;</span><br><span class="line">  Class nextSiblingClass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  所有的类会链接成一个树状结构 利用firstSubclass 和 nextSiblingClass来实现的。</span></span><br></pre></td></tr></table></figure><p><code>class_rw_ext_t</code>结构信息如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_ext_t &#123;</span><br><span class="line">  class_ro_t_authed_ptr&lt;<span class="keyword">const</span> class_ro_t&gt; ro;</span><br><span class="line">  method_array_t methods; <span class="comment">// 方法列表</span></span><br><span class="line">  property_array_t properties; <span class="comment">// 属性列表</span></span><br><span class="line">  protocol_array_t protocols; <span class="comment">// 协议列表</span></span><br><span class="line">  <span class="type">char</span> *demangledName;</span><br><span class="line">  uint32_t version;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note red no-icon flat"><p><strong>提醒</strong>：</p><p>在WWDC2020中，苹果修改了一些底层的类，其中一个就是我们上面介绍的<code>class_rw_ext_t</code>，至于这个类主要作用是什么大家有兴趣的可以去详细了解一下，博主这里就不展开来讲这个了，大概的意思就是：它利用了懒加载的机制，在类的<code>methods</code>、<code>properties</code>等发生变化的时候，才会初始化<code>class_rw_ext_t</code>来存储这些列表，这样就可以减少90%以前Runtime中的类在<code>rw</code>中直接复制<code>ro</code>中数据浪费的内存。</p></div><p><code>class_ro_t</code>结构中，<code>ro</code>一般表示readonly（只读），<code>t</code>一般表示table，结构信息如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">  uint32_t flags;</span><br><span class="line">  uint32_t instanceStart;</span><br><span class="line">  uint32_t instanceSize; <span class="comment">// instance对象占用的内存空间大小</span></span><br><span class="line">  </span><br><span class="line">  explicit_atomic&lt;<span class="keyword">const</span> <span class="type">char</span> *&gt; name; <span class="comment">// 类名</span></span><br><span class="line">  <span class="comment">// 方法列表（不包括分类的方法列表）</span></span><br><span class="line">  WrappedPtr&lt;method_list_t, method_list_t::Ptrauth&gt; baseMethods;</span><br><span class="line">  protocol_list_t * baseProtocols; <span class="comment">// 协议信息列表</span></span><br><span class="line">  <span class="keyword">const</span> ivar_list_t * ivars; <span class="comment">// 成员变量列表</span></span><br><span class="line">  property_list_t *baseProperties; <span class="comment">// 属性信息列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一张图来表示Class结构：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1123/3.png" alt="3"></p><p>从上面的结构分析我们可以看到：class对象或meta-class对象里面确实保存了<strong>方法列表、属性列表、协议列表、成员变量列表</strong>等信息。</p><h2 id="写在最后-18">写在最后</h2><p>关于<code>Class</code>结构信息我们就分析到这里了，如果有什么不对的地方望指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面-27&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;本文主要探究&lt;code&gt;Class&lt;/code&gt;的内部结构，博主这里使用的objc4的源码版本是&lt;code&gt;objc4-838&lt;/code&gt;，建议大家在看的时候可以下载最新源码。&lt;/p&gt;
&lt;h2 id=&quot;Class的结构</summary>
      
    
    
    
    <category term="iOS" scheme="https://codersunny.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://codersunny.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【iOS重学】KVC详解</title>
    <link href="https://codersunny.com/posts/8583d944/"/>
    <id>https://codersunny.com/posts/8583d944/</id>
    <published>2022-11-21T10:04:23.000Z</published>
    <updated>2023-03-05T09:52:30.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KCV的基本使用">KCV的基本使用</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设值</span></span><br><span class="line">- (<span class="type">void</span>)setValue:(<span class="type">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">void</span>)setValue:(<span class="type">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">- (<span class="type">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Student类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Student *student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体使用</span></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">person.student = [[Student alloc] init];</span><br><span class="line">[person setValue:@(<span class="number">10</span>) forKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">[person setValue:<span class="string">@&quot;Sunny&quot;</span> forKeyPath:<span class="string">@&quot;student.name&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;age:%@ name:%@&quot;</span>, [person valueForKey:<span class="string">@&quot;age&quot;</span>], [person valueForKeyPath:<span class="string">@&quot;student.name&quot;</span>]);</span><br></pre></td></tr></table></figure><h2 id="KVC的设值原理">KVC的设值原理</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">@public</span></span><br><span class="line">  <span class="type">int</span> _age;</span><br><span class="line">  <span class="type">int</span> _isAge;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">int</span> isAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)accessInstanceVariablesDirectly &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setAge:(<span class="type">int</span>)age &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)_setAge:(<span class="type">int</span>)age &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setValue:(<span class="type">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ViewController类</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">  Person *person = [[Person alloc] init];</span><br><span class="line">  [person setValue:@(<span class="number">10</span>) forKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><div class="note green no-icon flat"><p><strong>解释</strong>：</p><p>1、当存在<code>setKey</code>方法时，调用<code>setKey</code>。</p><p>2、当<code>setKey</code>方法不存在，存在<code>_setKey</code>方法时，调用<code>_setKey</code>。</p><p>3、当<code>setKey</code>和<code>_setKey</code>都不存在时，检查<code>+(BOOL)accessInstanceVariablesDirectly</code>返回值。</p><p>4、如果<code>+(BOOL)accessInstanceVariablesDirectly</code>返回NO，调用<code>-(void)setValue:(id)value forUndefinedKey:(NSString *)key</code>，程序结束。</p><p>5、如果<code>+(BOOL)accessInstanceVariablesDirectly</code>返回YES，按照<code>_key</code>、<code>_isKey</code>、<code>key</code>、<code>isKey</code>的顺序查找成员变量赋值。</p><p>6、如果按照上面的流程都没找到，调用<code>-(void)setValue:(id)value forUndefinedKey:(NSString *)key</code>，程序结束。</p></div><p>用一张图来总结KVC设值的查找顺序：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1121/1.png" alt="1"></p><p><strong>总结</strong>：</p><p>按照上面流程都没有查找到对应的方法或成员变量可以赋值就是调用我们常见的一个方法:<code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code>抛出异常。</p><p><strong>注意</strong>：</p><p>针对KVC赋值，即使没有找到<code>setKey</code>或<code>_setKey</code>，只要找到一个成员变量也是会触发KVO的，KVC本身自己在内部会去通知相应的observer观察者某个属性发生了变化。</p><p>其实就是在内部调用了:</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><h2 id="KVC的取值原理">KVC的取值原理</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">@public</span></span><br><span class="line">  <span class="type">int</span> _age;</span><br><span class="line">  <span class="type">int</span> _isAge;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">int</span> isAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)accessInstanceVariablesDirectly &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)getAge &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)age &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)isAge &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)_age &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// ViewController 类</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">  Person *person = [[Person alloc] init];</span><br><span class="line">  [person valueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><div class="note green no-icon flat"><p><strong>解释</strong>：</p><p>1、当存在<code>getKey</code>方法时，调用<code>getKey</code>。</p><p>2、当<code>getKey</code>方法不存在，存在<code>key</code>方法时，调用<code>key</code>。</p><p>3、当<code>getKey</code>、<code>key</code>方法不存在，存在<code>isKey</code>方法时，调用<code>isKey</code>。</p><p>4、当<code>getKey</code>、<code>key</code>、<code>isKey</code> 方法不存在，存在<code>_key</code>方法时，调用<code>_key</code>。</p><p>5、当<code>getKey</code>、<code>key</code>、<code>isKey</code> 、<code>_key</code>都不存在时，检查<code>+(BOOL)accessInstanceVariablesDirectly</code>返回值。</p><p>6、如果<code>+(BOOL)accessInstanceVariablesDirectly</code>返回NO，调用<code>- (id)valueForUndefinedKey:(NSString *)key</code>，程序结束。</p><p>7、如果<code>+(BOOL)accessInstanceVariablesDirectly</code>返回YES，按照<code>_key</code>、<code>_isKey</code>、<code>key</code>、<code>isKey</code>的顺序查找成员变量赋值。</p><p>8、如果按照上面的流程都没找到对应的方法或成员变量，调用<code>- (id)valueForUndefinedKey:(NSString *)key</code>，程序结束。</p></div><p>用一张图来总结KVC取值的查找顺序：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1121/2.png" alt="2"></p><p><strong>总结</strong>：</p><p>按照上面流程都没有查找到对应的方法或成员变量可以赋值就是调用我们常见的一个方法:<code>- (id)valueForUndefinedKey:(NSString *)key</code>抛出异常。</p><h2 id="写在最后-9">写在最后</h2><p>关于iOS里面的KVC设值、取值的相关顺序就写到这里了，如有错误请指教。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;KCV的基本使用&quot;&gt;KCV的基本使用&lt;/h2&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// </summary>
      
    
    
    
    <category term="iOS" scheme="https://codersunny.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://codersunny.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【iOS重学】KVO详解</title>
    <link href="https://codersunny.com/posts/4223b330/"/>
    <id>https://codersunny.com/posts/4223b330/</id>
    <published>2022-11-15T11:55:30.000Z</published>
    <updated>2023-03-05T09:52:30.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KVO的基本使用">KVO的基本使用</h2><h3 id="基本使用">基本使用</h3><p>KVO：Key Value Observing（键值监听），用来监听某个对象属性值的改变。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// KVOViewController</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KVOViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Person *person1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Person *person2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KVOViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">self</span>.person1 = [[Person alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.person1.age = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">self</span>.person2 = [[Person alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.person2.age = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="literal">NULL</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">self</span>.person1.age = <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">self</span>.person2.age = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="type">id</span>&gt; *)change context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@对象的%@属性发生了改变：\n%@&quot;</span>,object, keyPath,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-15</span> <span class="number">20</span>:<span class="number">08</span>:<span class="number">33.563589</span>+<span class="number">0800</span> OC对象的本质[<span class="number">81675</span>:<span class="number">15955895</span>] &lt;Person: <span class="number">0x6000007519c0</span>&gt;对象的age属性发生了改变：</span><br><span class="line">&#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="number">11</span>;</span><br><span class="line">    old = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在不需要监听的时候需要移除。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.person1 removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note green no-icon flat"><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1115/3.png" alt="3"></p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1115/4.png" alt="4"></p><p><strong>解释</strong>：</p><p>1、KVO是建立在KVC的基础之上的，即是说给成员变量赋值KVO是无法监听其变化的。</p><p>2、context意为上下文信息，我们平时用的时候一般传的<code>NULL</code>，但是苹果官方建议的是把这个参数用起来会更安全、扩展性更强。</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1115/5.png" alt="5"></p></div><h3 id="KVO其他细节">KVO其他细节</h3><h4 id="1、是否打开自动观察的开关">1、是否打开自动观察的开关</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>) automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>; <span class="comment">// 默认是YES</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、返回可能影响监听值的NSSet">2、返回可能影响监听值的NSSet</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当writtenData发生改变的时候，downloadProgress就会发生改变</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">NSSet</span>&lt;<span class="type">NSString</span> *&gt; <span class="operator">*</span>)keyPathsForValuesAffectingValueForKey:(<span class="type">NSString</span> <span class="operator">*</span>)key &#123;</span><br><span class="line">    <span class="type">NSSet</span> <span class="operator">*</span>keyPaths <span class="operator">=</span> [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:@<span class="string">&quot;downloadProgress&quot;</span>]) &#123;</span><br><span class="line">        <span class="type">NSArray</span> <span class="operator">*</span>affectingKeys <span class="operator">=</span> @[@<span class="string">&quot;writtenData&quot;</span>];  <span class="comment">// 只要affectingKeys数组里面的属性发生变化 都会触发downloadProgress的KVO</span></span><br><span class="line">        keyPaths <span class="operator">=</span> [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、对可变数组的监听">3、对可变数组的监听</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.person1.booksArr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">[<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;booksArr&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</span><br><span class="line">[[<span class="keyword">self</span>.person1 mutableArrayValueForKey:<span class="string">@&quot;booksArr&quot;</span>] addObjectsFromArray:@[<span class="string">@&quot;Hello&quot;</span>, <span class="string">@&quot;World&quot;</span>]];</span><br></pre></td></tr></table></figure><p>// 打印结果：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1115/6.png" alt="6"></p><h2 id="KVO的本质分析">KVO的本质分析</h2><p>从上面的例子咱们发现：两个不同的对象<code>person1</code>和<code>person2</code>，为什么<code>person1</code>添加了KVO可以监听到属性值的改变？</p><p>看起来<code>self.person1.age = 11</code> 和 <code>self.person2.age = 21</code>都是调用的<code>setAge:</code>方法，为什么<code>person1</code>就可以监听到属性值的改变了呢？我们可以大胆猜测一下<code>person1</code> 和<code>person2</code>的<code>setAge:</code>的具体实现肯定不一样了，也就是说<code>person1</code>的<code>isa</code>和<code>person2</code>的<code>isa</code>指向发生了变化，下面我们来验证一下我们的猜想。</p><div class="note green no-icon flat"><p><strong>验证一</strong>：</p><p>在<code>person1</code>添加KVO前后分别打印<code>person1</code>和<code>person2</code>的<strong>class对象</strong>：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;person1添加监听之前：person1:%@ person2:%@&quot;</span>,object_getClass(<span class="keyword">self</span>.person1),object_getClass(<span class="keyword">self</span>.person2));</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;person1添加监听之后：person1:%@ person2:%@&quot;</span>,object_getClass(<span class="keyword">self</span>.person1),object_getClass(<span class="keyword">self</span>.person2));</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-15</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">21.161924</span>+<span class="number">0800</span> OC对象的本质[<span class="number">81836</span>:<span class="number">15966659</span>] person1添加监听之前：person1:Person person2:Person</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-15</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">21.162217</span>+<span class="number">0800</span> OC对象的本质[<span class="number">81836</span>:<span class="number">15966659</span>] person1添加监听之后：person1:<span class="built_in">NSKVONotifying_Person</span> person2:Person</span><br></pre></td></tr></table></figure><p>如上：我们发现在<code>person1</code>添加了KVO之后，<code>person1</code>的<code>isa</code>指向的是<code>NSKVONotifying_Person</code>类，<code>person2</code>的<code>isa</code>指向的还是<code>Person</code>类。</p></div><div class="note orange no-icon flat"><p><strong>验证二</strong>：</p><p>在<code>person1</code>添加KVO前后分别打印<code>person1</code>和<code>person2</code>的<code>setAge:</code>方法的函数地址（IMP）：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;person1添加监听之前：person1:%p person1:%p&quot;</span>,[<span class="keyword">self</span>.person1 methodForSelector:<span class="keyword">@selector</span>(setAge:)], [<span class="keyword">self</span>.person2 methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;person1添加监听之后：person1:%p person1:%p&quot;</span>,[<span class="keyword">self</span>.person1 methodForSelector:<span class="keyword">@selector</span>(setAge:)], [<span class="keyword">self</span>.person2 methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-15</span> <span class="number">20</span>:<span class="number">32</span>:<span class="number">28.980113</span>+<span class="number">0800</span> OC对象的本质[<span class="number">81977</span>:<span class="number">15975768</span>] person1添加监听之前：person1:<span class="number">0x102539e70</span> person1:<span class="number">0x102539e70</span></span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-15</span> <span class="number">20</span>:<span class="number">32</span>:<span class="number">28.980454</span>+<span class="number">0800</span> OC对象的本质[<span class="number">81977</span>:<span class="number">15975768</span>] person1添加监听之后：person1:<span class="number">0x7fff207b1cfb</span> person1:<span class="number">0x102539e70</span></span><br></pre></td></tr></table></figure><p>如上：我们发现在<code>person1</code>添加了KVO之后，<code>person1</code>的<code>IMP</code>跟<code>person2</code>的<code>IMP</code>不一样。</p><p>通过LLDB指令：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// person1</span></span><br><span class="line">p (IMP) <span class="number">0x7fff207b1cfb</span></span><br><span class="line">(IMP) $<span class="number">0</span> = <span class="number">0x00007fff207b1cfb</span> (Foundation`_NSSetIntValueAndNotify)</span><br><span class="line"></span><br><span class="line"><span class="comment">// person2</span></span><br><span class="line">p (IMP) <span class="number">0x102539e70</span></span><br><span class="line">(IMP) $<span class="number">1</span> = <span class="number">0x0000000102539e70</span> (OC对象的本质`-[Person setAge:] at Person.h:<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p>如上：我们发现<code>person1</code>的<code>setAge:</code>方法其实是调用到了一个C函数：<code>_NSSetIntValueAndNotify</code>。</p></div><p>通过上面的分析：</p><p>1、我们看到<code>person1</code>添加了KVO之后，其<code>isa</code> 指针指向的是一个派生类<code>NSKVONotifying_Person</code>，这个类是Runtime在程序运行的过程中动态创建的一个类，这个类继承自<code>Person</code>。</p><p>2、在这个派生类里面调用了C函数：<code>_NSSetIntValueAndNotify</code>。</p><p>3、在<code>_NSSetIntValueAndNotify</code>里面实现如下代码：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">[<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">[<span class="variable language_">super</span> setAge:age];</span><br><span class="line">[<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br></pre></td></tr></table></figure><p>4、在<code>didChangeValueForKey</code>方法里面去通知监听器某个属性值发生了改变。</p><p><strong>用一张图来做一个总结</strong>：</p><p>未添加KVO监听的对象：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1115/1.png" alt="1"></p><p>使用KVO添加监听的对象：</p><p><img src="https://sunny-blog.oss-cn-beijing.aliyuncs.com/202211/1115/2.png" alt="2"></p><div class="note green no-icon flat"><p><strong>注意</strong>：</p><p>通过<code>Runtime</code>中的<code>object_class</code>拿到的class对象才是真正的class对象，通过<code>class</code>拿到的不一定是真正的class对象，比如使用了KVO监听的对象。</p></div><p>如何验证派生类<code>NSKVONotifing_Person</code>重写了哪些方法？</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">Class cls = object_getClass(<span class="keyword">self</span>.person1);</span><br><span class="line">[<span class="keyword">self</span> printMethodNameOfClass:cls];</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)printMethodNameOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,<span class="built_in">NSStringFromSelector</span>(method_getName(method)));</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-16</span> <span class="number">13</span>:<span class="number">36</span>:<span class="number">32.484809</span>+<span class="number">0800</span> OC对象的本质[<span class="number">26389</span>:<span class="number">16561796</span>] setAge:</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-16</span> <span class="number">13</span>:<span class="number">36</span>:<span class="number">32.484965</span>+<span class="number">0800</span> OC对象的本质[<span class="number">26389</span>:<span class="number">16561796</span>] <span class="keyword">class</span></span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-16</span> <span class="number">13</span>:<span class="number">36</span>:<span class="number">32.485084</span>+<span class="number">0800</span> OC对象的本质[<span class="number">26389</span>:<span class="number">16561796</span>] dealloc</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-16</span> <span class="number">13</span>:<span class="number">36</span>:<span class="number">32.485195</span>+<span class="number">0800</span> OC对象的本质[<span class="number">26389</span>:<span class="number">16561796</span>] _isKVOA</span><br></pre></td></tr></table></figure><p>从上面打印可以看到：<code>NSKVONotifinh_Person</code>类重写了<code>setAge:</code>、<code>class</code>、<code>dealloc</code>、<code>_isKVOA</code>方法。</p><h2 id="KVO的触发场景">KVO的触发场景</h2><p>从上面KVO的本质分析可以看到：只要有<code>setter</code>方法就可以通过KVO来监听值的改变，比如：属性值发生改变、通过KVC赋值。</p><p>请看下面场景：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// KVOController</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KVOViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Person *person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KVOViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">  <span class="keyword">self</span>.person = [[Person alloc] init];</span><br><span class="line">  <span class="keyword">self</span>.person-&gt;age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">  [<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">  <span class="comment">// 不会触发KVO</span></span><br><span class="line">  <span class="comment">// [self.person willChangeValueForKey:@&quot;age&quot;];</span></span><br><span class="line">  <span class="keyword">self</span>.person-&gt;age = <span class="number">11</span>;</span><br><span class="line">  <span class="comment">// [self.person didChangeValueForKey:@&quot;age&quot;];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="type">id</span>&gt; *)change context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%@对象的%@属性发生了改变：\n%@&quot;</span>,object, keyPath,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">  [<span class="keyword">self</span>.person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上：</p><p>通过<code>self.person-&gt;age = 11</code>不会触发KVO，原因相信大家都很清楚了，没有调用<code>setter</code>，可以在<code>self.person-&gt;age = 11</code>前后分别添加<code>[self.person willChangeValueForKey:@&quot;age&quot;]</code>和<code>[self.person didChangeValueForKey:@&quot;age&quot;]</code>来手动触发KVO。</p><p>也可以通过KVC赋值<code>[self.person setValue:@11 forKey:@&quot;age&quot;]</code>，这样就可以自动触发KVO。</p><h2 id="其他补充">其他补充</h2><p>如何查看某个方法的函数地址（IMP）？</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (IMP)methodForSelector:(SEL)aSelector;</span><br><span class="line">+ (IMP)instanceMethodForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;KVO的基本使用&quot;&gt;KVO的基本使用&lt;/h2&gt;
&lt;h3 id=&quot;基本使用&quot;&gt;基本使用&lt;/h3&gt;
&lt;p&gt;KVO：Key Value Observing（键值监听），用来监听某个对象属性值的改变。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;</summary>
      
    
    
    
    <category term="iOS" scheme="https://codersunny.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://codersunny.com/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://codersunny.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
